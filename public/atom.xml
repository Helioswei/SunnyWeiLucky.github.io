<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Helios</title>
  
  <subtitle>世人谓我恋长安，其实只恋长安某</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.helioswei.top/"/>
  <updated>2021-04-20T08:10:06.009Z</updated>
  <id>http://www.helioswei.top/</id>
  
  <author>
    <name>Helioswei</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>s3-亚马逊oss客户端源码编译</title>
    <link href="http://www.helioswei.top/article/4200273252.html"/>
    <id>http://www.helioswei.top/article/4200273252.html</id>
    <published>2021-04-20T06:22:17.000Z</published>
    <updated>2021-04-20T08:10:06.009Z</updated>
    
    <content type="html"><![CDATA[<p>​    cpp关于亚马逊S3的客户端源码编译，aws-sdk-cpp的记录。因为项目中使用了亚马逊的oss的存储，所以需要客户端去请求，进行一些文件的上传下载等工作。</p><h3 id="源码下载"><a href="#源码下载" class="headerlink" title="源码下载"></a>源码下载</h3><p>​    我们直接在GitHub上下载<a href="https://github.com/aws/aws-sdk-cpp.git">aws-sdk-cpp</a>。我们的服务器环境</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/aws/aws-sdk-cpp.git</span><br></pre></td></tr></table></figure><ul><li>Ubuntu 16.04.6 LTS</li><li>git version 2.7.4</li><li>cmake version 3.19.3</li><li>g++ (GCC) 7.4.0</li></ul><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>​    编译需要先参考官方文档，有一个基本的了解</p><ul><li><a href="https://docs.aws.amazon.com/sdk-for-cpp/v1/developer-guide/setup-linux.html">linux下编译</a></li><li><a href="https://docs.aws.amazon.com/sdk-for-cpp/v1/developer-guide/cmake-params.html#cmake-target-arch">cmake编译参数</a></li></ul><h4 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h4><p>​    我们在编译的时候需要依赖一些库：</p><ul><li>zlib;</li><li>openssl;</li><li>curl;</li></ul><h4 id="编译-1"><a href="#编译-1" class="headerlink" title="编译"></a>编译</h4><p>​    进入源码目录<code>aws-sdk-cpp</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd aws-sdk-cpp</span><br><span class="line">mkdir build</span><br></pre></td></tr></table></figure><p>编译静态库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake -DCMAKE_BUILD_TYPE=Release -DTARGET_ARCH=LINUX -DBUILD_SHARED_LIBS=OFF -DBUILD_ONLY=&quot;s3&quot; -DCMAKE_INSTALL_PREFIX=/usr/local/awssta ..</span><br></pre></td></tr></table></figure><p>编译动态库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake -DCMAKE_BUILD_TYPE=Release -DTARGET_ARCH=LINUX -DBUILD_ONLY=&quot;s3&quot; -DCMAKE_INSTALL_PREFIX=/usr/local/aws ..</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make -j5</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>使用时先学习<a href="https://docs.aws.amazon.com/sdk-for-cpp/v1/developer-guide/programming-general.html">官网的例子</a></p><ul><li>自己封装<a href="https://gitee.com/helioswei/testcode/tree/master/s3/aws">的使用</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;​    cpp关于亚马逊S3的客户端源码编译，aws-sdk-cpp的记录。因为项目中使用了亚马逊的oss的存储，所以需要客户端去请求，进行一些文件的上传下载等工作。&lt;/p&gt;
    
    </summary>
    
      <category term="Database" scheme="http://www.helioswei.top/categories/Database/"/>
    
      <category term="s3" scheme="http://www.helioswei.top/categories/Database/s3/"/>
    
    
      <category term="aws-sdk-cpp" scheme="http://www.helioswei.top/tags/aws-sdk-cpp/"/>
    
  </entry>
  
  <entry>
    <title>cpp-菜鸟回炉-内存分布之普通类</title>
    <link href="http://www.helioswei.top/article/202723234.html"/>
    <id>http://www.helioswei.top/article/202723234.html</id>
    <published>2021-03-28T07:14:20.000Z</published>
    <updated>2021-04-20T06:18:05.722Z</updated>
    
    <content type="html"><![CDATA[<p>​    本文记录一下CPP关于类的内存存储的情况，根据自己目前的水平写的文章，不当之处请指正。后期会根据自己的所学以及在实际的应用中来不断的更新自己的认识。目前自己使用的平台是Ubuntu18, g++7.4</p><h3 id="空类，空结构体，空联合体"><a href="#空类，空结构体，空联合体" class="headerlink" title="空类，空结构体，空联合体"></a>空类，空结构体，空联合体</h3><p>​    在CPP中，对于空类（class），空结构体（struct），空联合体（union）来说，其 内存大小为<code>1</code>。在C语言中，对空结构体，空联合体，其内存大小为0（c语言中没有类）。原因是：CPP中规定，不同的对象必须拥有不同的地址，如果为0为导致两个类的地址一样，在内存地址上就不能区分该类实例化的实例了。所以为了实现这个标准，编译器往往会给一个空类隐含的加一个字节，这样空类字实例化后字内存得到了一个独一无二的地址。如果不是空类，那么一个占位符就会失效，内存空间直接就是这些占内存的总和。参考我<a href="https://www.helioswei.top/article/734109955.html#more">内存对齐文章</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PR(x) std::cout &lt;&lt; #x &lt;&lt; <span class="meta-string">&quot;:&quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">B</span> &#123;</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PR(<span class="keyword">sizeof</span>(A));</span><br><span class="line">    PR(<span class="keyword">sizeof</span>(B));</span><br><span class="line">    PR(<span class="keyword">sizeof</span>(C));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;                                                                                                                                           </span><br></pre></td></tr></table></figure><h3 id="加入函数"><a href="#加入函数" class="headerlink" title="加入函数"></a>加入函数</h3><h4 id="加入普通函数"><a href="#加入普通函数" class="headerlink" title="加入普通函数"></a>加入普通函数</h4><p>​    如果我们往空类中加入函数（普通函数，构造函数，析构函数，静态函数，const函数），那么其内存大小会有变化吗？其内存大小<code>sizeof(C)</code>还是为1，因为其没有成员变量，成员函数是不占用这个类的内存空间的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>                                                                                                                                     </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    C()</span><br><span class="line">    &#123;   </span><br><span class="line">        PR(<span class="string">&quot;构造函数&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ~C()</span><br><span class="line">    &#123;   </span><br><span class="line">        PR(<span class="string">&quot;析构函数&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;   </span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">return</span> a ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;   </span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">10</span>; </span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">int</span>  <span class="title">getA</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;   </span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="加入虚函数"><a href="#加入虚函数" class="headerlink" title="加入虚函数"></a>加入虚函数</h4><p>​    如果我们往这个类里面加入虚函数，其结果内存空间的大小会是多少呢？其内存大小<code>sizeof(c)</code>为8，这是因为虚函数会有一个<code>虚表指针</code>，其大小为<code>一个指针</code>的占有的内存大小，布局在<code>类的开头</code>。编译器是在构造函数中创建这个虚表指针以及虚表的。类定义时只是在类的开头加了一个指向虚函数表的指针，而不是在类里加入虚函数数组。虚函数表也不是定义在类中的，这个类在产生多个对象是，会共用同样的虚函数表。纯虚函数同理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    C() </span><br><span class="line">    &#123;   </span><br><span class="line">        PR(<span class="string">&quot;构造函数&quot;</span>);</span><br><span class="line">    &#125;   </span><br><span class="line">    ~C()</span><br><span class="line">    &#123;   </span><br><span class="line">        PR(<span class="string">&quot;析构函数&quot;</span>);</span><br><span class="line">    &#125;                                                                                                                                       </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="继承类的内存大小"><a href="#继承类的内存大小" class="headerlink" title="继承类的内存大小"></a>继承类的内存大小</h3><h4 id="普通继承"><a href="#普通继承" class="headerlink" title="普通继承"></a>普通继承</h4><p>​    没有虚函数的基础，我们子类的空间大小会包含父类成员变量的大小以及自身定义的成员变量大小。内存分布是基类的在前面，子类的在后面。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;                                                                                                                     </span></span></span><br><span class="line"> <span class="number">2</span> <span class="meta">#<span class="meta-keyword">define</span> PR(x) std::cout &lt;&lt; #x &lt;&lt; <span class="meta-string">&quot;:&quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span></span><br><span class="line"> <span class="number">3</span> </span><br><span class="line"> <span class="number">4</span> <span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class"> 5 &#123;</span></span><br><span class="line"> <span class="number">6</span> <span class="keyword">public</span> :</span><br><span class="line"> <span class="number">7</span>     <span class="keyword">int</span> a;</span><br><span class="line"> <span class="number">8</span> <span class="keyword">private</span>:</span><br><span class="line"> <span class="number">9</span>     <span class="keyword">int</span> b;</span><br><span class="line"><span class="number">10</span> &#125;;</span><br><span class="line"><span class="number">11</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line"><span class="number">12</span> &#123;</span><br><span class="line"><span class="number">13</span> <span class="keyword">public</span>:</span><br><span class="line"><span class="number">14</span>     <span class="keyword">int</span> c;</span><br><span class="line"><span class="number">15</span> &#125;;</span><br><span class="line"><span class="number">16</span> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">17 </span>&#123;</span><br><span class="line"><span class="number">18</span>     PR(<span class="keyword">sizeof</span>(Base));<span class="comment">//sizeof(Base) 8</span></span><br><span class="line"><span class="number">19</span>     PR(<span class="keyword">sizeof</span>(Son));<span class="comment">//sizeof(Son) 12</span></span><br><span class="line"><span class="number">20</span>     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">21</span> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="有虚函数的继承"><a href="#有虚函数的继承" class="headerlink" title="有虚函数的继承"></a>有虚函数的继承</h4><p>​    子类会继承父类的虚函数指针。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">6</span> <span class="keyword">public</span> :</span><br><span class="line"> <span class="number">1</span> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> <span class="number">2</span> <span class="meta">#<span class="meta-keyword">define</span> PR(x) std::cout &lt;&lt; #x &lt;&lt; <span class="meta-string">&quot;:&quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span></span><br><span class="line"> <span class="number">3</span> </span><br><span class="line"> <span class="number">4</span> <span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class"> 5 &#123;</span></span><br><span class="line"> <span class="number">6</span> <span class="keyword">public</span> :</span><br><span class="line"> <span class="number">7</span>     <span class="keyword">int</span> a;</span><br><span class="line"> <span class="number">8</span> <span class="keyword">private</span>:</span><br><span class="line"> <span class="number">9</span>     <span class="keyword">int</span> b;</span><br><span class="line"><span class="number">10</span>     <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">11     </span>&#123;</span><br><span class="line"><span class="number">12</span>         PR(<span class="string">&quot;Base&quot;</span>)</span><br><span class="line"><span class="number">13</span>     &#125;;</span><br><span class="line"><span class="number">14</span> &#125;;</span><br><span class="line"><span class="number">15</span> </span><br><span class="line"><span class="number">16</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line"><span class="number">17</span> &#123;</span><br><span class="line"><span class="number">18</span> <span class="keyword">public</span>:</span><br><span class="line"><span class="number">19</span>     <span class="keyword">int</span> c;</span><br><span class="line"><span class="number">20</span>     <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">21     </span>&#123;</span><br><span class="line"><span class="number">22</span> </span><br><span class="line"><span class="number">23</span>         PR(<span class="string">&quot;Son&quot;</span>);</span><br><span class="line"><span class="number">24</span>     &#125;</span><br><span class="line"><span class="number">25</span> &#125;;</span><br><span class="line"><span class="number">26</span> </span><br><span class="line"><span class="number">27</span> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">28 </span>&#123;</span><br><span class="line"><span class="number">29</span>     Son son;</span><br><span class="line"><span class="number">30</span>     son.print();</span><br><span class="line"><span class="number">31</span>     PR(<span class="keyword">sizeof</span>(Base));<span class="comment">//sizeof(Base) 8 + 4 + 4 = 16,内存对齐</span></span><br><span class="line"><span class="number">32</span>     <span class="comment">//            vptr a  b   c  xx</span></span><br><span class="line"><span class="number">33</span>     <span class="comment">//sizeof(Son) 8 + 4 + 4 + 4 +4 = 24</span></span><br><span class="line"><span class="number">34</span>     PR(<span class="keyword">sizeof</span>(Son));</span><br><span class="line"><span class="number">35</span>     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">36</span> &#125;  </span><br></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://blog.nowcoder.net/n/cc17d398f41a4beb82b663ca0a72f35c">https://blog.nowcoder.net/n/cc17d398f41a4beb82b663ca0a72f35c</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;​    本文记录一下CPP关于类的内存存储的情况，根据自己目前的水平写的文章，不当之处请指正。后期会根据自己的所学以及在实际的应用中来不断的更新自己的认识。目前自己使用的平台是Ubuntu18, g++7.4&lt;/p&gt;
    
    </summary>
    
      <category term="Cpp" scheme="http://www.helioswei.top/categories/Cpp/"/>
    
      <category term="memory" scheme="http://www.helioswei.top/categories/Cpp/memory/"/>
    
    
      <category term="memory" scheme="http://www.helioswei.top/tags/memory/"/>
    
  </entry>
  
  <entry>
    <title>cpp-菜鸟回炉-操作系统内存对齐</title>
    <link href="http://www.helioswei.top/article/734109955.html"/>
    <id>http://www.helioswei.top/article/734109955.html</id>
    <published>2021-03-28T06:55:57.000Z</published>
    <updated>2021-04-20T06:18:05.722Z</updated>
    
    <content type="html"><![CDATA[<p> 最为一名程序员，你知道一个基础变量在计算机是怎样存储的吗？你知道一个整数占多大的空间？一个结构体占多大的空间？一个联合体占多个的空间？</p><h3 id="对齐"><a href="#对齐" class="headerlink" title="对齐"></a>对齐</h3><p>​    很多计算机系统对基础数据类型的可允许地址做了一个限制，要求某种类型的对象的地址必须是某个值k（通常是2，4，8）的倍数。这种对齐限制简化了处理器和存储器系统之间接口的硬件设计。假如，一个处理器总是从存储器中取8个字节的数据出来，则地址必须为8的倍数。如果我们能保证所有的double都将他们的地址对齐为8的倍数，那么就可以用一个存储器操作来读或者写值了。否则我们可能要执行两次存储器访问，因为对象可能分布在两个8字节存储器中。</p><p>​    确保每种数据类型都是按照指定方式来组织和分配的，即每种类型的对象都满足它的对齐限制，就可以保证实施对齐。<code>编译器</code>在汇编代码中放入命令，指明全局数据所需要的对齐。当然我们自己在代码中也可以控制，这个后面在说。</p><h3 id="对齐规则"><a href="#对齐规则" class="headerlink" title="对齐规则"></a>对齐规则</h3><p>​    每个特定平台上的编译器都有自己默认的“对齐系数”。可以通过预编译命令<code>#pragma pack(n)</code>, n = 1,2,4,8来改变这一系数。若没有手动指定，那么编译器就会默认将成员变量中最大的类型字节数设置为对齐值：m</p><h4 id="有效对齐值"><a href="#有效对齐值" class="headerlink" title="有效对齐值"></a>有效对齐值</h4><p>​    有效对其值：是给定值<code>#pragma pack(n)</code>和结构体中最长数据类型长度中<code>较小</code>的那个。有效对齐值也叫<strong>对齐单位</strong>。</p><p>了解了上面的概念后，我们现在可以来看看内存对齐需要遵循的规则：</p><p>(1) 结构体第一个成员的<strong>偏移量（offset）</strong>为0，以后每个成员相对于结构体首地址的 offset 都是<strong>该成员大小与有效对齐值中较小那个</strong>(即·<code>对齐单位</code>)的整数倍，如有需要编译器会在成员之间加上填充字节。</p><p>(2) <strong>结构体的总大小</strong>为 有效对齐值 的<strong>整数倍</strong>，如有需要编译器会在最末一个成员之后加上填充字节。</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>考虑下面的结构体，使用系统默认的设置，分析其内存分布</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ubuntu 64位，sizeof(int) 4字节</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>假设编译器用的是最小的9字节分配，画出来的图是这样的<img src="/images/memory/offset1.png" alt="offset1.png"></p><p>它是不可能满足域i（偏移量是0）和j（偏移量是5）的4字节对齐要求的。所有编译器在域c和域j之间插入了一个3字节的空隙（此处用xxx表示）。<img src="/images/memory/offset2.png" alt="offset2.png"></p><p>另外编译器可能需要添加一些填充到结构体的末尾，这样结构数组的每个元素都会满足它的对齐要求。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ubuntu 64位，sizeof(int) 4字节</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/images/memory/offset3.png" alt="offset3.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ubuntu64位，sizeof(int) 4字节，sizeof(double) 8字节</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">double</span> d;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">sizeof</span>(A) = <span class="number">24</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">double</span> d;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">sizeof</span>(B) = <span class="number">32</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 最为一名程序员，你知道一个基础变量在计算机是怎样存储的吗？你知道一个整数占多大的空间？一个结构体占多大的空间？一个联合体占多个的空间？&lt;/p&gt;
    
    </summary>
    
      <category term="Cpp" scheme="http://www.helioswei.top/categories/Cpp/"/>
    
      <category term="memory" scheme="http://www.helioswei.top/categories/Cpp/memory/"/>
    
    
      <category term="memory" scheme="http://www.helioswei.top/tags/memory/"/>
    
  </entry>
  
  <entry>
    <title>cpp-菜鸟回炉-操作系统内存管理</title>
    <link href="http://www.helioswei.top/article/279221372.html"/>
    <id>http://www.helioswei.top/article/279221372.html</id>
    <published>2021-03-28T06:55:31.000Z</published>
    <updated>2021-04-20T06:18:05.738Z</updated>
    
    <content type="html"><![CDATA[<p>   本文介绍操作系统对变量的内存管理相关的内容。要能够更清楚的看懂本章的内容，需要先看一下我上一章程序编译原理中提到的操作系统的抽象相关内容。</p><h3 id="信息存储"><a href="#信息存储" class="headerlink" title="信息存储"></a>信息存储</h3><p>​    大多数的计算机使用8位的块，或称为<code>字节</code>（byte），来作为最小的可寻址的存储器单位，而不是访问存储器中单独的位。机器级程序将存储器视为一个非常大的字节数组，成为<code>虚拟存储器</code>。存储器的每个字节都由一个唯一的数字来标识，称为它的<code>地址</code>，所有可能地址的集合就称为<code>虚拟地址空间</code>。正如它的名字表明的，这个虚拟地址空间只是展现给机器级程序的概念性映像。实际的实现是随机访问存储器RAM，磁盘存储，特殊硬件和操作系统软件的结合，来为程序提供一个看上去统一的字节数组。</p><h4 id="十六进制表示法"><a href="#十六进制表示法" class="headerlink" title="十六进制表示法"></a>十六进制表示法</h4><p>​    <img src="/images/memory/hex.png" alt="hex.png"></p><h4 id="字"><a href="#字" class="headerlink" title="字"></a>字</h4><p>​    每台计算机都有一个字长，指明<code>整数</code>和<code>指针数据</code>的标称大小。因为虚拟地址就是以这样的字来编码的，所以字长决定的最重要的参数是虚拟地址空间的最大大小。也就是说，对于一个字长为n位的机器而言，虚拟地址的范围为0~2^n-1,程序最大访问2^n字节。</p><p>​    今天大多数的计算机的字长为64位，这就限制了虚拟地址空间为8千兆（8GB）。</p><h4 id="数据大小"><a href="#数据大小" class="headerlink" title="数据大小"></a>数据大小</h4><p>​    <code>计算机</code>和<code>编译器</code>使用不同的方式来编码数字，比如不同长度的整数和浮点数，从而支持多种数字格式。准确的字节数依赖于机器和编译器。我们展示典型的32位机器和64位机器中的基础类型的字节长度。<img src="/images/memory/byte.png" alt="byte.png"></p><h4 id="寻址和字节顺序"><a href="#寻址和字节顺序" class="headerlink" title="寻址和字节顺序"></a>寻址和字节顺序</h4><p>​    对于跨越多字节的程序对象，我们必须建立两个规则：</p><ul><li>这个对象的地址是什么；</li><li>我们在存储器中如何对这些字节排序；字节排序有两种形式，分为<code>大端法</code>和<code>小端法</code>：<ul><li><strong>小端法</strong>：某些机器选择在存储器中按照从最低有效字节到最高有效字节的顺序存储对象，最低有效字节在最前面的方式被称为小端法，即数据的高字节保存在内存的高地址中，数据的低字节保存在内存的低地址中；<ul><li>大多数源自以前的Digital Equipment公司（现在是Compaq公司的一部分）的机器及其Intel的机器都采用这种规则。</li></ul></li><li><strong>大端法</strong>：另外一些机器选择在存储器中按照从最高有效字节到最低有效字节的顺序存储对象，最高有效字节在最前面的方式被称为大端法，即数据的高字节保存在内存的低地址中，数据的低字节保存在内存的高地址中；这个与我们的阅读习惯一致。<ul><li>IBM，Motorola,Sun Microsytems的大多数机器都采用这种规则。</li></ul></li></ul></li></ul><p>​        在几乎所有的机器中，多字节对象都被存储为连续的字节序列，对象的地址为所使用字节序列中最小的地址。例如，假设一个类型为int的变量x的地址为0x100，也就是说，地址表达式&amp;x的值为0x100。那么x的四个字节将被存储在存储器的0x100,0x101,0x102,0x103位置。</p><p>​        对于大多数的程序员来说，他们机器字节的顺序是完成不可见的。无论为哪种类型的机器所编译的程序都可以得到相同的结果。不过有时间，字节顺序会成为问题。</p><ul><li><p>不同机器之间通过网络传递二进制数据时，当小端法机器产生的数据被发送到大端法的机器上或者反之时，接受程序会发现字里的字节成了反序的。为了避免这种问题，网络应用程序的代码编写必须遵守已经建立的关于字节顺序的规则，以确保发送方机器将其内部表示转换成网络标准，而接收方机器则将网络标准转换成其内部的表示。</p></li><li><p>判断机器是大端还是小端的方法；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> a;</span><br><span class="line">        <span class="keyword">char</span> c;</span><br><span class="line">    &#125;Un;<span class="comment">//联合体共用内存</span></span><br><span class="line">    <span class="comment">//假设当前的内存地址为           00 01 02 03</span></span><br><span class="line">    <span class="comment">//int a 4个字节，大端法的内存分布 12 34 56 78;</span></span><br><span class="line">    <span class="comment">//int a 4个字节，小端法的内存分布 78 56 34 12;</span></span><br><span class="line">    Un.a = <span class="number">0x12345678</span>;<span class="comment">//12是数据的高字节哦                                                                                                  </span></span><br><span class="line">    <span class="keyword">if</span> (Un.c == <span class="number">0x12</span>)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;big&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(Un.c == <span class="number">0x78</span>)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;little&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h3 id="整数数据类型的存储"><a href="#整数数据类型的存储" class="headerlink" title="整数数据类型的存储"></a>整数数据类型的存储</h3><p>​    计算机编码整数有两种方式：</p><ul><li>一种只能表示非负数；<ul><li>对于这种整数，计算机的存储直接将其转换为对应的二进制，然后直接存储。</li></ul></li><li>另一种可以表示负数，零，正数；<ul><li>对于这种整数，计算机通过<code>二进制补码</code>的方式来进行存储，它的定义是将<code>最高有效位</code>解释为<code>负权</code>，也成为<code>符号位</code>。当被设置为<code>1</code>时，表示值为<code>负数</code>；当被设置为<code>0</code>时，值为<code>非负</code>。</li><li>原码：就是符号加绝对值</li><li>反码：正数的反码就是原码，负数的反码是保持符号位不变，其他位取反；</li><li>补码：正数的补码就是原码，负数的补码为反码+1；</li></ul></li></ul><p><img src="/images/memory/int.png" alt="int.png"></p><h3 id="浮点数数据类型的存储"><a href="#浮点数数据类型的存储" class="headerlink" title="浮点数数据类型的存储"></a>浮点数数据类型的存储</h3><p>​    计算机中的浮点数的存储是按照IEEE（电气电子工程师学会）标准来的 <img src="/images/memory/ieee.png" alt="ieee.png"></p><p>​    示例可以<a href="https://blog.csdn.net/xxssyyyyssxx/article/details/51586959">参考文章</a></p><h3 id="数组分配和访问"><a href="#数组分配和访问" class="headerlink" title="数组分配和访问"></a>数组分配和访问</h3><p><img src="/images/memory/array.png" alt="array.png"></p><h3 id="指针计算"><a href="#指针计算" class="headerlink" title="指针计算"></a>指针计算</h3><p><img src="/images/memory/ptr.png" alt="ptr.png"></p><h3 id="虚拟存储器"><a href="#虚拟存储器" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h3><p>​    为了更有效的管理存储器并且少出错，现代操作系统提供了一个对主存的抽象概念，叫做虚拟存储器。虚拟存储器是硬件异常，硬件地址翻译，主存，磁盘文件和内核软件的完美交互，它为进程提供了一个大的，一致的，私有地址空间。通过一个很清晰的机制，虚拟存储器提供了三个重要的能力：</p><ul><li>它将主存看成是一个存储在磁盘上的地址空间的高速缓存，在主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据，通过这种方式，它高效的使用了主存；</li><li>它为每个进程提供了一致的地址空间，从而简化了存储器管理；</li><li>它保护了每个进程的地址空间不被其他进程破环。</li></ul><p>虚拟存储器是计算机系统最重要的概念之一。它成功的一个主要的原因就是因为它是沉默地，自动的工作，不需要应用程序员的任何干涉。既然虚拟存储器在幕后工作的如此之好，为什么程序员还需要理解它呢？有以下几个原因：</p><ul><li><strong>虚拟存储器是中心的</strong>。虚拟存储器遍及计算机系统的所有层面，在硬件异常，汇编器，链接器，加载器，共享对象，文件和进程的设计中扮演着重要的角色。理解虚拟存储器将帮助你更好的理解系统通常是如何工作的。</li><li><strong>虚拟存储器是强大的</strong>。虚拟存储器给予应用程序强大的能力，可以创建和破坏存储器块，将存储器块映射到磁盘文件的某个部分，以及与其他进程共享存储器。比如，你知道你可以通过读写存储器位置读或者修改一个磁盘文件的内容吗？或者你可以加载一个文件的内容到存储器中，不需要进行任何的显示的拷贝吗？理解虚拟存储器将帮助你利用它的强大的能力在你的应用程序中添加动力。</li><li><strong>虚拟存储器是危险的</strong>。每个应用程序引用一个变量，间接引用一个指针，或者调用一个诸如malloc这样动态分配包程序时，它就会和虚拟存储器进行交互。如果虚拟存储器使用不当，应用将遇到复杂险恶的与存储器有关的错误。例如一个带有错误指针的程序可以立即崩溃于”<strong>段错误</strong>“或者”<strong>保护错误</strong>“。</li></ul><p>独立的地址空间允许每个进程为它的存储器映像使用相同的基本格式，而不管代码和数据实际存放在物理存储器的何处。例如每个Linux进程使用如图所示的格式。文本区总是从虚拟地址<strong>0x08048000</strong>处开始的，栈总是从地址<strong>0xbfffffff</strong>向下伸展，共享代码库总是从地址<strong>0x40000000</strong>，而操作系统代码和数据总是从地址<strong>0xc0000000</strong>开始。这样一致性极大的简化了链接器的设计和实现，允许链接器生成全链接的可执行目标文件，这些可执行文件是独立于物理存储器中代码和数据的最终位置。<img src="/images/memory/linuxmemory1.png" alt="linuxmemory1.png"></p><h3 id="程序中代码和数据的存储位置"><a href="#程序中代码和数据的存储位置" class="headerlink" title="程序中代码和数据的存储位置"></a>程序中代码和数据的存储位置</h3><p>​    在计算机中每个程序的内存是相互独立的，都是在虚拟存储器中开辟的空间。虚拟地址空间（查看我上一篇文章程序编译原理）有大量准确定义的区，每个区都有专门的功能：<img src="/images/memory/linuxmemory.png" alt="linuxmemory.png"></p><ul><li><code>栈</code>：位于虚拟地址空间顶部的是用户栈，系统自己分配，存放临时变量包括，局部变量，返回值，参数，返回地址等；</li><li><code>堆</code>:  主要用于动态内存的分配，在程序开发中，一般是开发人员进行分配与释放，</li><li><code>读/写区域</code>：主要存放全局变量，静态变量;<ul><li><code>data</code>：data区里主要存放的是已经初始化的全局变量、静态变量；</li><li><code>bss</code>：bss区主要存放的是未初始化的全局变量、静态变量，这些未初始化的数据在程序执行前会自动被系统初始化为0或者NULL；</li></ul></li><li><code>只读区</code>：主要存放const修饰的变量/字符常量，二进制代码。(关于const变量存疑？)<ul><li>init：</li><li>text：已经编译的程序的代码；</li><li>rodata：只读数据，比如printf语句中的格式串和switch语句的跳转表；</li></ul></li></ul><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>​    全文皆是摘录自<a href="https://gitee.com/helioswei/books">《深入理解计算机系统》</a>一书，用于自己的学习和理解，若存在侵权请联系作者。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;   本文介绍操作系统对变量的内存管理相关的内容。要能够更清楚的看懂本章的内容，需要先看一下我上一章程序编译原理中提到的操作系统的抽象相关内容。&lt;/p&gt;
    
    </summary>
    
      <category term="Cpp" scheme="http://www.helioswei.top/categories/Cpp/"/>
    
      <category term="memory" scheme="http://www.helioswei.top/categories/Cpp/memory/"/>
    
    
      <category term="memory" scheme="http://www.helioswei.top/tags/memory/"/>
    
  </entry>
  
  <entry>
    <title>cpp-菜鸟回炉-程序链接详解</title>
    <link href="http://www.helioswei.top/article/1117780254.html"/>
    <id>http://www.helioswei.top/article/1117780254.html</id>
    <published>2021-03-28T06:55:04.000Z</published>
    <updated>2021-04-20T06:18:05.741Z</updated>
    
    <content type="html"><![CDATA[<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>链接就是将不同代码和数据收集和组合成为一个单一文件的过程，这个文件可被加载（或被拷贝）到存储器并执行。</p><p>链接发生的时机有以下几种：</p><ul><li>链接可以发生于编译时，也就是在源代码被翻译成机器代码时；</li><li>也可以发生与加载时，也就是在程序被加载器加载到存储器并执行时；</li><li>甚至执行与运行时，由应用程序来执行；</li></ul><p>链接通常是由链接器来安静的处理，对于那些在编程入门课堂上构造小程序的学生来说，链接不是一个重要的议题。那为什么还有这么麻烦的学习关于链接的知识呢？</p><p>​    链接器的两个主要的任务：</p><ul><li>符号解析（symbol resolution）：目标文件定义和引用符号。符号解析的作用是将每个符号引用和一个符号定义联系起来；</li><li>重定位（relocation）：编译器和汇编器生成从零开始的代码和数据节。链接器通过把每个符号定义与一个存储器位置联系起来，然后修改所有这些对符号的引用，使得他们指向这个存储器的位置，从而重定位这些节。</li></ul><p>在你阅读的时候，要记住关于链接器的一些基本的事实：目标文件存粹是字节快的集合。这些快中，有些包含程序代码，有效包含程序数据，而其他的则包含指导链接器和加载器的数据结构。链接器将这些库链接起来，确定被链接块的运行时位置，并且修改代码和数据块中的各个位置。链接器对目标机器了解甚少，产生目标文件的编译器和汇编器已经完成了大部分工作。</p><h3 id="了解链接的好处"><a href="#了解链接的好处" class="headerlink" title="了解链接的好处"></a>了解链接的好处</h3><ul><li>理解链接器将帮助你构造大型程序。构造大型程序的程序员经常会遇到由于缺少模块，缺少库或者不兼容的库版本引起的链接器错误。除非你理解链接器是如何的解析引用，什么是库以及链接器是如何的使用库来解析引用的，否则这些错误将会使用迷惑和挫败；</li><li>理解链接器将帮助你避免一些危险的编程错误。Unix链接器解析符号引用时所做的决定可以不动声色的影响你程序的正确性。在默认情况下，错误的定义多个全局变量的程序将通过链接器，而不产生任何警告信息。由此得到的程序会产生迷惑的运行时行为，而且非常难以调试。</li><li>理解链接将帮助你理解语言的作用域规则是如何实现的。例如全局和局部变量的区别是什么？当你定义一个具有静态属性的变量或者函数时，到底实际意味着什么？</li><li>理解链接器将帮助你理解其他重要的系统概念。</li><li>理解链接器将使你能够开发共享库。随着共享库和动态链接在现代操作系统中日益加强的重要性，链接成为了一个复杂的过程，它为知识丰富的程序员提供了强大的能力。比如，许多软件产品使用共享库在运行时来升级压缩包装的二进制程序。</li></ul><h3 id="目标文件"><a href="#目标文件" class="headerlink" title="目标文件"></a>目标文件</h3><p>​    目标文件有三种形式：</p><ul><li>可重定位目标文件：包含二进制代码和数据，其形式可以在编译时与其他可重定位目标文件合并起来，创建一个可执行目标文件；</li><li>可执行目标文件：包含二进制代码和数据，其形式可以直接被拷贝到存储器并执行；</li><li>共享目标文件：一种特殊类型的可重定位目标文件，可以在加载或者运行时，被动态的加载到存储器并链接。</li></ul><p>编译器和汇编器生成可重定位目标文件（包含共享目标文件），链接器生成可执行目标文件。</p><h3 id="加载可执行目标文件"><a href="#加载可执行目标文件" class="headerlink" title="加载可执行目标文件"></a>加载可执行目标文件</h3><p>​    每个Unix程序都有一个运行时存储器映像。如图<img src="/images/memory/linuxmemory.png" alt="linuxmemory.png"></p><h3 id="从应用程序中加载和链接共享库"><a href="#从应用程序中加载和链接共享库" class="headerlink" title="从应用程序中加载和链接共享库"></a>从应用程序中加载和链接共享库</h3><p>​    应用程序还可能在它运行时要求动态链接器加载和链接任意共享库，而无需在编译时链接那些库到应用中。动态链接是一项强大有用的技术。向linux这样的Unix系统，为动态链接器提供了一个简单的接口，允许应用程序在运行时加载和链接共享库。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dlfcn.h&gt;                                                                                                                          </span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">dlopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* filename, <span class="keyword">int</span> flag)</span></span>;</span><br><span class="line"><span class="comment">//返回：若成功则为指向句柄的指针，若出错则为NULL</span></span><br></pre></td></tr></table></figure><p>​    <code>dlopen</code>函数加载和链接共享库<code>filename</code>。用以前带<code>RELD_GLOBAL</code>选项打开的库解析filename中的外部符号。如果当前可执行文件是带<code>-rdynamic</code>选项编译的，那么对符号解析而言，它的全局符号也是可用的。flag参数必须要么包括<code>RELD_NOW</code>,该标志告诉链接器立即解析外部符号的引用，要么包含<code>RELD_LAZY</code>标志，该标志指示链接器推迟符号解析直到执行来自库中的代码时。这两个中的任何一个都可以和<code>RELD_GLOBAL</code>标志取或。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dlfcn.h&gt;                                                                                                                          </span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">dlsym</span><span class="params">(<span class="keyword">void</span>* handle, <span class="keyword">char</span>* symbol)</span></span>;</span><br><span class="line"><span class="comment">//返回：若成功则为指向符号的指针，若出错则为NULL</span></span><br></pre></td></tr></table></figure><p><code>dlsym</code>函数的输入是一个指向前面已经打开共享库的句柄和一个符号的名字，如果该符号存在，就返回符号的地址，否则则为NULL。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dlfcn.h&gt;                                                                                                                          </span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">dlclose</span><span class="params">(<span class="keyword">void</span>* handle, <span class="keyword">char</span>* symbol)</span></span>;</span><br><span class="line"><span class="comment">//返回：若成功则为指向符号的指针，若出错则为NULL</span></span><br></pre></td></tr></table></figure><p>如果没有其他共享库还在使用这个共享库，<code>dlclose</code>函数就卸载该共享库。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dlfcn.h&gt;                                                                                                                          </span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">dlerror</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="comment">//返回：若前面对dlopen,dlsym,dlclose的调用失败，则为错误消息，若前面的调用成功，则为NULL。</span></span><br></pre></td></tr></table></figure><p><code>dlerror</code>函数返回一个字符串,它描述的是调用<code>dlopen</code>,<code>dlsym</code>,<code>dlclose</code>函数时发生的最近的错误，如果没有错误发生则发回空。</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>在addvec.c文件中，创建下面的代码，构建一个动态库。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;                                                                                                                           </span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addvec</span><span class="params">(<span class="keyword">int</span>* x, <span class="keyword">int</span>* y, <span class="keyword">int</span>* z, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;   </span><br><span class="line">        z[i] = x[i] + y[i];</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -shared -fPIC -o libaddvec.so addvec.c </span><br></pre></td></tr></table></figure><p>在test.c文件中，动态的加载共享库，如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x[<span class="number">2</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> y[<span class="number">2</span>] = &#123;<span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> z[<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span>* handle;</span><br><span class="line">    <span class="keyword">void</span> (*addvec)(<span class="keyword">int</span>*, <span class="keyword">int</span>*, <span class="keyword">int</span>*, <span class="keyword">int</span>);</span><br><span class="line">    <span class="keyword">char</span>* error;</span><br><span class="line">    <span class="comment">//dynamically load the shared library that contains addvec()</span></span><br><span class="line">    handle = dlopen(<span class="string">&quot;./libaddvec.so&quot;</span>, RTLD_LAZY);</span><br><span class="line">    <span class="keyword">if</span> (handle == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s\n&quot;</span>, dlerror());</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//get a pointer to the addvec() function we just loaded</span></span><br><span class="line">    addvec = dlsym(handle, <span class="string">&quot;addvec&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ((error = dlerror()) != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s\n&quot;</span>, dlerror());</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Now we can call addvec() just like any other function</span></span><br><span class="line">    addvec(x, y, z, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;z = [%d %d]\n&quot;</span>, z[<span class="number">0</span>], z[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">//unload the shared library</span></span><br><span class="line">    <span class="keyword">if</span> (dlclose(handle) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s\n&quot;</span>, dlerror());</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">                                                                                                                                                               </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">s</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -rdynamic -O2 -o test test.c  -ldl</span><br></pre></td></tr></table></figure><h3 id="处理目标文件的工具"><a href="#处理目标文件的工具" class="headerlink" title="处理目标文件的工具"></a>处理目标文件的工具</h3><p>​    在Unix系统中有大量可用的工具可以帮助你理解和处理目标文件。特别地，GNU binutils包尤其有帮助，而且可以运行在每个Unxi平台上。</p><ul><li><code>ar</code>：创建静态库，插入，删除，列出和提取成员；</li><li><code>strings</code>：列出一个目标文件中，所有可打印的字符串；</li><li><code>strip</code>：从目标文件中删除符号表信息；</li><li><code>nm</code>：列出一个目标文件的符号表中定义的符号；</li><li><code>size</code>：列出目标文件中节的名字和大小；</li><li><code>readelf</code>：显示一个目标文件中的完整结构，包括ELF头中编码的所有信息。包含size和nm的功能；</li><li><code>objdump</code>：所有二进制工具之母，能够显示一个目标文件中所有的信息。它最有用的功能是反汇编.text节中的二进制指令。</li><li><code>ldd</code>：列出一个可执行文件在运行时所需要的共享库；（Unix系统为共享库提供的ldd程序）</li></ul><h3 id="操作进程的工具"><a href="#操作进程的工具" class="headerlink" title="操作进程的工具"></a>操作进程的工具</h3><p>​    unix系统提供了大量的监控和操作进程的有用工具：</p><ul><li><code>strace</code>：打印一个程序和它的子程序调用的每个系统调用的轨迹。对于好奇的学生而言，这是一个令人着迷的工具。用-static编译你的程序，能得到一个清晰的轨迹，而不带有大量与共享库相关的输出；</li><li><code>ps</code>：列出系统中当前的进程（包括僵尸进程）；</li><li><code>top</code>：打印出关于当前进程资源的使用的信息；</li><li><code>kill</code>：发送一个信号给进程。对于调试带信号处理程序以及清除难以捉摸的进程是非常有用的。</li><li><code>/proc</code>：一个虚拟文件系统，以ASCII文本格式输出大量内核数据结构的内容，用户程序可以读取这些内容。</li></ul><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>​    全文皆是摘录自<a href="https://gitee.com/helioswei/books">《深入理解计算机系统》</a>一书，用于自己的学习和理解，若存在侵权请联系作者。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;链接&quot;&gt;&lt;a href=&quot;#链接&quot; class=&quot;headerlink&quot; title=&quot;链接&quot;&gt;&lt;/a&gt;链接&lt;/h3&gt;
    
    </summary>
    
      <category term="Cpp" scheme="http://www.helioswei.top/categories/Cpp/"/>
    
      <category term="memory" scheme="http://www.helioswei.top/categories/Cpp/memory/"/>
    
    
      <category term="memory" scheme="http://www.helioswei.top/tags/memory/"/>
    
  </entry>
  
  <entry>
    <title>cpp-菜鸟回炉-程序编译原理</title>
    <link href="http://www.helioswei.top/article/1580317473.html"/>
    <id>http://www.helioswei.top/article/1580317473.html</id>
    <published>2021-03-28T06:51:56.000Z</published>
    <updated>2021-04-20T06:18:05.739Z</updated>
    
    <content type="html"><![CDATA[<p>​    菜鸟的自我学习之路。</p><p>​    本文介绍程序的编译原理以及运行过程中发生了什么。</p><h3 id="程序编译过程"><a href="#程序编译过程" class="headerlink" title="程序编译过程"></a>程序编译过程</h3><p>​    我们的源程序实际上就是一个由0和1组成的位（又成为比特）序列，这些位被组织成8个一组，称为字节，每个字节都表示程序中某个文本字符。大部分的操作系统都使用ASCII标准来表示文本字符，这种方式实际上就是用一个唯一的字节大小的整数值来表示每个字符。</p><p>​    为了能够在系统上运行我们的代码，每条ｃ语言都必须被其他程序转换为一系列的<strong>低级机器语言指令</strong>。然后这些指令按照一种称为<strong>可执行目标程序</strong>的格式打包好，并以<strong>二进制磁盘文件</strong>的形式存放起来。目标程序也称为可执行目标文件。在Unix系统上，从源文件到目标文件的转换是由编译器驱动程序完成的，如ｇcc。对于一个简单的程序，如hello.c，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span>                                                                                                          </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="number">1111</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o hello hello.c</span><br></pre></td></tr></table></figure><p>​    在这里gcc编译驱动程序读取源程序hello.c，并将其翻译成一个可执行目标文件hello。这个编译过程是分四个基本完成的。如图，执行这四个阶段的程序（预处理器，编译器，汇编器，链接器）一起构成了编译系统。<img src="/images/memory/gcc.png" alt="gcc.png"></p><ul><li><p>预处理阶段：预处理器（cpp）根据以字符#开头的命令，修改原始的c程序。比如hello.c中的第一行的#include&lt;stdio.h&gt;指令告诉预处理器读取系统头文件stdio.h的内容，并把其直接插入到程序文本中去。结果得到另一个c程序，通常是以<code>.i</code>作为文件扩展名。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -E hello.c  -o hello.i</span><br></pre></td></tr></table></figure></li><li><p>编译阶段：编译器（ccl）将文本文件<code>hello.i</code>翻译成文本文件<code>hello.s</code>,它包含一个<code>汇编语言程序</code>。汇编语言程序中的每条语句都以一种标准的文本格式确切描述了一条低级机器语言指令。汇编程序是非常有用的，因为它为不同高级语言程序中的不同编译器提供了通用的输出语句。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -S hello.i  -o hello.s</span><br></pre></td></tr></table></figure></li><li><p>汇编阶段：接下来汇编器（as）将<code>hello.s</code>翻译成<code>机器语言指令</code>，把这些指令打包成一种叫做<code>可重定位目标程序格式</code>。并将结果保存在目标文件<code>hello.o</code>中。hello.o文件是一个二进制的文件，它的字节编码是机器语言指令而不是字符，如果我们在文本编译器中打开hello.o文件，呈现的将是一堆乱码。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c hello.s  -o hello.o</span><br></pre></td></tr></table></figure></li><li><p>链接阶段：请注意，我们的hello程序调用了printf函数，它是标准c库中的一个函数，每个c编译器都提供。printf函数存在于一个叫printf.o的单独的预编译目标文件中，而这个文件必须以某种方式并入到我们的hello.o程序中。链接器(ld)就是负责这种并入，结果得到一个hello文件，它是一个<code>可执行目标文件</code>(或称可执行文件)。可执行程序加载到存储器后，由系统负责执行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc hello.o -o hello</span><br></pre></td></tr></table></figure></li></ul><p><code>cpp的编译过程同理，只是我们的编译成换成了g++,上面分步编译的命令同样适用</code></p><h3 id="理解编译系统如何工作的好处"><a href="#理解编译系统如何工作的好处" class="headerlink" title="理解编译系统如何工作的好处"></a>理解编译系统如何工作的好处</h3><h4 id="优化程序性能"><a href="#优化程序性能" class="headerlink" title="优化程序性能"></a>优化程序性能</h4><p>​    现代编译器都是成熟的工具，通常可以生成很好的代码。作为程序员，我们无需为了写出高效的代码而去了解编译器内部的工作。但是为了在我们的程序里面做出好的代码选择，我们确实需要对汇编语言以及编译器如何将不同的c语句转换为汇编语言有一些基础的了解。比如：一个switch语句是不是总是比一系列的if-else语句高效呢？一个函数的代价有多少？while循环比do循环更有效吗？指针引用比数组引用更有效吗?</p><h4 id="理解链接时出现的错误"><a href="#理解链接时出现的错误" class="headerlink" title="理解链接时出现的错误"></a>理解链接时出现的错误</h4><p>​    根据我们的经验，一些令人困扰的程序错误往往都与链接器操作有关，尤其是当你试图建立大型的软件系统时。比如，链接器报告说它无法解析一个引用，这是什么意思？静态变量和全局变量的区别是什么？静态库和动态库的区别是什么？</p><h4 id="避免安全漏洞"><a href="#避免安全漏洞" class="headerlink" title="避免安全漏洞"></a>避免安全漏洞</h4><p>​    近年来，缓冲区的溢出错误造成了大多数的网络和Internet服务器上的安全漏洞。这些错误的存在是因为大多数的程序员忽视了编译器用来为函数产生代码的堆栈规则。</p><h3 id="程序运行时发生了什么"><a href="#程序运行时发生了什么" class="headerlink" title="程序运行时发生了什么"></a>程序运行时发生了什么</h3><p>​    为了了解运行时hello程序发生了什么，我们需要理解一个典型系统的硬件组织，下图是Inter Pentium系统产品族的模型，<img src="/images/memory/system.png" alt="system.png"></p><p><code>CPU:中央处理器；ALU：算术/逻辑单元；PC：程序计数器；USB：通用串行总线</code></p><h4 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h4><p>​    贯穿整个系统的是一组电子管道，成为总线，它携带信息字节并负责在各个部件之间传递。通常总线被设计成传送定长的字节快，也就是字(word)。字中的字节数（即字长）是一个基本的系统参数，各个系统中也不尽相同。比如，Inter Pentiu系统的字长是4个字节，而服务器类的系统，比如Inter Itaninums和高端的Sun公司的SPARCS的字长是8个字节.用于汽车和工业中的嵌入式控制器之类较小的系统的字长往往只有一或两个字节.</p><h4 id="IO设备"><a href="#IO设备" class="headerlink" title="IO设备"></a>IO设备</h4><p>​    IO设备是系统与外界的联系通道.我们的示例系统包含了四个io设备:作为用户输入的键盘和鼠标,作为用户输出的显示器,以及用于长期存储数据和程序的磁盘驱动器(简单的说就是磁盘).</p><p>​    每个IO设备都是通过一个控制器和适配器与IO总线进行连接的.控制器和适配器之间的区别主要在于它们的组成方式.控制器是IO设备本身中或者系统的主印制电路板(通常称为主板)上的芯片组,而适配器则是一块插在主板插槽上的卡.无论无何,它们的功能都是在IO总线和IO设备之间传递信息.</p><h4 id="主存"><a href="#主存" class="headerlink" title="主存"></a>主存</h4><p>​    主存是一个临时存储设备,在处理器执行程序时,它被用来存放程序和程序处理的数据.物理上来说，主存是由一组DRAM（动态随机存储器）芯片组成的。逻辑上来说，存储器是由一个<strong>线性的字节数组</strong>组成的，每个字节都有字节唯一的地址（数组索引），这些地址是从0开始的。一般来说，组成程序的每条机器指令都由不定量的字节构成。与C程序变量相对应的数据项的大小是根据类型变化的。比如，运行LInux的Inter机器上，short类型的数据需要2个字节，int,float和long类型需要4个字节，而double类型需要8个字节。</p><h4 id="处理器"><a href="#处理器" class="headerlink" title="处理器"></a>处理器</h4><p>​    中央处理单元（CPU）简称处理器，只解释（或执行）存储在主存中指令的引擎。处理器的核心是一个被称为<code>程序计数器</code>（PC）的字长大小的存储设备（或寄存器。在任何时间点上，PC都指向主存中的某条<code>机器语言指令</code>（内含其地址）。</p><p>​    从系统通电开始，直到系统断电，处理器一直在不假思索的重复执行相同的基本任务：从程序计数器指向的存储器处读取指令，解释指令中的位，执行指令指示的简单操作，然后更新程序计数器指向下一条指令，而这条指令并不一定在存储器中和刚刚执行的指令相邻。</p><p>​    这样简单操作的数目并不多，它们在主存，寄存器文件和<code>算法逻辑单元</code>（ALU）之间循环。寄存器文件是一个小的存储设备，由一些字长大小的寄存器组成，这些寄存器每个都有唯一的名字。ALU计算新的数据和地址值。</p><h4 id="程序运行"><a href="#程序运行" class="headerlink" title="程序运行"></a>程序运行</h4><p>​    我们做一个粗略的描述：</p><p>​    首先，shell程序执行它的指令，等待我们输入命令。当我们在键盘输入字符串./hello后，shell程序就逐一读取字符到寄存器，再把它存储到存储器中，如下图。<img src="/images/memory/hello1.png" alt="hello1.png"></p><p>​    当我们在键盘上敲回车键时，shell就知道我们已经结束了命令的输入。然后shell执行一系列的指令将hello目标文件中的代码和数据从磁盘拷贝到主存中，从而加载hello文件。</p><p>​    利用称为DMA（直接存储器存取）的技术，数据可以不通过处理器而直接从磁盘到达主存，如图<img src="/images/memory/hello2.png" alt="hello2.png"></p><p>​    一旦hello目标文件中的代码和数据被加载到了存储器，处理器就开始执行hello程序的主程序中的机器指令。这些指令将<code>hello world</code>串中的字节从存储器拷贝到寄存器文件，再从寄存器中文件拷贝到显示设备，最终显示到设备上，如图<img src="/images/memory/hello3.png" alt="hello3.png"></p><p>​    通过这个简单的示例我们了解到了重要的一课，那就是系统花费了大量的时间把信息从一个地方挪到另一个地方。hello程序的机器指令最初存放在磁盘上，当程序加载的时候，它们被拷贝到主存。当处理器运行程序时，指令由从存储器拷贝到处理器。从一个程序员的角度来看，大量的拷贝减慢了程序实践的工作。因此，一个系统设计者的一个主要的目标就是使这些拷贝操作尽可能的快。下图是存储器层次模型的示例。<img src="/images/memory/memory.png" alt="memory.png"></p><h4 id="操作系统管理硬件"><a href="#操作系统管理硬件" class="headerlink" title="操作系统管理硬件"></a>操作系统管理硬件</h4><p>​    当shell加载和运行hello程序时,当hello程序输出自己的消息时,程序没有直接的访问键盘,显示器,磁盘或者主存储器.取而代之的是它们依靠操作系统提供的服务。我们可以把操作系统看成是应用程序和硬件之间插入的一层软件如下图，所有的应用程序对硬件的操作都必须通过操作系统。<img src="/images/memory/system2.png" alt="system2.png"></p><p>​    操作系统的两个基本的功能：</p><ul><li>防止硬件被失控的应用程序滥用；</li><li>在控制复杂而又通常广泛不同的低级硬件设备方面，为应用程序提供简单一致的方法；</li></ul><p>操作系统通过下面图片显示的几个基本的抽象概念（进程，虚拟存储器，文件）来实现上述的两个功能。</p><ul><li>文件：对IO设备的抽象表示；<ul><li>文件只不过就是字节序列。每个IO设备，包括磁盘，键盘，显示器，甚至是网络，都可以被看成是文件。系统中的所有输入和输出都是通过使用称为Unix IO的一小组系统函数调用读写文件来实现的</li></ul></li><li>虚拟存储器：对主存和磁盘IO设备的抽象表示；<ul><li>它为每个进程提供一个假象，好像每个进程都在独占地使用主存。每个进程看到的存储器都是一致的，称为虚拟地址空间，如下图是Linux进程的虚拟地址空间（其他的Unix系统的设计与此类似）。在Linux中，最上面的四分之一的地址空间是预留给操作系统中的代码和数据的，这对所有的进程都一样。底部的四分之三的地址空间用来存放用户进程定义的代码和数据。请注意图中的地址是从下往上增大的<img src="/images/memory/virtualmemory.png" alt="virtualmemory.png">每个进程进程看到的虚拟地址空间由大量准确定义的区（area)构成，每个区都有专门的功能。<ul><li>程序代码和数据：代码是从同一固定地址开始的，紧接着的是和C全局变量相对应的数据区。代码和数据区是由可执行目标文件直接初始化的；</li><li>堆：代码和数据区后紧随的就是运行时堆。代码和数据区是进程一旦开始运行时就被指定了大小，与次不同，作为调用了向malloc和free这边的c标准库函数的结果，堆可以在运行时动态的扩展和收缩；</li><li>共享库：在地址空间的中间附近是一块用来存放像C标准库和数学库这样共享库的代码和数据的区域；</li><li>栈：位于用户虚拟地址空间顶部的是用户栈，编译器用它来实现函数的调用。和堆一样，用户栈在程序执行期间可以动态的扩展和收缩。特别的，每次我们调用一个函数时，栈就会增长。每次我们从函数返回时，栈就会收缩；</li><li>内核虚拟存储器。内核是操作系统总是驻留在存储器中的部分。地址空间顶部的四分之一的部分是为内核预留的。应用程序不允许读写这块区域的内容或者直接调用内核代码定义的函数。</li></ul></li></ul></li><li>进程：对处理器，主存，和IO设备的抽象表示；</li></ul><p><img src="/images/memory/system3.png" alt="system3.png"></p><h4 id="Unix和Posix"><a href="#Unix和Posix" class="headerlink" title="Unix和Posix"></a>Unix和Posix</h4><p><img src="/images/memory/posix.png" alt="posix.png"></p><h4 id="Linux项目"><a href="#Linux项目" class="headerlink" title="Linux项目"></a>Linux项目</h4><p>​    1991年8月，一个名为Linux Torvalds的芬兰研究生谨慎的发布了一个新的类Unix的操作系统内核。<img src="/images/memory/linux.png" alt="linux.png"></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>​    全文皆是摘录自<a href="https://gitee.com/helioswei/books">《深入理解计算机系统》</a>一书，用于自己的学习和理解，若存在侵权请联系作者。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;​    菜鸟的自我学习之路。&lt;/p&gt;
    
    </summary>
    
      <category term="Cpp" scheme="http://www.helioswei.top/categories/Cpp/"/>
    
      <category term="memory" scheme="http://www.helioswei.top/categories/Cpp/memory/"/>
    
    
      <category term="memory" scheme="http://www.helioswei.top/tags/memory/"/>
    
  </entry>
  
  <entry>
    <title>linux-生成ssh key</title>
    <link href="http://www.helioswei.top/article/2022323734.html"/>
    <id>http://www.helioswei.top/article/2022323734.html</id>
    <published>2021-03-04T05:37:04.000Z</published>
    <updated>2021-03-04T08:00:03.419Z</updated>
    
    <content type="html"><![CDATA[<p>​    我们在使用git的时候经常需要用到ssh的连接，本文记录一下自己在使用的时候怎么生成的ssh key的过程。</p><h3 id="平台"><a href="#平台" class="headerlink" title="平台"></a>平台</h3><p>​    我使用的平台是Ubuntu16，查看的命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/lsb-release</span><br></pre></td></tr></table></figure><h3 id="ssh-key的生成"><a href="#ssh-key的生成" class="headerlink" title="ssh key的生成"></a>ssh key的生成</h3><h4 id="检测本地是否有SSH-Key的存在"><a href="#检测本地是否有SSH-Key的存在" class="headerlink" title="检测本地是否有SSH Key的存在"></a>检测本地是否有SSH Key的存在</h4><p>​    使用下面的命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -la ~/.ssh</span><br></pre></td></tr></table></figure><p>​    如果输出的是下面的内容，则表示没有，我们需要生成。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls: cannot access &#39;&#x2F;home&#x2F;weiyang&#x2F;.ssh&#39;: No such file or directory</span><br></pre></td></tr></table></figure><p>​    如果存在则就会显示下面的内容，我们直接使用就好了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">total 8</span><br><span class="line">drwx------ 2 weiyang weiyang   38 Mar  4 13:43 .</span><br><span class="line">drwxr-xr-x 4 weiyang weiyang  123 Mar  4 13:42 ..</span><br><span class="line">-rw------- 1 weiyang weiyang 1766 Mar  4 13:43 id_rsa</span><br><span class="line">-rw-r--r-- 1 weiyang weiyang  405 Mar  4 13:43 id_rsa.pub</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="生成"><a href="#生成" class="headerlink" title="生成"></a>生成</h4><p>​    使用下面的命令生成，按照操作来就行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen</span><br></pre></td></tr></table></figure><p>​    提示设置 passphrase，每次与 Git 通信都会要求输入 passphrase，以避免某些错误的操作所导致的问题，建议设置一下。成功后在终端输入下面命令，此时会要求输入上面步骤里所填的 passphrase。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-add ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure><p>​    使用下面命令获取公钥，然后拷贝到自己的git上就行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat .ssh&#x2F;id_rsa.pub</span><br></pre></td></tr></table></figure><p>​    如果你在使用时不想用passphrase,则使用下面的命令删除</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -p [-P old_passphrase] [-N new_passphrase] [-f keyfile]</span><br><span class="line"></span><br><span class="line">ssh-keygen -p -P 123456 -N &#39;&#39; -f ~&#x2F;.ssh&#x2F;id_rsa</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;​    我们在使用git的时候经常需要用到ssh的连接，本文记录一下自己在使用的时候怎么生成的ssh key的过程。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://www.helioswei.top/categories/Linux/"/>
    
    
      <category term="ssh" scheme="http://www.helioswei.top/tags/ssh/"/>
    
  </entry>
  
  <entry>
    <title>cpp-包管理工具vcpkg使用</title>
    <link href="http://www.helioswei.top/article/2441447756.html"/>
    <id>http://www.helioswei.top/article/2441447756.html</id>
    <published>2021-03-03T08:37:41.000Z</published>
    <updated>2021-03-04T02:59:06.133Z</updated>
    
    <content type="html"><![CDATA[<p>​    体验一下cpp的包管理工具vcpkg的使用，<a href="https://github.com/microsoft/vcpkg/blob/master/README_zh_CN.md">git地址</a>。vcpkg是Microsoft的跨平台开源软件包的管理器，极大的简化了在不同平台上第三方库的安装。如果项目要使用第三方库，建议通过 vcpkg 来安装它们。vcpkg 同时支持开源和专有库。微软对其的介绍可以查看<a href="https://docs.microsoft.com/zh-cn/cpp/build/vcpkg?view=msvc-160&amp;viewFallbackFrom=vs-2019">地址</a>。我们在做cpp的开发时，经常会使用到第三方的库，在编译这些时我们要做哪些考虑呢?比如：Debug还是Release、动态库还是静态库、MD还是MT、32位还是64位。光是这三种组合就有16种可能性。如果像libcurl这种还要考虑是否引用其他开源库的功能，那么编译类型的组合会更多。管理起来很麻烦。由于多样的编译类型，工程目录也必须仔细设定才能保证自己的软件项目能够正常编译。</p><p>​    使用vcpkg的优点：</p><ul><li>自动下载开源库源代码</li><li>源码包的缓存管理和版本管理，可以升级版本</li><li>轻松编译</li><li>依赖关系检查（比如编译libcurl，会自动下载zlib、openssl进行编译）</li><li>无缝集成Visual Studio，不需要设置库文件、头文件的所在目录，自动集成。</li><li>Visual Studio全平台支持，不仅支持Debug/Release、x86/x64编译，还支持UWP、ARM平台的编译。</li></ul><h3 id="Ubuntu下部署"><a href="#Ubuntu下部署" class="headerlink" title="Ubuntu下部署"></a>Ubuntu下部署</h3><h4 id="依赖软件"><a href="#依赖软件" class="headerlink" title="依赖软件"></a>依赖软件</h4><ul><li>git</li><li>g++ &gt;=6</li></ul><h4 id="依赖工具"><a href="#依赖工具" class="headerlink" title="依赖工具"></a>依赖工具</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install build-essential tar curl zip unzip</span><br></pre></td></tr></table></figure><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>​    安装过程可以参考<a href="https://docs.microsoft.com/zh-cn/cpp/build/install-vcpkg?view=msvc-160&amp;tabs=linux">地址</a>。如果电脑中没有安装cmake，vcpkg会自动下载portable版本的cmake。但是由于各种原因，下载的网速很慢，所以建议先自行下载安装msi版本的cmake。最好是下载最新版本的cmake。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/microsoft/vcpkg</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;vcpkg&#x2F;bootstrap-vcpkg.sh</span><br></pre></td></tr></table></figure><p>安装成功后会在当前vcpkg的目录下产生一个vcpkg的命令行的工具。</p><h5 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h5><p>所有 vcpkg 功能和数据都自包含在实例的单独目录层次结构中。 没有注册表设置或环境变量。 可以在一台计算机上设置任意数量的 vcpkg 实例，它们彼此互不干扰。</p><p>vcpkg 实例的内容如下：</p><ul><li><code>buildtrees</code> - 包含从中生成每个库的源的子文件夹。</li><li><code>docs</code> - 文档和示例。</li><li><code>downloads</code> - 所有已下载的工具或源的缓存副本。 运行安装命令时，vcpkg 会首先搜索此处。</li><li><code>installed</code> - 包含每个已安装库的标头和二进制文件。 与 Visual Studio 集成时，实质上是相当于告知它将此文件夹添加到其搜索路径。</li><li><code>packages</code> - 在不同的安装之间用于暂存的内部文件夹。</li><li><code>ports</code> - 用于描述每个库的目录、版本和下载位置的文件。 如有需要，可添加自己的端口。</li><li><code>scripts</code> - 由 vcpkg 使用的脚本（CMake、PowerShell）。</li><li><code>toolsrc</code> - vcpkg 和相关组件的 C++ 源代码。</li><li><code>triplets</code> - 包含每个受支持目标平台（如 x86-windows 或 x64-uwp）的设置。</li></ul><h4 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h4><p>​    vcpkg 包管理器在 GitHub 上定期更新。 若要将 vcpkg 的克隆更新到最新版本，请从 vcpkg 根目录运行 <code>git pull</code>。 此命令会将 vcpkg 的副本与 GitHub 上的版本同步。 下载完成后，再次运行引导程序。 引导程序会重新生成 vcpkg 程序，但保留已安装的库。</p><h4 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h4><p>​    若要卸载 vcpkg，只需删除 <code>vcpkg</code> 目录。 删除此目录会卸载 vcpkg 分发以及 vcpkg 已安装的所有库。</p><p>但是，如果已执行 <code>vcpkg integrate install</code>，则应执行 <code>vcpkg integrate remove</code> 来确保在删除文件夹之前已清理集成 。 有关详细信息，请参阅<a href="https://docs.microsoft.com/zh-cn/cpp/build/integrate-vcpkg?view=msvc-160">集成 vcpkg</a>。这个是Windows下集成到IDE使用的，在Linux下开发的不用关心。</p><h3 id="命令行使用"><a href="#命令行使用" class="headerlink" title="命令行使用"></a>命令行使用</h3><p>​    记录一下常用的命令行。具体的命令行的使用可以参考<a href="https://docs.microsoft.com/zh-cn/cpp/build/vcpkg-command-line-reference?view=msvc-160">地址</a></p><h4 id="search"><a href="#search" class="headerlink" title="search"></a>search</h4><p>​    您也可以使用 <code>search</code> 子命令来查找vcpkg中已集成的库。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./vcpkg/vcpkg search [search term]</span><br></pre></td></tr></table></figure><p>​    您也可以查看具体的某个包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./vcpkg/vcpkg search uuid</span><br></pre></td></tr></table></figure><h4 id="install"><a href="#install" class="headerlink" title="install"></a>install</h4><p>​    使用以下命令安装任意包。linux下默认编译生成的是静态库。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;vcpkg&#x2F;vcpkg install [packages to install]</span><br></pre></td></tr></table></figure><h5 id="指定编译某种架构的程序库"><a href="#指定编译某种架构的程序库" class="headerlink" title="指定编译某种架构的程序库"></a>指定编译某种架构的程序库</h5><p>​    如果不指定安装的架构，vcpkg默认把开源库编译成x86的Windows版本的库。那vcpkg总共支持多少种架构呢？我们可以使用如下命令便知：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;vcpkg&#x2F;vcpkg help triplet</span><br></pre></td></tr></table></figure><p>​    vcpkg不仅支持x86架构，还支持arm架构。注意：这里的arm架构特指类似于surface这种运行在arm处理器上的Win10平台，而并非我们传统意义上的Linux或android的ARM平台。那如果要安装编译某一个架构的开源库，我们该怎么写呢？我们只需要在需要安装的包后面指定相应的triplet即可。例如我们需要编译64位版本的jsoncpp，那么执行如下命令即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;vcpkg&#x2F;vcpkg  install jsoncpp:x64-linux</span><br></pre></td></tr></table></figure><p>​    例如安装uuid,先用<code>search</code>命令查找具体的包的名字，然后在使用<code>install</code>进行安装。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./vcpkg/vcpkg search uuid</span><br><span class="line">./vcpkg/vcpkg install libuuid</span><br></pre></td></tr></table></figure><h5 id="动态库编译"><a href="#动态库编译" class="headerlink" title="动态库编译"></a>动态库编译</h5><p>​    Linux平台默认编译的是静态库，如果要编译动态库则可以参照<a href="https://github.com/microsoft/vcpkg/blob/master/docs/examples/overlay-triplets-linux-dynamic.md">这篇文章</a></p><h4 id="list"><a href="#list" class="headerlink" title="list"></a>list</h4><p>​    查看已经安装的开源库。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./vcpkg/vcpkg list</span><br></pre></td></tr></table></figure><h4 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h4><p>​    移除一个已经安装的库。 如果有其他库依赖它，系统会提示你使用 <code>--recurse</code> 重新运行命令；重新运行会导致下游的所有库都被删除。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./vcpkg/vcpkg remove libuuid</span><br></pre></td></tr></table></figure><h4 id="upgrade"><a href="#upgrade" class="headerlink" title="upgrade"></a>upgrade</h4><p>​    公共目录始终与最新版本的库保持一致。 要判断哪个本地库已过期，请使用 <code>vcpkg update</code>。 准备好将端口集合更新到最新版本的公共目录后，请运行 <code>vcpkg upgrade</code> 命令。 它会自动下载并重新生成已过期的任意或所有已安装的库。</p><p>默认情况下，<code>vcpkg upgrade</code> 命令仅列出过期库，不对它们进行升级。 若要真正升级这些库，请使用 <code>--no-dry-run</code> 选项。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vcpkg upgrade --no-dry-run</span><br></pre></td></tr></table></figure><p>升级选项：</p><ul><li><code>--no-dry-run</code>：执行升级；若未指定，该命令将仅列出过期的包。</li><li><code>--keep-going</code>：继续安装包（即使某项失败）。</li><li><code>--triplet &lt;t&gt;</code>：为非限定的包设置默认的三元组。</li><li><code>--vcpkg-root &lt;path&gt;</code>：指定要使用的 vcpkg 目录，而不是使用当前目录或工具目录。</li></ul><h4 id="export"><a href="#export" class="headerlink" title="export"></a>export</h4><p>​    导出一个安装好的包。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;vcpkg&#x2F;vcpkg export jsoncpp --zip</span><br></pre></td></tr></table></figure><p>注意，导出时必须指定导出的包格式。vcpkg支持5种导出包格式，有：</p><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">格式</th></tr></thead><tbody><tr><td style="text-align:left">–raw</td><td style="text-align:left">以不打包的目录格式导出</td></tr><tr><td style="text-align:left">–nuget</td><td style="text-align:left">以nuget包形式导出</td></tr><tr><td style="text-align:left">–ifw</td><td style="text-align:left">我也不知道这是啥格式</td></tr><tr><td style="text-align:left">–zip</td><td style="text-align:left">以zip压缩包形式导出</td></tr><tr><td style="text-align:left">–7zip</td><td style="text-align:left">以7z压缩包形式导出</td></tr></tbody></table><p>​    如果要指定输出目录和特定文件名，需使用”–output=”参数</p><h4 id="import"><a href="#import" class="headerlink" title="import"></a>import</h4><p>​    导入一个包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;vcpkg&#x2F;vcpkg import xxx.zip</span><br></pre></td></tr></table></figure><h4 id="cmake"><a href="#cmake" class="headerlink" title="cmake"></a>cmake</h4><p>​    和cmake配合使用可以通过下面的命令。这个是需要在命令行中输入。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-DCMAKE_TOOLCHAIN_FILE&#x3D;&quot;&#x2F;home&#x2F;helios&#x2F;work&#x2F;source&#x2F;vcpkg&#x2F;scripts&#x2F;buildsystems&#x2F;vcpkg.cmake&quot;</span><br></pre></td></tr></table></figure><p>​    另一种方法是直接在项目顶层的CMakeLists.txt中设置变量，必须在project参数设置之前设置下面的参数。在需要使用的地方通过find_package既可以。</p><ul><li>CMAKE_TOOLCHAIN_FILE  你的vcpkg.cmake的路径;</li><li>VCPKG_TARGET_TRIPLET  你的平台架构名字，通过<code>./vcpkg/vcpkg help tripl</code> 来查看</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set(CMAKE_TOOLCHAIN_FILE /home/helios/work/source/vcpkg/scripts/buildsystems/vcpkg.cmake CACHE PATH &quot;&quot;)</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="built_in">set</span>(VCPKG_TARGET_TRIPLET x64-linux CACHE PATH <span class="string">&quot;&quot;</span>)</span></span><br></pre></td></tr></table></figure><p>​    对于你安装的软件，执行<code>install</code>之后会告诉你怎么在camke中使用，例如下面的：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">The package sqlite3:x64-linux provides CMake targets:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">find_package</span>(unofficial-sqlite3 CONFIG REQUIRED)</span><br><span class="line">    <span class="keyword">target_link_libraries</span>(main PRIVATE unofficial::sqlite3::sqlite3))</span><br></pre></td></tr></table></figure><p>​    最后一种方法，直接在cmake文件中添加其头文件和动态库的地址。</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>​    官网介绍了一个例子，可以用于学习，<a href="https://github.com/microsoft/vcpkg/blob/master/docs/examples/installing-and-using-packages.md">地址</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;​    体验一下cpp的包管理工具vcpkg的使用，&lt;a href=&quot;https://github.com/microsoft/vcpkg/blob/master/README_zh_CN.md&quot;&gt;git地址&lt;/a&gt;。vcpkg是Microsoft的跨平台开源软件包的管理器，极大的简化了在不同平台上第三方库的安装。如果项目要使用第三方库，建议通过 vcpkg 来安装它们。vcpkg 同时支持开源和专有库。微软对其的介绍可以查看&lt;a href=&quot;https://docs.microsoft.com/zh-cn/cpp/build/vcpkg?view=msvc-160&amp;amp;viewFallbackFrom=vs-2019&quot;&gt;地址&lt;/a&gt;。我们在做cpp的开发时，经常会使用到第三方的库，在编译这些时我们要做哪些考虑呢?比如：Debug还是Release、动态库还是静态库、MD还是MT、32位还是64位。光是这三种组合就有16种可能性。如果像libcurl这种还要考虑是否引用其他开源库的功能，那么编译类型的组合会更多。管理起来很麻烦。由于多样的编译类型，工程目录也必须仔细设定才能保证自己的软件项目能够正常编译。&lt;/p&gt;
    
    </summary>
    
      <category term="Cpp" scheme="http://www.helioswei.top/categories/Cpp/"/>
    
      <category term="vcpkg" scheme="http://www.helioswei.top/categories/Cpp/vcpkg/"/>
    
    
      <category term="vcpkg" scheme="http://www.helioswei.top/tags/vcpkg/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://www.helioswei.top/article/1243066710.html"/>
    <id>http://www.helioswei.top/article/1243066710.html</id>
    <published>2021-03-01T02:04:04.277Z</published>
    <updated>2021-03-01T02:04:04.277Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>cpp-学习计划</title>
    <link href="http://www.helioswei.top/article/3248960382.html"/>
    <id>http://www.helioswei.top/article/3248960382.html</id>
    <published>2021-02-28T09:48:45.000Z</published>
    <updated>2021-03-01T02:04:04.266Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="0196dd85c43caac64bbfa355b3ca5e3e5665c94318adcf7a800c9b43f13c4a6b">fb9f6fbb8fc1d993240686705025b43532348148d53fb91ba5b377f724fe5b62c8b3848ff11810ef0eef03060f6fa9f6e50d44b812aff7d5fdc4437d49bc3ec3e31345cea2d12cf0e10c9263a9a720edff928b1331435c3804bd25a85f9996d78dbbe9dc1d7b7f8b067c0e6ab72a5244de9bfb995d4843af7c253efaf6e2fec00b653d0a3d104ff27b30871fa5d9d573046181f461ad2df13ae2a784c5beefb1a453a0e4f92a555e1053de39ef1ad8fad0b97503b1b218349f9fbad1388bc847448b3e178d64e5d1272e1f401c1edf874c176a20d808f075129a21b0aad9e0c5053566f26dc591b18fd817f14a3f907f1d35de0afe1f1ebde4dbfc57a6cf7e9d512dea436830ac2bf71fc1345931b2309bc730a8463fab9cdc10dde3ae2f2503c266c6bba6609f08b9245d973d3882cafb7c9f3447a40deddaec734cc607cde984d0098163d6ce69eaa1b3b794082e61455b2bf6f9791d3ae907269f301b98eeaffffc22a4f4213e858894cacce10edde3da2679e75f6ab333a2ce5d686868e18f8cb03814d2479f0e2774efb5530cd77f2d3e8c4ed354e8240481d4477536828e5d6af0b50eb43d8c362395dae9b6efa53ff7d5c71208134ebb53f662635c4435365e35059de2fe2c6aff04d13d64b7a8b2fa751922a8c9872b28efba30596ba9004699cb3dcd4896ba2f234a8a434299ab5d94f38a1bfeb6c861fdcdd70bd84de3aa5eafd0d45145028488924eb8963f37593d7b03cf6516781ec062f0933839c13aa332a5a3abed20e6f9e7b066143f36b909c51b98a637866fc8c63f27e4b0a836a6b8bd6bcf8a20920faa431370ca45d096c4efa237a1ce0d2b2cc70cef5d6672d0fd33f8ab6af34e5b720999286593004dfc75a83a0df6f3e79689d83614c02297619315243468250579241ac8d03ef9320c1173c9eb3727c5a9779f768c7acac2fa606d7009d5ec15b98238bc474fb5e8d96ca52a319f99c739272c909daa79a2ac59ede1fff686176c4ce47ef8db249073cb831fdbc94fd55be03fada6fb13910d71ad18fbed5f86da55552236642859ac12f99e1635a22b4e9a886d55e4d4834511c241fb7f66de318550fcd3dcfb141970e8099d8cacdd43feef3afc171dc1f4650d52966b8cf092c43a37bb5b29c793aaa8cd52cfac690cb4cefb837a9a030505cd5f147cc3abb5d372718f083412da4c91a7c905c9e2b6528bd1bdc597648351606f4e70705a3a34a1fc4b83b609f2d8e7efc299a2cea4df796897048acafe9247e9a32b366af8244bf3cfedef1676044f44d26c823a4fec672faa053f71a5e765ac5dfde7b3616fa20d1b68fbcea0d67bd8bff3548f9ce657cbf79bfcb9272b9213c27e3e1cce80a4c228191ab3eec2b305a504292053d2ee78dc4caf283f5d32a48511ebdaac7a2176736c5b5b53258376fc3acc4138d8c3c5affa138da0a531334c5c53668eeb661d8ff995bb95d46ab48b5c16c89f89682434830801d63b7cfdae2458797ac9455e6021abecc847a17dbec5279ac984e77e90178e45ad1f7dc718d03759f3790c04d63264ff7815b7827d475a8b4cea58f1496ef0e696e487776bea8e6f66627077826229f4ced8d7ac6e5a9a1ae2ef09087cf7082930a040787ec1ddef886de4f884765a767cbc5f11793aae222f1bdcc6e35f67e2303ec93a1c10955dcc7156fe6c8f33b7211e9d90949c2a6c16207e963dd1403631e51d78bed697b6622212222b5c4109fe1c17574ff39ffb83a1d1c40575109615873079a3b95533ebbcbe72219fabf30c055a666eebd0ad025c3d663bca9131a82bf044fc51f9b13b9c0d51d51bdc28afd7476f351f50ecd5fd7cf1a5bf40d1c9d8b5692ac443ee18e1d1c47aa917dfec4e4d09246e1329267c9689577bf566fc6f3c6678bbaf2478adcea5809aa0a187b10dc8ad3a9990ed11a137a943315ff6f2fee9ab0b4d3ba8200e905b8301f5e037f975ec74ff1c7037921ecff9d002f04a8f83de136bf2ae447c1a92ec0d6a748cde1873ccaf3685803bdd1704e36ca7dad35236f4f913be709b6f8d7db12a553cc51c987058dbca05bcc396776d0c7ccf09dde0421f7f5bcccaa72b155060d4fe21d2e69ef492dbcace542be74bb46b328f2b5f017769d70370ae612147433110cb3b92ad72ebcc65c4467f6b04f2356483a9d0315e1186e2b55b9ba7c115c5855110d0eea323935da0316bf635c30f0f6adb6f253636090a0ed43f446d5a36dec9915b76c2d0c67d79a8d10e23a22dfe99b3691f3b056251488e7075994b6e00293f01d9730a3478f91fbe388a4ddfc13ab17017ed0a41eaa371121b20511491082fe2d865ea70fb5c58a231a586facb8c99d0975f0afa7e3fffe76b274e7ee5fcafc01ef9cd5d1779405a2748aebea29238d6de71e7a38202c277ec706d82778f9f0da2121780b6bb799d3ec265d85bab9ab4706b3be28a403010f1075689e414f37c57b5a85625907a857f8935bcdaa65ab14dc7abe6ffcb4e18493f6693cfb3106cc970629643566821b3e591435255238bfdd1c84cf2e24f299d579ab99f252c7d349362905d8daf2c483922ac63d9b40afdbe23908da7a80b4659260af3704addae263d122e368b8322cffb10024efd238af0d7f17b6f96e15c0a6ddf0329930987dcdf5d15c20f338d44a05b42ab1f4a93a6629bbabc3d8869eb1004dd906af2915a3435680e469678367dd441f098c5f2a24481d93bb610eb3c7a3b5bdcf22c0064756af8d9f02749d21e0daca5f6a862081c72b0a10354436f3f37466663f74d68a3a360fcc44f394cb3c728d137e8dee34270770f2beeeff98e7bf2c4848a8e93a57b0a1c14ca52a4679c2960ae0337a57590acb81ad471c333e8ed3f82bbf44b1cd704f5de2ecc676da91b0bac1eb1685124924fb5fe488dda425554b4e8ae4f98d5f9e2c260a47265f4aa37583cb6556ad425ba9dfbbd999f7da19d5e36ebfb8ae64aabb990901affd2667da1080b37746f6c18dffec796c6d65e9e1336c2afe165e716d7310a2ce5a83ffa2f379e7e24090aa70a734d2fae2611f950d9b7b8f3424a5bd0e6f7434ca14fc2bc21b023802b9f4f602919fcc4be0c6c8ea97af2c8afc31c69201cbc67cf306be629c668a097e87e541925cdc09f786cbb5739895732a53229fc5f552c2299cf2fe909b6a8fe9bf67d5d0118a7fc5be5da51eb34a783371b9c572315f5b4c8999efa0b6943808c3b577d4261acd4cfd94ae63ad0c6e403051c53090d19ee9dc1f772ca5b4e04b0f854329a2380c72f5700b6d1ada5d814155279a0e639a715e0564115e7b26a5ffa51ccb00bb868469a7a8ada54fdaa31e77e35830508db80cb678b7ee3711302733291a440e9a798adea55be57f7876c36a7b408e99e7a59abc028570a1660d54410c2db9b99d896bdd27dee3f115179340ae46d69706dda0ba04acb3471719da4e032fa093de6ed0dfbe8a5ec7ed6942cd877dd2a814146e35e800137747fe32745fb4af60a0bd0d48bcbe53eabf67990a5afd1d68f816390705f539975b5ca49a7e880cf02814e9888a8ea91abf01d552174eb02da00fb8054eb7ea81c6b511e0789f44fec714ff2530ecc1a58bb9b27915d49e5756ec529fbc69e0902e88a33575cf5916b9291460f904856f6902cc7744db997812bbe410e3f550b83e0197b2456624a15a483a700ba3c9efc1c4a607c525afd0f9dffda91388d16410c12b4a83f99414970d8c75c53957ab0327acf9fee92909c19df1189e0cba98f35a29120d68a35d8281cd8d343fe6fc65b9a592d8a6115a97f24f58c116c046b362914e108a3301936537783c4b76082523b3124bcd71a36e5467b1549be4324ada8c6e45ac02fd1aaed8f1c12c1e610f3a7047ef8d4e8e2773039b7b4d7085f04439258c2b490f06bde28a038e23aaf85794bc33b574b6d2726d5ac6397ddfce2bcb91abc1fb3ff540e9d188b84f7cb8aa1a68ec5cc75786fc755d62ae600a2f2c1d648be95d9f2de92a9abaac6417662680073eda6e5838fd171d74cff71dd408708de8f07c6b5667d82c8f7efa69d400adabd6de6557c7e44292b1be77dc90d82b059b3ee01c32852759c59ac421075a7df042e1ad1d3706c3cd864a44f68ae2303f39f6abcab5e15b7de13ba3a1f85867739269fabde5ed340feab5dd24f8e7e86cac8f2981709d3a9f0b3372f468bb8f20ecfcdce7ca059a49d8e61dc12103b5003238343740d14ed45b6000361cb0ab277c34bc3cb1be55fd33dda317540b257d1dd2555ae0a56eafa4fc4da7c705667538a65f6e70c56a1fa04be1905305db0949a6a498481f8fd164d66c2676e9963d96f49371f4ba6dce170c32ab806684ae86df9d20baceb6bc4191e980591f833e648cfff2592c9d866bbce92257f69c946c37235d41ff3d073e1be62f0f2a10cae513e1a5f146ee9198ac9524ff5259f76d62ca0bf9d233361cc1ab6682ddc2f5fa38594a536beecd205d4c8b97d48b1186e934e021baa919d7510bdd114e9ba347747747681593369f4007d8d14ac3336e8ee33f93031297cd4e9279422f6cb1578faeb4b6c35088ad1c16eebd34f39145299d76dc960379f49522efeb96b82fae1294ee4c5b7e13cee8bf295fc64cc51418a5c03387f291560a4fd43969ec69acd874de0d770534731c8b2a3066190ad01c8acad0fd8627bedbdd3a0648de6b684911c61a976afb5a774abea8a00b15407dd79353b38789358783e09908b2d39f5fbdfe5aea98fd478bff5f3a8c55197671ae0442478943e9296338f87ca4862baab3dd55a75c4c6717e3a6b610882a979215747d0d9d9f976a99d4dd1c2f9bc68e9cc39b27696a0a6c6e85ec0052f81b7f10573e7a3b21de433da09e85109a040cd00730e3856fa43372c69da1fee87420ea9591632ed654a299d4a172610cd11c653e1c64c80a1eb9bf60972e6633ed51fa287dfd7c892031c3b2d123466f1b6ddc45ab09e518066e19095a1aa2c674f6e8b24dd09ce7514fcdc508681b7ba4e3dfe106229e246986e05044a3c5f03ac785020592640d3eb2e3a639ce79a72b24cef5dc772fa6831549e2b0d54ce36b241291fcc2a0fe77c61d0d0a21a30f6cad8e934c14809e5adeb0d039b84cfc8a919ec276ccf88ac7139fca948a64f9bf5ef709f7fbe1888fbc137c3fe571e54f3c38c4ee3eff155e17d67a3ca4d223ef50bc3eb1be6e278fc2a65e25432cbb66a6d393cded33bcb6f9de277fd9448947c6302535cf9ad4f8d74f53c004e257e7bb7850a0a48d6bf590c0b2872dceab86c393d34d3908c7b594f2d6212035ba7414f9b48a76c8947363fe631c71f5c031ce822c6a5b8dfcb965dbdc659493c01e63ce3eff2802dcc9b282ce8d1b0d282ae982d8c79e5a85d68b0882012aaf849002424f074fe24cd32fbe212c2b31874159332fdb7ea677008229a65f115b727b8a1cb050e71347f874373f11fcaed4b15693f459779ff2d0a2c978ededc1721167369177387c5b0a28e752abd5592d4d26712a1479959c66ee94f3bf1e514d72f3dc36080675bb10b1b1f84abab3146b66df570e5c74c394edd4718d17b083ce13331963f3440718e04dd48a8df0993c862b94df4718a567169fe65d72f25c6eacb64e18e33bb1239876ab4caf11a490c0330630cbb0fba89d2df42e90c1a3d57619d5992203fda3a6be02288e87416a809dbfecb09919b38e34b1574a9ac2ac71951c6bcbd914643722e1a93cadecb067574909cd2a53efdd2d0fce0f134b61e04c9d4a7ecd4fbe8e07afb3faf698deb9eefd701886f3937cc7b6fe756a6ef7621fb9f717363333fa324378d32057f1a624f5abbb2f1b9a440d82bd54bdf9cc7759645f37c3e397ad89fb679659be2318b83183b9a4fd871fe31f56167c9bd8a822f5d57b125c567c911dd5f3be42e6fbf29df8fe10b4deb123b8de5869ab318513280406c393d55878ebc63be0cb1cf1006b2c1d5320058f99b27420265007bfd6b12f0bd17e62de02296f0717b011acda0b6b288b5f78ae9083f0e841e62494a2d4da4cabd3a940ac2f540c032d196af73f6f66dcaf7da93a6da645000c886984058dbc995d64d032482506db36541084a917b876d087b965b33df63f4753e6a7c51786f5a03887bf5f64dd279a05f8393f937d64e8f983810620e799a60579a3b96699321f6379ff99b2610be9f12b9797d64c97aac7057368946a4a913c55ca66b91cbe900021b3c8188ecb1035d87442851fc3910115d5a85bca5b8644172dcf1a821d1e6321d99b95990aa68cf4231f0802082bf1da01e73df4300cbc9c25edbf1fcf5d964613eaba32190534eb109c97d9311664ebc8107162c91cb9638daba325ed12f9d77338de0a390ffe81123fb0c375d298fd4f7aa6dea0d15d4b8ac3b34e5be0c6575c8f9981d5e48e0e5ea71b2e3686327e6574f225f8c1d539b974be6ce935c814208211724e091d89afb76753b1e806fa141aaeeb1b13bee3b61234ae5ffd8d1fd79289a77e73792b3dce48bf2eea554cee68aefedec7e5e14a3cfa2a34f9920a2f9b7f07bc657ed4fe7f5f7336301b479c91581ded39c05526a603fc8790e47842d5ff1643b5e58a2d85b7e1fffac16708db65ce543180729214c460a5e51367cd3eb63945a5372b75c610e7e666d0cabec7ec4bb8ded012e69d5a1a350cc9734562c4aa98780ffd29769915b112d0a5bfb66fef86eb7b8182b21a53005adfe726028d7d62d6bfa53ff59865b9446df6a749636b448dc29b26df9815d2d4a25dd3a7d72af62e9f85e6b5f5ff09b70470e2e6103eb389e100c5bca3c50eed8896a155881547bbb2ca9036946aef902d074710aef7d822562a85264ae6b62a8f6e3de0766c342101875d7e8eaf9604f85bcb1ce9cb88003550479e8c76577b9697f9e0b3eb812b5bb3fa01d31d97eb6911ff604434a467fd4da1159f88cd4b50ee8b5c023cb570c420fc84d0408375db5126aab836fc62b0b8d7679720f8cdae8f63280eddf6ff79d990b0436ba816251a95672b7cb0a94e452ee02a0375ff54e52da1ead5d777b3be44f2188d574fcdab08235fdd5d834b4b4ae3e8a204e3dc0eae47b7134058d73dbe69fb5f67f5a09acaa36bf00e2e488b951ff29f76d7093aadb6b00e6894a89964bec8475a4d0c916a93db57546f36f1e62a99d792f463fc6abf3f6b88d541831e7a6c31491e7660656e8ef36dd83c28c22f1a667848be16d8b01b060310238ad17ff1325f64251742c580b2d9be39c1130b52edc1a47b3e1e5abfa2c3dddfaa6e470da7dc9fd35c83af6d9acf32a9e6beb68c3b7eba1e6614ef79c9797ffbf38dc99f38f8f359b68d917c77d39f62ab4ed91a23966ceaabc69d120dfb718601b000f312ce85faa81b558374555587be820d706f121fb54cbfdd8fbb2d7009ed4d696d4359462b4572bb50cb2b59697ef5e21cd6cb5edd84f9d1c8da62411193217b7ab0d0b0a29a7ec5dd3468d9d6c7516ac5d4315d4c6598fd856038b1db4d7e0b11aca8de88343eeddfe22e482b5589def594f81455c02754b5c06c3687c3852b3a9266f05f756f3d4426795b624235eb8a79d22f581d8283f5a33f55d05f647147f197cc8989920191b8ce944859ad8aed14e2d78ebd7b8d3a7844d1700517fb6d17586b26e9b8cf50c62613a0256944ede978c132930adec7f782ef2bc5707420c662b3362aba3702ead08856fab6055b92283f92ad68246170a773b012067067f17a2b629afcac4b4d4ea9929ef9172aacf690823fd77c77385f2bdeb768f353f295ef8d582e67d825b179a4727187c96e220bd5f23150124e281f4</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-flip">      <input class="hbe hbe-input-field hbe-input-field-flip" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-flip" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-flip" data-content="您好, 这里需要密码。">您好, 这里需要密码。</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;hbe hbe-container&quot; id=&quot;hexo-blog-encrypt&quot; data-wpm=&quot;抱歉, 这个密码看着不太对, 请再试试.&quot; data-whm=&quot;抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.&quot;&gt;
  &lt;script id=&quot;hbeData&quot; type=&quot;hbeData&quot; data-hmacdigest=&quot;0196dd85c43caac64bbfa355b3ca5e3e5665c94318adcf7a800c9b43f13c4a6b&quot;&gt;fb9f6fbb8fc1d993240686705025b43532348148d53fb91ba5b377f724fe5b62c8b3848ff11810ef0eef03060f6fa9f6e50d44b812aff7d5fdc4437d49bc3ec3e31345cea2d12cf0e10c9263a9a720edff928b1331435c3804bd25a85f9996d78dbbe9dc1d7b7f8b067c0e6ab72a5244de9bfb995d4843af7c253efaf6e2fec00b653d0a3d104ff27b30871fa5d9d573046181f461ad2df13ae2a784c5beefb1a453a0e4f92a555e1053de39ef1ad8fad0b97503b1b218349f9fbad1388bc847448b3e178d64e5d1272e1f401c1edf874c176a20d808f075129a21b0aad9e0c5053566f26dc591b18fd817f14a3f907f1d35de0afe1f1ebde4dbfc57a6cf7e9d512dea436830ac2bf71fc1345931b2309bc730a8463fab9cdc10dde3ae2f2503c266c6bba6609f08b9245d973d3882cafb7c9f3447a40deddaec734cc607cde984d0098163d6ce69eaa1b3b794082e61455b2bf6f9791d3ae907269f301b98eeaffffc22a4f4213e858894cacce10edde3da2679e75f6ab333a2ce5d686868e18f8cb03814d2479f0e2774efb5530cd77f2d3e8c4ed354e8240481d4477536828e5d6af0b50eb43d8c362395dae9b6efa53ff7d5c71208134ebb53f662635c4435365e35059de2fe2c6aff04d13d64b7a8b2fa751922a8c9872b28efba30596ba9004699cb3dcd4896ba2f234a8a434299ab5d94f38a1bfeb6c861fdcdd70bd84de3aa5eafd0d45145028488924eb8963f37593d7b03cf6516781ec062f0933839c13aa332a5a3abed20e6f9e7b066143f36b909c51b98a637866fc8c63f27e4b0a836a6b8bd6bcf8a20920faa431370ca45d096c4efa237a1ce0d2b2cc70cef5d6672d0fd33f8ab6af34e5b720999286593004dfc75a83a0df6f3e79689d83614c02297619315243468250579241ac8d03ef9320c1173c9eb3727c5a9779f768c7acac2fa606d7009d5ec15b98238bc474fb5e8d96ca52a319f99c739272c909daa79a2ac59ede1fff686176c4ce47ef8db249073cb831fdbc94fd55be03fada6fb13910d71ad18fbed5f86da55552236642859ac12f99e1635a22b4e9a886d55e4d4834511c241fb7f66de318550fcd3dcfb141970e8099d8cacdd43feef3afc171dc1f4650d52966b8cf092c43a37bb5b29c793aaa8cd52cfac690cb4cefb837a9a030505cd5f147cc3abb5d372718f083412da4c91a7c905c9e2b6528bd1bdc597648351606f4e70705a3a34a1fc4b83b609f2d8e7efc299a2cea4df796897048acafe9247e9a32b366af8244bf3cfedef1676044f44d26c823a4fec672faa053f71a5e765ac5dfde7b3616fa20d1b68fbcea0d67bd8bff3548f9ce657cbf79bfcb9272b9213c27e3e1cce80a4c228191ab3eec2b305a504292053d2ee78dc4caf283f5d32a48511ebdaac7a2176736c5b5b53258376fc3acc4138d8c3c5affa138da0a531334c5c53668eeb661d8ff995bb95d46ab48b5c16c89f89682434830801d63b7cfdae2458797ac9455e6021abecc847a17dbec5279ac984e77e90178e45ad1f7dc718d03759f3790c04d63264ff7815b7827d475a8b4cea58f1496ef0e696e487776bea8e6f66627077826229f4ced8d7ac6e5a9a1ae2ef09087cf7082930a040787ec1ddef886de4f884765a767cbc5f11793aae222f1bdcc6e35f67e2303ec93a1c10955dcc7156fe6c8f33b7211e9d90949c2a6c16207e963dd1403631e51d78bed697b6622212222b5c4109fe1c17574ff39ffb83a1d1c40575109615873079a3b95533ebbcbe72219fabf30c055a666eebd0ad025c3d663bca9131a82bf044fc51f9b13b9c0d51d51bdc28afd7476f351f50ecd5fd7cf1a5bf40d1c9d8b5692ac443ee18e1d1c47aa917dfec4e4d09246e1329267c9689577bf566fc6f3c6678bbaf2478adcea5809aa0a187b10dc8ad3a9990ed11a137a943315ff6f2fee9ab0b4d3ba8200e905b8301f5e037f975ec74ff1c7037921ecff9d002f04a8f83de136bf2ae447c1a92ec0d6a748cde1873ccaf3685803bdd1704e36ca7dad35236f4f913be709b6f8d7db12a553cc51c987058dbca05bcc396776d0c7ccf09dde0421f7f5bcccaa72b155060d4fe21d2e69ef492dbcace542be74bb46b328f2b5f017769d70370ae612147433110cb3b92ad72ebcc65c4467f6b04f2356483a9d0315e1186e2b55b9ba7c115c5855110d0eea323935da0316bf635c30f0f6adb6f253636090a0ed43f446d5a36dec9915b76c2d0c67d79a8d10e23a22dfe99b3691f3b056251488e7075994b6e00293f01d9730a3478f91fbe388a4ddfc13ab17017ed0a41eaa371121b20511491082fe2d865ea70fb5c58a231a586facb8c99d0975f0afa7e3fffe76b274e7ee5fcafc01ef9cd5d1779405a2748aebea29238d6de71e7a38202c277ec706d82778f9f0da2121780b6bb799d3ec265d85bab9ab4706b3be28a403010f1075689e414f37c57b5a85625907a857f8935bcdaa65ab14dc7abe6ffcb4e18493f6693cfb3106cc970629643566821b3e591435255238bfdd1c84cf2e24f299d579ab99f252c7d349362905d8daf2c483922ac63d9b40afdbe23908da7a80b4659260af3704addae263d122e368b8322cffb10024efd238af0d7f17b6f96e15c0a6ddf0329930987dcdf5d15c20f338d44a05b42ab1f4a93a6629bbabc3d8869eb1004dd906af2915a3435680e469678367dd441f098c5f2a24481d93bb610eb3c7a3b5bdcf22c0064756af8d9f02749d21e0daca5f6a862081c72b0a10354436f3f37466663f74d68a3a360fcc44f394cb3c728d137e8dee34270770f2beeeff98e7bf2c4848a8e93a57b0a1c14ca52a4679c2960ae0337a57590acb81ad471c333e8ed3f82bbf44b1cd704f5de2ecc676da91b0bac1eb1685124924fb5fe488dda425554b4e8ae4f98d5f9e2c260a47265f4aa37583cb6556ad425ba9dfbbd999f7da19d5e36ebfb8ae64aabb990901affd2667da1080b37746f6c18dffec796c6d65e9e1336c2afe165e716d7310a2ce5a83ffa2f379e7e24090aa70a734d2fae2611f950d9b7b8f3424a5bd0e6f7434ca14fc2bc21b023802b9f4f602919fcc4be0c6c8ea97af2c8afc31c69201cbc67cf306be629c668a097e87e541925cdc09f786cbb5739895732a53229fc5f552c2299cf2fe909b6a8fe9bf67d5d0118a7fc5be5da51eb34a783371b9c572315f5b4c8999efa0b6943808c3b577d4261acd4cfd94ae63ad0c6e403051c53090d19ee9dc1f772ca5b4e04b0f854329a2380c72f5700b6d1ada5d814155279a0e639a715e0564115e7b26a5ffa51ccb00bb868469a7a8ada54fdaa31e77e35830508db80cb678b7ee3711302733291a440e9a798adea55be57f7876c36a7b408e99e7a59abc028570a1660d54410c2db9b99d896bdd27dee3f115179340ae46d69706dda0ba04acb3471719da4e032fa093de6ed0dfbe8a5ec7ed6942cd877dd2a814146e35e800137747fe32745fb4af60a0bd0d48bcbe53eabf67990a5afd1d68f816390705f539975b5ca49a7e880cf02814e9888a8ea91abf01d552174eb02da00fb8054eb7ea81c6b511e0789f44fec714ff2530ecc1a58bb9b27915d49e5756ec529fbc69e0902e88a33575cf5916b9291460f904856f6902cc7744db997812bbe410e3f550b83e0197b2456624a15a483a700ba3c9efc1c4a607c525afd0f9dffda91388d16410c12b4a83f99414970d8c75c53957ab0327acf9fee92909c19df1189e0cba98f35a29120d68a35d8281cd8d343fe6fc65b9a592d8a6115a97f24f58c116c046b362914e108a3301936537783c4b76082523b3124bcd71a36e5467b1549be4324ada8c6e45ac02fd1aaed8f1c12c1e610f3a7047ef8d4e8e2773039b7b4d7085f04439258c2b490f06bde28a038e23aaf85794bc33b574b6d2726d5ac6397ddfce2bcb91abc1fb3ff540e9d188b84f7cb8aa1a68ec5cc75786fc755d62ae600a2f2c1d648be95d9f2de92a9abaac6417662680073eda6e5838fd171d74cff71dd408708de8f07c6b5667d82c8f7efa69d400adabd6de6557c7e44292b1be77dc90d82b059b3ee01c32852759c59ac421075a7df042e1ad1d3706c3cd864a44f68ae2303f39f6abcab5e15b7de13ba3a1f85867739269fabde5ed340feab5dd24f8e7e86cac8f2981709d3a9f0b3372f468bb8f20ecfcdce7ca059a49d8e61dc12103b5003238343740d14ed45b6000361cb0ab277c34bc3cb1be55fd33dda317540b257d1dd2555ae0a56eafa4fc4da7c705667538a65f6e70c56a1fa04be1905305db0949a6a498481f8fd164d66c2676e9963d96f49371f4ba6dce170c32ab806684ae86df9d20baceb6bc4191e980591f833e648cfff2592c9d866bbce92257f69c946c37235d41ff3d073e1be62f0f2a10cae513e1a5f146ee9198ac9524ff5259f76d62ca0bf9d233361cc1ab6682ddc2f5fa38594a536beecd205d4c8b97d48b1186e934e021baa919d7510bdd114e9ba347747747681593369f4007d8d14ac3336e8ee33f93031297cd4e9279422f6cb1578faeb4b6c35088ad1c16eebd34f39145299d76dc960379f49522efeb96b82fae1294ee4c5b7e13cee8bf295fc64cc51418a5c03387f291560a4fd43969ec69acd874de0d770534731c8b2a3066190ad01c8acad0fd8627bedbdd3a0648de6b684911c61a976afb5a774abea8a00b15407dd79353b38789358783e09908b2d39f5fbdfe5aea98fd478bff5f3a8c55197671ae0442478943e9296338f87ca4862baab3dd55a75c4c6717e3a6b610882a979215747d0d9d9f976a99d4dd1c2f9bc68e9cc39b27696a0a6c6e85ec0052f81b7f10573e7a3b21de433da09e85109a040cd00730e3856fa43372c69da1fee87420ea9591632ed654a299d4a172610cd11c653e1c64c80a1eb9bf60972e6633ed51fa287dfd7c892031c3b2d123466f1b6ddc45ab09e518066e19095a1aa2c674f6e8b24dd09ce7514fcdc508681b7ba4e3dfe106229e246986e05044a3c5f03ac785020592640d3eb2e3a639ce79a72b24cef5dc772fa6831549e2b0d54ce36b241291fcc2a0fe77c61d0d0a21a30f6cad8e934c14809e5adeb0d039b84cfc8a919ec276ccf88ac7139fca948a64f9bf5ef709f7fbe1888fbc137c3fe571e54f3c38c4ee3eff155e17d67a3ca4d223ef50bc3eb1be6e278fc2a65e25432cbb66a6d393cded33bcb6f9de277fd9448947c6302535cf9ad4f8d74f53c004e257e7bb7850a0a48d6bf590c0b2872dceab86c393d34d3908c7b594f2d6212035ba7414f9b48a76c8947363fe631c71f5c031ce822c6a5b8dfcb965dbdc659493c01e63ce3eff2802dcc9b282ce8d1b0d282ae982d8c79e5a85d68b0882012aaf849002424f074fe24cd32fbe212c2b31874159332fdb7ea677008229a65f115b727b8a1cb050e71347f874373f11fcaed4b15693f459779ff2d0a2c978ededc1721167369177387c5b0a28e752abd5592d4d26712a1479959c66ee94f3bf1e514d72f3dc36080675bb10b1b1f84abab3146b66df570e5c74c394edd4718d17b083ce13331963f3440718e04dd48a8df0993c862b94df4718a567169fe65d72f25c6eacb64e18e33bb1239876ab4caf11a490c0330630cbb0fba89d2df42e90c1a3d57619d5992203fda3a6be02288e87416a809dbfecb09919b38e34b1574a9ac2ac71951c6bcbd914643722e1a93cadecb067574909cd2a53efdd2d0fce0f134b61e04c9d4a7ecd4fbe8e07afb3faf698deb9eefd701886f3937cc7b6fe756a6ef7621fb9f717363333fa324378d32057f1a624f5abbb2f1b9a440d82bd54bdf9cc7759645f37c3e397ad89fb679659be2318b83183b9a4fd871fe31f56167c9bd8a822f5d57b125c567c911dd5f3be42e6fbf29df8fe10b4deb123b8de5869ab318513280406c393d55878ebc63be0cb1cf1006b2c1d5320058f99b27420265007bfd6b12f0bd17e62de02296f0717b011acda0b6b288b5f78ae9083f0e841e62494a2d4da4cabd3a940ac2f540c032d196af73f6f66dcaf7da93a6da645000c886984058dbc995d64d032482506db36541084a917b876d087b965b33df63f4753e6a7c51786f5a03887bf5f64dd279a05f8393f937d64e8f983810620e799a60579a3b96699321f6379ff99b2610be9f12b9797d64c97aac7057368946a4a913c55ca66b91cbe900021b3c8188ecb1035d87442851fc3910115d5a85bca5b8644172dcf1a821d1e6321d99b95990aa68cf4231f0802082bf1da01e73df4300cbc9c25edbf1fcf5d964613eaba32190534eb109c97d9311664ebc8107162c91cb9638daba325ed12f9d77338de0a390ffe81123fb0c375d298fd4f7aa6dea0d15d4b8ac3b34e5be0c6575c8f9981d5e48e0e5ea71b2e3686327e6574f225f8c1d539b974be6ce935c814208211724e091d89afb76753b1e806fa141aaeeb1b13bee3b61234ae5ffd8d1fd79289a77e73792b3dce48bf2eea554cee68aefedec7e5e14a3cfa2a34f9920a2f9b7f07bc657ed4fe7f5f7336301b479c91581ded39c05526a603fc8790e47842d5ff1643b5e58a2d85b7e1fffac16708db65ce543180729214c460a5e51367cd3eb63945a5372b75c610e7e666d0cabec7ec4bb8ded012e69d5a1a350cc9734562c4aa98780ffd29769915b112d0a5bfb66fef86eb7b8182b21a53005adfe726028d7d62d6bfa53ff59865b9446df6a749636b448dc29b26df9815d2d4a25dd3a7d72af62e9f85e6b5f5ff09b70470e2e6103eb389e100c5bca3c50eed8896a155881547bbb2ca9036946aef902d074710aef7d822562a85264ae6b62a8f6e3de0766c342101875d7e8eaf9604f85bcb1ce9cb88003550479e8c76577b9697f9e0b3eb812b5bb3fa01d31d97eb6911ff604434a467fd4da1159f88cd4b50ee8b5c023cb570c420fc84d0408375db5126aab836fc62b0b8d7679720f8cdae8f63280eddf6ff79d990b0436ba816251a95672b7cb0a94e452ee02a0375ff54e52da1ead5d777b3be44f2188d574fcdab08235fdd5d834b4b4ae3e8a204e3dc0eae47b7134058d73dbe69fb5f67f5a09acaa36bf00e2e488b951ff29f76d7093aadb6b00e6894a89964bec8475a4d0c916a93db57546f36f1e62a99d792f463fc6abf3f6b88d541831e7a6c31491e7660656e8ef36dd83c28c22f1a667848be16d8b01b060310238ad17ff1325f64251742c580b2d9be39c1130b52edc1a47b3e1e5abfa2c3dddfaa6e470da7dc9fd35c83af6d9acf32a9e6beb68c3b7eba1e6614ef79c9797ffbf38dc99f38f8f359b68d917c77d39f62ab4ed91a23966ceaabc69d120dfb718601b000f312ce85faa81b558374555587be820d706f121fb54cbfdd8fbb2d7009ed4d696d4359462b4572bb50cb2b59697ef5e21cd6cb5edd84f9d1c8da62411193217b7ab0d0b0a29a7ec5dd3468d9d6c7516ac5d4315d4c6598fd856038b1db4d7e0b11aca8de88343eeddfe22e482b5589def594f81455c02754b5c06c3687c3852b3a9266f05f756f3d4426795b624235eb8a79d22f581d8283f5a33f55d05f647147f197cc8989920191b8ce944859ad8aed14e2d78ebd7b8d3a7844d1700517fb6d17586b26e9b8cf50c62613a0256944ede978c132930adec7f782ef2bc5707420c662b3362aba3702ead08856fab6055b92283f92ad68246170a773b012067067f17a2b629afcac4b4d4ea9929ef9172aacf690823fd77c77385f2bdeb768f353f295ef8d582e67d825b179a4727187c96e220bd5f23150124e281f4&lt;/script&gt;
  &lt;div class=&quot;hbe hbe-content&quot;&gt;
    &lt;div class=&quot;hbe hbe-input hbe-input-flip&quot;&gt;
      &lt;input class=&quot;hbe hbe-input-field hbe-input-field-flip&quot; type=&quot;password&quot; id=&quot;hbePass&quot;&gt;
      &lt;label class=&quot;hbe hbe-input-label hbe-input-label-flip&quot; for=&quot;hbePass&quot;&gt;
        &lt;span class=&quot;hbe hbe-input-label-content hbe-input-label-content-flip&quot; data-content=&quot;您好, 这里需要密码。&quot;&gt;您好, 这里需要密码。&lt;/span&gt;
      &lt;/label&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;
    
    </summary>
    
      <category term="Cpp" scheme="http://www.helioswei.top/categories/Cpp/"/>
    
    
  </entry>
  
  <entry>
    <title>cpp-gtest集成Lcov代码覆盖率测试</title>
    <link href="http://www.helioswei.top/article/3264464113.html"/>
    <id>http://www.helioswei.top/article/3264464113.html</id>
    <published>2021-02-08T07:04:47.000Z</published>
    <updated>2021-03-01T02:04:04.266Z</updated>
    
    <content type="html"><![CDATA[<p>​    做好了单元测试但是别人并不知道我们的单元测试做的如何，是否覆盖了所有的需要被测试的类方法或者变量等，所以我们需要对单测case做一个覆盖率统计。其实本质就是看代码执行时候运行了你需要测试文件里面的所有代码，比如switch分支 if分支等。</p><h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><h4 id="安装下载lcov"><a href="#安装下载lcov" class="headerlink" title="安装下载lcov"></a>安装下载lcov</h4><pre><code>http://ltp.sourceforge.net/coverage/lcov.php，有rpm包和源码包。（以源码包为例）</code></pre><p>解压lcov-x.xx.tar.gz，进入源码包，执行make install<br>在命令行执行lcov -v，正确输出版本号即安装成功</p><h4 id="增加Lcov编译选项"><a href="#增加Lcov编译选项" class="headerlink" title="增加Lcov编译选项"></a>增加Lcov编译选项</h4><p>​    在项目顶层目录CmakeLists.txt中添加以下编译指令：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coverage option</span></span><br><span class="line"><span class="keyword">OPTION</span> (ENABLE_COVERAGE <span class="string">&quot;Use gcov&quot;</span> <span class="keyword">ON</span>)</span><br><span class="line"><span class="keyword">MESSAGE</span>(STATUS ENABLE_COVERAGE=<span class="variable">$&#123;ENABLE_COVERAGE&#125;</span>)</span><br><span class="line"><span class="keyword">IF</span>(ENABLE_COVERAGE)</span><br><span class="line">    <span class="keyword">SET</span>(CMAKE_CXX_FLAGS <span class="string">&quot;$&#123;CMAKE_CXX_FLAGS&#125; -fprofile-arcs -ftest-coverage&quot;</span>)</span><br><span class="line">    <span class="keyword">SET</span>(CMAKE_C_FLAGS <span class="string">&quot;$&#123;CMAKE_C_FLAGS&#125; -fprofile-arcs -ftest-coverage&quot;</span>)</span><br><span class="line">    <span class="keyword">SET</span>(CMAKE_EXE_LINKER_FLAGS <span class="string">&quot;$&#123;CMAKE_EXE_LINKER_FLAGS&#125; -fprofile-arcs -ftest-coverage&quot;</span>)</span><br><span class="line"><span class="keyword">ENDIF</span>()</span><br></pre></td></tr></table></figure><h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><ol><li><p>将cmake编译选项设置为-DENABLE_COVERAGE=OFF …，或者将顶层目录CmakeLists.txt中OPTION (ENABLE_COVERAGE “Use gcov” OFF)编译选项手动设置为ON；</p></li><li><p>编译产生<code>.gcno</code>文件，运行则产生<code>.gcda</code>（与.gcno对应）文件；</p><ul><li>我们使用的是<code>cmake编译</code>，则编译后生成的.gcno文件存在build目录下的每个项目中，例如：<img src="/images/cpp/gcno.png" alt="gcno" style="zoom:75%;" /></li><li><code>运行</code>我们的测试代码才会产生.gcda文件，如图是运行后产生的。<ul><li>若用户进程<code>并非调用 exit 正常退出</code>，覆盖率统计数据就无法输出，也就无从生成报告了。后台服务程序若非专门设计，一旦启动就很少主动退出，用 kill 杀死进程强制退出时就不会调用 exit，因此没有覆盖率统计结果产生。所以必须当前进程退出后才会产生.gcda文件。</li></ul></li></ul></li><li><p>使用Lcov生成覆盖率统计文件；</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lcov -d cmake-build-debug -t test -o test.info -b . -c  --no-external</span><br></pre></td></tr></table></figure><p>命令参数含义解释如下：</p><ul><li>-d src_dir： 待覆盖率测试的源码目录，本工程设置为cmake-build-debug；</li><li>-t ‘test’: 目标的名称，此处为test；</li><li>-o ‘test.info’: 生成的覆盖率文件，可自定义，可不带引号；</li><li>-b .：相对目录的起始位置；</li><li>-c: capture，采集覆盖率；</li></ul><p>因为我们是cmake进行编译的，所以我们可以直接在build目录下使用lcov命令生成覆盖率报表</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lcov -c -o result.info  -b . -d . </span><br></pre></td></tr></table></figure></li><li><p>使用genhtml生成覆盖率报表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">genhtml -o report test.info</span><br></pre></td></tr></table></figure><ul><li><p>-o result: 输出的目标文件夹，可带路径，此处为当前目录下的result目录；</p></li><li><p>test.info: 覆盖率的统计文件；</p></li></ul><p>如果我们需要对覆盖率报表进行过滤，比如把include文件或者系统的文件给过滤掉，可以使用下面的命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lcov --remove result.info  &#x27;/usr/*&#x27; &#x27;*/inc/*&#x27; -o finalresult.info</span><br><span class="line">genhtml finalresult.info  -o cppreport</span><br></pre></td></tr></table></figure></li><li><p>html报表生成如下，这个是未过滤的。<img src="/images/cpp/html.png" alt="html.png"></p></li></ol><p>相关文章参考：</p><ul><li><a href="https://blog.csdn.net/weixin_43892514/article/details/107822769">这篇文章</a>对lcov讲解的比较详细以及cmake添加的选项比较好用，但是对生成的.gcno和.gcda文件在哪里没有说明，对于我这个初学者来说比较的蒙。</li><li><a href="https://www.cnblogs.com/zhaoxd07/p/5608177.html">这篇文章</a>对文件生成的位置有详细的说明。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;​    做好了单元测试但是别人并不知道我们的单元测试做的如何，是否覆盖了所有的需要被测试的类方法或者变量等，所以我们需要对单测case做一个覆盖率统计。其实本质就是看代码执行时候运行了你需要测试文件里面的所有代码，比如switch分支 if分支等。&lt;/p&gt;
    
    </summary>
    
      <category term="Cpp" scheme="http://www.helioswei.top/categories/Cpp/"/>
    
      <category term="unitTest" scheme="http://www.helioswei.top/categories/Cpp/unitTest/"/>
    
    
      <category term="gtest" scheme="http://www.helioswei.top/tags/gtest/"/>
    
      <category term="lcov" scheme="http://www.helioswei.top/tags/lcov/"/>
    
  </entry>
  
  <entry>
    <title>博客的分类</title>
    <link href="http://www.helioswei.top/article/2992991387.html"/>
    <id>http://www.helioswei.top/article/2992991387.html</id>
    <published>2021-01-06T03:51:26.000Z</published>
    <updated>2021-03-04T05:26:18.731Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="9c6d4558b2764049217fd8f0af560cae3ca790ee7dab0a3ce3210a004071e6c3">fb9f6fbb8fc1d993240686705025b43532348148d53fb91ba5b377f724fe5b62290d080b1fcf999e1ed49c1afe465ff98e01c6e53c9483c7737641457feb35c33eb6b85fffeaca79b42470e68905ee3b89c18e94c8af44842b77ec4efa2d30b010f716e514e0804bf02f00c8fc60db83d842ee4d1277bbd526a5576fe56c2edd80e257d2e581dda4a2ff4c90761c88d26a3c06c981cd48e3116dbb60b65e6bbccb3580ed5d8e68f1bf06496ea918920c02d084f0b8b139575a7d43b981887169a3ceca6893f74e59e786ebd093f01abc46e977cb50b469895ab5f6f5516d9f3f21d4c422312a1170c6f74ffd913b52a32d137a4a10b6b9db86a346d53f866e3b9f0b45655430a7b18c17062c2ef525640120010b24a74284ca2763d229eed5ce7e23e8cf790efcb626beab1f00e42dc897c9546cb133f36969fb18a81cfd7dabf889ef660c3c6045e8614823c17a9740a735ad4a42278facdd693b5146a369cbe76fa3e953cc512df56ef275f9699a499f8555a846135389781682dc70eeefc22ad66ecd389718cae8d0a2d913a086e1792033b717e1f36d7242e6f2d1619022062153c4c1f161cb2c0cfe06cb63d9eb5c7488e239f82cbca61c354f1ef1396b774d4b1a4f97e08007e7abd204926e92a1b95a5562b2c303e873a086d113578a622db42e3ebf1683e20c84d00e22c9f00f0903799083705eb95e6befe04e7f7bde09dc7ed3b250eb380dc0ba5a4a0d718010a1afb0807ee8ba92abfcf4b68726940f4de6afb11a7b82279f84aee7bea851eea8b79c8cef69c56aae7c6680e7e369a2585f767c0711bcb6f2cb594ee30c3da5c446b55547bbfbc702b945cd565e24cee873da22c1167a7386b0520803b14e523dca542b3f36457a11552ce8448cb6ae4df3d33fc4d164d2b1b271fe66aa25f5ba8081e6fb7881e25afa97567ab16beac9dcd2278492db067d99f64380c1a90047e08dd245fba07691ceed15edcf504b0bc47fe554698dbe5abed3acbd5a6bdee7e9a352d2af370331cc956c152c24a9d0272475679b44d4815682632f02a0a5e8e146815a37abfec59b5d3da26f8b4e8bdc8f6ffc993132facd600f51b460b5221cf31d29e551727d6b61bed2eed77aed9cf1571bdc52cdbe779e0af29da412e410642e36a2adb3a984d9ef8e47e1dda27992e1794f8abe31fa9b8492c4558e2ef565a2e507bfc57754bff82ed42e03804d99b98613645e70974f411a0a74a1ab725fef3370cb97359ece0b9d2e89ea4873a4f3e85824f1b79b62bd19f6d88f55a5a3789b5d9b23c8a7d9461bdbf2871038ad51ce3cd0e90fd9233344a200b4de317e832dabc88624cb1a20b663f2540464d0aaae092d290aa32e3ff6b024112c6c4f2ca820180b491f4df672687cfe2e1f5e37c3f08452e1b4c7366e6a4a947b7ea151e69b1797bd8b53742865adb57a65dcbf4971c26346fa211a395f96e3ac584cff32d4047ed9209593760b79fa4d9ad663d7d883dd59940c42fc661512abed1ff151c96a3bef1596ad3f5638e5fb83b96511c3b363d91f0a1b8464046b71aa66d0824855d84a104429897eb67db459ce92e260ade3af56d8af74262fdc25734bf88aa4439b278eabde1a7a2d54a4ff45bba0f39d2a557e232ee3404dee50231527eede69abc6af2b424f69561c044c977a4b5d0eaa96faab895cca2635a1a2a9bf382e2ddf6d627557e5f9ee5f4317b57d503bec4334869a343e8749b79035983d6f3c5b196e2b36ee9b2b30ca01437dfcea1dddb2cd6442b639eb0b8fc4ccbe98a98ba3dff2e51d87f580532c566fa4f9f1f446e1f01e10ecb0439a1fbcfc37b6ada5a0e32f549384b2f40d62fed6c774fc631fb6a8ec8a26db4e264b8c1db92ae501aa301dc19154cadb1f65f52da653b65248f12b2e0b22763ec74bb6b5ce2bfb8b41b41d19013f6abcb99a33d6d9ba31b78e631507bec712afafc3cd0a4e211373713efa6aac193db428d64677299015a65702c71c407d54e760af27cc8db15fbb7d4bf5e8b1da8c6340dfb836115b700c73ef13c67335bfd2e6931ba21555bb1d181a5decbb067176d4e8f26b35fa872cb4950f8d638a2cc1019f0e942a9f25a0d518833ec0ccf6b23c4c937719bda83c26f7bc47d5f35adcc9d2b4909318a1f1b3a78695aa0e6167456cec4ac5a0432d4cbce3fd699f7189e1dfa2a83c32cca4cf67d2f8fd03e86f1f3c0326e0ee7be57d65f2ee7d7f973d596c5e91e0e93cbe96d39d853adbc88d5f2d7a91792aaaa86a7e3e61aa08d12f</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-flip">      <input class="hbe hbe-input-field hbe-input-field-flip" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-flip" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-flip" data-content="您好, 这里需要密码。">您好, 这里需要密码。</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;hbe hbe-container&quot; id=&quot;hexo-blog-encrypt&quot; data-wpm=&quot;抱歉, 这个密码看着不太对, 请再试试.&quot; data-whm=&quot;抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.&quot;&gt;
  &lt;script id=&quot;hbeData&quot; type=&quot;hbeData&quot; data-hmacdigest=&quot;9c6d4558b2764049217fd8f0af560cae3ca790ee7dab0a3ce3210a004071e6c3&quot;&gt;fb9f6fbb8fc1d993240686705025b43532348148d53fb91ba5b377f724fe5b62290d080b1fcf999e1ed49c1afe465ff98e01c6e53c9483c7737641457feb35c33eb6b85fffeaca79b42470e68905ee3b89c18e94c8af44842b77ec4efa2d30b010f716e514e0804bf02f00c8fc60db83d842ee4d1277bbd526a5576fe56c2edd80e257d2e581dda4a2ff4c90761c88d26a3c06c981cd48e3116dbb60b65e6bbccb3580ed5d8e68f1bf06496ea918920c02d084f0b8b139575a7d43b981887169a3ceca6893f74e59e786ebd093f01abc46e977cb50b469895ab5f6f5516d9f3f21d4c422312a1170c6f74ffd913b52a32d137a4a10b6b9db86a346d53f866e3b9f0b45655430a7b18c17062c2ef525640120010b24a74284ca2763d229eed5ce7e23e8cf790efcb626beab1f00e42dc897c9546cb133f36969fb18a81cfd7dabf889ef660c3c6045e8614823c17a9740a735ad4a42278facdd693b5146a369cbe76fa3e953cc512df56ef275f9699a499f8555a846135389781682dc70eeefc22ad66ecd389718cae8d0a2d913a086e1792033b717e1f36d7242e6f2d1619022062153c4c1f161cb2c0cfe06cb63d9eb5c7488e239f82cbca61c354f1ef1396b774d4b1a4f97e08007e7abd204926e92a1b95a5562b2c303e873a086d113578a622db42e3ebf1683e20c84d00e22c9f00f0903799083705eb95e6befe04e7f7bde09dc7ed3b250eb380dc0ba5a4a0d718010a1afb0807ee8ba92abfcf4b68726940f4de6afb11a7b82279f84aee7bea851eea8b79c8cef69c56aae7c6680e7e369a2585f767c0711bcb6f2cb594ee30c3da5c446b55547bbfbc702b945cd565e24cee873da22c1167a7386b0520803b14e523dca542b3f36457a11552ce8448cb6ae4df3d33fc4d164d2b1b271fe66aa25f5ba8081e6fb7881e25afa97567ab16beac9dcd2278492db067d99f64380c1a90047e08dd245fba07691ceed15edcf504b0bc47fe554698dbe5abed3acbd5a6bdee7e9a352d2af370331cc956c152c24a9d0272475679b44d4815682632f02a0a5e8e146815a37abfec59b5d3da26f8b4e8bdc8f6ffc993132facd600f51b460b5221cf31d29e551727d6b61bed2eed77aed9cf1571bdc52cdbe779e0af29da412e410642e36a2adb3a984d9ef8e47e1dda27992e1794f8abe31fa9b8492c4558e2ef565a2e507bfc57754bff82ed42e03804d99b98613645e70974f411a0a74a1ab725fef3370cb97359ece0b9d2e89ea4873a4f3e85824f1b79b62bd19f6d88f55a5a3789b5d9b23c8a7d9461bdbf2871038ad51ce3cd0e90fd9233344a200b4de317e832dabc88624cb1a20b663f2540464d0aaae092d290aa32e3ff6b024112c6c4f2ca820180b491f4df672687cfe2e1f5e37c3f08452e1b4c7366e6a4a947b7ea151e69b1797bd8b53742865adb57a65dcbf4971c26346fa211a395f96e3ac584cff32d4047ed9209593760b79fa4d9ad663d7d883dd59940c42fc661512abed1ff151c96a3bef1596ad3f5638e5fb83b96511c3b363d91f0a1b8464046b71aa66d0824855d84a104429897eb67db459ce92e260ade3af56d8af74262fdc25734bf88aa4439b278eabde1a7a2d54a4ff45bba0f39d2a557e232ee3404dee50231527eede69abc6af2b424f69561c044c977a4b5d0eaa96faab895cca2635a1a2a9bf382e2ddf6d627557e5f9ee5f4317b57d503bec4334869a343e8749b79035983d6f3c5b196e2b36ee9b2b30ca01437dfcea1dddb2cd6442b639eb0b8fc4ccbe98a98ba3dff2e51d87f580532c566fa4f9f1f446e1f01e10ecb0439a1fbcfc37b6ada5a0e32f549384b2f40d62fed6c774fc631fb6a8ec8a26db4e264b8c1db92ae501aa301dc19154cadb1f65f52da653b65248f12b2e0b22763ec74bb6b5ce2bfb8b41b41d19013f6abcb99a33d6d9ba31b78e631507bec712afafc3cd0a4e211373713efa6aac193db428d64677299015a65702c71c407d54e760af27cc8db15fbb7d4bf5e8b1da8c6340dfb836115b700c73ef13c67335bfd2e6931ba21555bb1d181a5decbb067176d4e8f26b35fa872cb4950f8d638a2cc1019f0e942a9f25a0d518833ec0ccf6b23c4c937719bda83c26f7bc47d5f35adcc9d2b4909318a1f1b3a78695aa0e6167456cec4ac5a0432d4cbce3fd699f7189e1dfa2a83c32cca4cf67d2f8fd03e86f1f3c0326e0ee7be57d65f2ee7d7f973d596c5e91e0e93cbe96d39d853adbc88d5f2d7a91792aaaa86a7e3e61aa08d12f&lt;/script&gt;
  &lt;div class=&quot;hbe hbe-content&quot;&gt;
    &lt;div class=&quot;hbe hbe-input hbe-input-flip&quot;&gt;
      &lt;input class=&quot;hbe hbe-input-field hbe-input-field-flip&quot; type=&quot;password&quot; id=&quot;hbePass&quot;&gt;
      &lt;label class=&quot;hbe hbe-input-label hbe-input-label-flip&quot; for=&quot;hbePass&quot;&gt;
        &lt;span class=&quot;hbe hbe-input-label-content hbe-input-label-content-flip&quot; data-content=&quot;您好, 这里需要密码。&quot;&gt;您好, 这里需要密码。&lt;/span&gt;
      &lt;/label&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;
    
    </summary>
    
      <category term="Blog" scheme="http://www.helioswei.top/categories/Blog/"/>
    
    
      <category term="Blog" scheme="http://www.helioswei.top/tags/Blog/"/>
    
  </entry>
  
  <entry>
    <title>centos7-zsh的使用和配置</title>
    <link href="http://www.helioswei.top/article/192192511.html"/>
    <id>http://www.helioswei.top/article/192192511.html</id>
    <published>2020-12-08T08:58:14.000Z</published>
    <updated>2021-03-04T05:28:28.821Z</updated>
    
    <content type="html"><![CDATA[<p>​     本文主要是记录centos7搭建自己个性的命令行。</p><h3 id="安装zsh"><a href="#安装zsh" class="headerlink" title="安装zsh"></a>安装zsh</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install zsh</span><br></pre></td></tr></table></figure><h4 id="将其设置为默认shell"><a href="#将其设置为默认shell" class="headerlink" title="将其设置为默认shell"></a>将其设置为默认shell</h4><p>~~~`<br>chsh -s /bin/zsh<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#96;可以通过echo $SHELL来查看当前默认的shell，如果没有改为&#x2F;bin&#x2F;zsh,那么需要重新启动shell&#96;</span><br><span class="line"></span><br><span class="line">### 安装oh-my-zsh</span><br><span class="line"></span><br><span class="line">[地址](https:&#x2F;&#x2F;github.com&#x2F;ohmyzsh&#x2F;ohmyzsh)</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>    sh -c “$(wget -O- <a href="https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot;">https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot;</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 配置文件</span><br><span class="line"></span><br><span class="line">​默认的配置文件是在&#96;&#x2F;root&#x2F;.zshrc&#96;，可以通过配置文件来配置一下插件以及功能</span><br><span class="line"></span><br><span class="line">##### 主题修改</span><br><span class="line"></span><br><span class="line">在&#96;.zshrc&#96;中找到&#96;ZSH_THEME&#96;，即可修改主题，[主题地址](https:&#x2F;&#x2F;github.com&#x2F;ohmyzsh&#x2F;ohmyzsh&#x2F;wiki&#x2F;themes)可自己修改</span><br><span class="line"></span><br><span class="line">##### zsh扩展</span><br><span class="line"></span><br><span class="line">​在&#96;&#x2F;root&#x2F;.zshrc&#96;中找到&#96;plugins&#96;关键字，就可以自定义启用的插件了，目前插件存放在workspace上</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;​     本文主要是记录centos7搭建自己个性的命令行。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://www.helioswei.top/categories/Linux/"/>
    
      <category term="centos7" scheme="http://www.helioswei.top/categories/Linux/centos7/"/>
    
    
      <category term="zsh" scheme="http://www.helioswei.top/tags/zsh/"/>
    
  </entry>
  
  <entry>
    <title>AI-PaddleHub的体验使用</title>
    <link href="http://www.helioswei.top/article/1959613013.html"/>
    <id>http://www.helioswei.top/article/1959613013.html</id>
    <published>2020-12-03T06:25:47.000Z</published>
    <updated>2021-03-01T02:04:04.259Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="8521b7cbfc6ac040635f9a48dc1ac7925f28db77691d8b73fa1bb2f8c2cd55d9">4630436162ade97ba2718b7d0c4b3b63c7da53b2e21fbc742f4fcb8fd6f69935ce67815935b6f57a5b73addf9c977ccc0ea54af4dea5aa99daa2f80d61ca5fbac32625c835b1966fd872844401f18de6514b9581035e21af340f202ba6c0ff5f33825547078782189f6725a7a78cea80e919aab557e14006c86da505dd41b715b2fb028f618c8e1c2ba2482c71ff5b9db37c53e812d2e9631f20b1742e7f5c23187209e65dabf44a3e6056664b5597d7e1bff7385c58a577d0bdeda6d0dae9097ab61a278687581156d107efe5e349a2439e6dd131f771b7fc8cb850cbdffcd532b2388d80ecc765770869e67d1399ea5b51cb2ccf120cd90b783952e1cc8c567aa17ac3bfa002e2aef69fdfbe5dcfa7626ed4f2c22c5c06e211f3a85a046d5974a79db953724dd59937e49358192364197c139db1647cff3243f021b41d217fa261d68c7845e52f12afc5dd335126aeb6187ace9f0006d4f99327a08bce41202843d5a55d1182f4f2f30cd37d40a7e49776bcbb6c97a0b89a4054c5b0380c3e2f62b5a110095070c113a2997fc4dcfe8ec881a2034bc55931598dbfcd82cdddc76137a10450e8acb3e659b127a561a28f6eabfecc9db9a1e06806b80894a5d375e845b8f90d363904f1d3e575fcf69aa5972e5048d6bf719c02e19de31c3f9e9887e8681ea5ea35927d3d076d846d359a8fd799d92375841ec0354b33dfd9f974c56c4f4d2d280d02629672f529139ce4a14716f16c0ca17a6a90ac9c00574a4f776f524845ed5a597974e1b36d6439639eb6d45f0b36c02c7fcf8ecc063b8e8dbe0e967f2c0a54b18ba81d88f2053e363100282af8832f691bf6bbe39904db81a6fb77597d17e0ed18b8d2f2386d62f136ab29f3d838952c1819abd6d1f61206f8cddfcb999103412d81cfdf79a69a2ca14cdc8dd99e0f9704d8218e52d4793f4b5370ec1883433ef1cf17ea5c2e5b50c75a9e18b7f04d87d5db0bddbb63fb8bd6cceeaeccb0eb5af471d7320bfba01c1073ee025a95dfc63519f1e2b067d4fcaa9117fd81ec9205632439f59f12bfb005e2f6c4829d52276e54bb375fc6e7938845c2b10ceb2da4c292961ca15381203df13bbf71a84795725f63622453eb828c38c80ba3ba13b193c0c3f571357f0e75f824035d4ff4f55e0917ac1c7d27eeeb58ec24fd73ed17bb894098caef186ad0fb1b7ffd96a8eda1e86651d5b90c3ff762e022c40fa59ac05b04d3a78c9ef10e03db37b235020fcf328bfe3278a58d3e7efe77fe889e67d24673ced44cd0144415f61e30a9ce709620d8940735ea94737f4e7d19e79f7e454480575341598adb6b7870a7080d6a7e29d20978705b770d0de4a86d91c5b0bb2177b9e5c04719dab406dc5060b8ef273faf267ca1d50bf6453817d4b5222c7f9f74367a5c16fbd0ee68520782a2034abe08b53f99d9676aa6ff568adc2dc43fdae0bd7b199a7911e91097c12b301d453b44f2ba04716bcc7656716524f59f55dda20d00cb640e70cd56df01cb095de528ce12f82303bbea95a916abe412bb442bdda06d3787ee20747ae9ee56f15e28f80150cfdc9058fc630d3648a7982f189f84559914b177b658d0dbe015eaf4e950d83071039c0bbfa60009f5029c1b65e33576a7f840fd6c3cc9f1e2ad62e90882226121335440ce774b4eaa235fa4f29b4fa92d5efb7ee39e2518127556cdd8330e074238463f039c051ca76b509a96e8147f54be39abe7fd65616a006fe7904cf651bfbd9f46bc37851c8b28ae035be98c8f9e8aad8363183d7a08ba2d9111c83dee75479e39a85827a764bc5e20afca905dbc9ce78f83e30f3bb5e8a3e80fc62bfa85b70b07d8e74eb40de1512d4211c8e9d4652ab2f19ce36c588529cf24561bef374409122c21678aefa62d5382481287efeee2254f12b83671d01431d951e108222c710ae350f6ed3c56616889c0f2d9b2a9f6c256b2e0e68e951b6ad563588b4ab772d466d5b5951bce0417d6340375af1bf32d436ac2cb592fd3f39f039f0c12b1e21f56ece4ac4023eb29854d33aa7fdb21b18122a1f0e6d29b9edaa6e14c7cf8f4e4ea28f897bf514856ff362b9acd13685ec6ba5f2f9346f2b418a522bf6628e17490d51cc3d9dfa1d64f4cf55def96d02bab41c08977db2f34891a4a0c9afb61a969c6b21b20f48127b49e5d04cff37d9b4988c43cb7b772d82a66c9d34eaf0848883b14302474236bea52913cd7fcc098bc31f54bb7a5c808a5ab6d0f3a7b051ab069bb02454c91689b5f23a7e9310c082d2baf73f3b63e8ff05dfc78a2c580035ac84e02e104ade534788c2b3add093276b39b72e0ff8ca11b041d993f28e8ad0e9dc747637d076faf5d7823d04e4d7eee8deace20cb08559928de8c0d52bfc2225d7e6c9fd94b24be8f669517e20cb322b338c840800c7d88e4378aa9289c748dba20950f891fca2e0015dd28bc65e7085ba0988c6cc4fc0b6ba42b198bc6dac0b750c5204f8996a58f311502792faf78962f534d2ec4357ecfe4ef35f5d71a6493f355e481030e8f1fe0f0d0cab4e62b68b19efb4ce66236e676330df2173064eb6de6afb4a14a32431f52bb3d7ab2b0b1f6c9712f4de985cdfc5fbb854573593fd4298554d0adf561308e6696082ea1d570df158865cf9bb296e8f4d9e65995bdeeb857a528ac46faca50f57d1a5e0eb3c15fbba58d8b90497e59292406c2e5680fc496e1c83c6dff10355b9bc366ceca1a5ca26370ce8e32329b724d8955802051e6fe92687fc17d9b9d6c7debf30ac634725b90bf855641d7dc478010a96c979fb863c4194b04b86a5065f5a89dff1236cda4d1b4eef6e769e422d16bfdc00cf1e8807aa698b3eb5a0b69b901c8dcf95799894d95258f57f773fcb7bfa819a1d36d1fb925424a45e4a8b2797e889e2c7b6717f325e57b853f3ed47a5d7089463d4da20c84e1a04ea4616026e20fdb79fb0fac30e51371b98cf4bfbc7954d46a699e57440f2340ea5099a1b6c73929343f8aa6bb7ce9e04c8166058b15b1ae8e58c1ac765df0493f475a0f85c9a90e3a4726954264a3837dcc3733230f103156d707ae9e1b63991ba1142aca734bd0441c6f139f854a0ae334ad4fbfd96348595bbc52137edf3a7c7ec5107b0068e95bb798b79e11c59257235b61bc680da4e3cee23941d235ba7780b4fc5a97565806669b941d7d4233332fac0aa9ddc293d225e59500b57f0450cb3cb2ac694a320d77301f6491c1a63e1212ebfd2aecc609d17ebfedf5684afcaae05c67a90af374f66c1e45c3f71b584545c3cf704800263fbf70beffff9a4e63524b085d019d372a42c20f88de2a5cca79c95dfdc9e53d99ea2749d3e4e1d7ee03c692b5fadd181cac827a9d32cb5439dbb8eade7fdfb64bde8696da9f76c82e7c8c620692bb129629080eb7ab75fad8187c34731ab7c02b53ad0e20797079790dc1c478cff75727c3cbe5a6c370fea816510ed8e9aa8c6da924cef9a3738f71b093c35b10077c22373f1ef2ac5dbe3544c2aad47ef8aa1b412190c032f8819b852b0543837a7ade257875925086a4c3f888d9d9347835c85ea575d6aa28f9aa0c7f6689e5982d6e6f9156f2bca4b75d210479baa18161264fc1638fb49f63e149ddf20d04c24c316872003653abeff7ee861e0a5e8e904805bbde50ebb490992f86d6347f3079debea364c27299bd992cce8c29838ef21467893ab9629597fce2138cd70dd059f523ff6b1ecee18f0bbd0cae503497140e8089a85f2d1e5a458bd121f37b1008f24d07a6b0c1a5f3a0ad7e73ccc181610b37b974b29cfd6ec14141c18350315161e8235b03996fa380ec762e2362b30b3671984eefd3ab415fb1b4ed0bb7add866f84e24d59ad5af5acd6df512fb7a434cf57d506b9e830a84be609193ebd187320e95753d2fa3716d8507efacf35ba6e1a4e8a38a3bc8894d89a7ae0d75efc33c910e0397c48dc3bc3254e7c55231899ac6078f31aa454021934510d9041695cb27a5f2e2979f8ce4be4e6142f17362de95e7aae7e1d2e45a9cacc65ff93559a6821a90430b7bfa12c3b6d97c524202687da70391f57a1632dcc35a4f6bc6fe27851224f6c352d57c11f10e8fef125f57844ae078e81d94761e1d503522c2e1143392731548fb156dedff0e9d29393dc1e81d642011d142fbf2cf088d4464cfe75f12bf371a98c5e09c60ff69e7698a61aa2913114495653729985b8d47e835693f74340547e7180b523a37737bacf766a27ef97ef7fc9674574c71904d8d9ccab6d6d96c813dc247eeba25c68976a4f7914a0da1a7e597e566f85d477288144308d1f47ca04705b5bbc6153e5b780d76ac6b1fe5b0c575787e44acb270bd3889fb89e57defc3b480b5debaa79b1a5a08a581c5640d98504806a387fc0e4da8d85cbbaa5f02d5673cf5fe488cbef94b85f4639119f51e68a5e17ecc938dc47a674d99efa637c1b778a29b672305265ffe2b83edbee849f930f28a6fc7608f6c17985ee860ae6cae8e52291d0d42580f9445fe0b11b1e38316b452af1a15d7f05f758737d286dc6a3db87e0c95bd61393345b79fb39c950a6e98cce14d3038f882d356c95279723abd61245a826ede7952c1d87504f7e5e09d2ec797715413f7ab33af9c0ee3e3247535c50b9570353b1d3744f7d50efd4589d4d07a356e4e6b8996c990afd18ec24adce1151d0b0b50dcd6a24cc3fea32f251296012d114c85e81fbd8b0719658e4e1be481107347bd57d41be414009a4f9cd06aadd382b6c3201e355525a7f1a05162a7ad258b112064539e76be46c2422b4c5e913d17be40e68eab18512ebb9f2cee5d4bc5f1b69934320ead2d2c4500585fcf4e5440d524434881d14e1ce752e6d76f6d968c82e732ee0a1e08ae70b969e2e57712a4dd2286b3062fe388185f1fad56a64c95fdb29f051a159b4d4efda788c719cacad3367ab3205180a9c256117fa62e0c5512fccadf6a8b9406e20cbe88b2ffaf3fab0bbc2bc064b34298d52d17a631a141124142e22ac5d39d6fa0a592747b1e5dd1e17c5b93c53e9c8a02b094a74cb8ce67773b4b2113b73fbe6b26b76d21c5ab882f90ce54da7d34d1aeba160736941dbfba101b162809dee2f5d9ae1c63f93681b7e667a830acd7fcc87a1bb2ce6e7d6f91d6e19a7d0e78f5cec87681ed1079f4e0b3e81f2902e4f2558ec6d24dfe8700d8bb46f113dfcb75ac1d6783590f183b121d1e692a3d37285e9f2a29fc66ab7a72168afcf7dd0b1f64b8ba27c57fd1281fbf0ed91fb46cbf4acb62ea4e17aeec090bf1ca99afd7499276be140e4fbd427b59c741b8aac7f121c2055c88001ef539cb59bd1d4618bb3432814c48e2ead882817a0c115dfa87f45edc75643c5df7bedb22753733a464c863af82a2fa7b67f7a9d0d52ff8d2c67a7c22166701ef07e918cb49ccf25c934dc26c87d0605f219b957f57300fe6e48abf9c96a8d3eaacba4fb9a38f4855bbb2bc25587b18bace8356734e4a5a67120c9db0188f44085c9efe8170b7a51826c573fe07d610280ecec9d7df13fff1877ade62cdc08fdc99d3b1982854c39368084d54be2b919839656a9a6767d13ef7f209b16e433b098e48b467f69f978f9326f906b38ca06cc410ad36daee9fda5b3d015ba2699d781b1aecc611c795bd1f70d17294fd915195de6aa24986d056e1d2259b8da11c7801bbe34293b8515ba4f4ba312b0811c183681028086a20b06c07b3f1cfd31bd377b5fda2734b1f5f2b75c933d9c7b8534ffda6f2066ed63e174142ea67b5e24767728d82d6b99cc58b84255f912044fc0f9507ec5133614ba4b80b57eb939d68dd6cd82d9147cdf4004f694ece907d96f3549ad513cf932acc2756a52ff262e7b76e56d41f0a12a677331c35eb1848e9424947f19d56d1b561eb555fb8ab1898b7481865e7b56829fcef63291f2d4190a062356486e892ad61da2e437386000ce1bb1f7ced68510adae3c322f1027fbe4994f51378312fcbf5c9c63680ac38ae9c0041d42a78103257ce66806d6d370599d791505425b23686b7d6fd9e0390c328ba43e3b6acaf67a1b80b756a454d</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-flip">      <input class="hbe hbe-input-field hbe-input-field-flip" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-flip" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-flip" data-content="您好, 这里需要密码。">您好, 这里需要密码。</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;hbe hbe-container&quot; id=&quot;hexo-blog-encrypt&quot; data-wpm=&quot;抱歉, 这个密码看着不太对, 请再试试.&quot; data-whm=&quot;抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.&quot;&gt;
  &lt;script id=&quot;hbeData&quot; type=&quot;hbeData&quot; data-hmacdigest=&quot;8521b7cbfc6ac040635f9a48dc1ac7925f28db77691d8b73fa1bb2f8c2cd55d9&quot;&gt;4630436162ade97ba2718b7d0c4b3b63c7da53b2e21fbc742f4fcb8fd6f69935ce67815935b6f57a5b73addf9c977ccc0ea54af4dea5aa99daa2f80d61ca5fbac32625c835b1966fd872844401f18de6514b9581035e21af340f202ba6c0ff5f33825547078782189f6725a7a78cea80e919aab557e14006c86da505dd41b715b2fb028f618c8e1c2ba2482c71ff5b9db37c53e812d2e9631f20b1742e7f5c23187209e65dabf44a3e6056664b5597d7e1bff7385c58a577d0bdeda6d0dae9097ab61a278687581156d107efe5e349a2439e6dd131f771b7fc8cb850cbdffcd532b2388d80ecc765770869e67d1399ea5b51cb2ccf120cd90b783952e1cc8c567aa17ac3bfa002e2aef69fdfbe5dcfa7626ed4f2c22c5c06e211f3a85a046d5974a79db953724dd59937e49358192364197c139db1647cff3243f021b41d217fa261d68c7845e52f12afc5dd335126aeb6187ace9f0006d4f99327a08bce41202843d5a55d1182f4f2f30cd37d40a7e49776bcbb6c97a0b89a4054c5b0380c3e2f62b5a110095070c113a2997fc4dcfe8ec881a2034bc55931598dbfcd82cdddc76137a10450e8acb3e659b127a561a28f6eabfecc9db9a1e06806b80894a5d375e845b8f90d363904f1d3e575fcf69aa5972e5048d6bf719c02e19de31c3f9e9887e8681ea5ea35927d3d076d846d359a8fd799d92375841ec0354b33dfd9f974c56c4f4d2d280d02629672f529139ce4a14716f16c0ca17a6a90ac9c00574a4f776f524845ed5a597974e1b36d6439639eb6d45f0b36c02c7fcf8ecc063b8e8dbe0e967f2c0a54b18ba81d88f2053e363100282af8832f691bf6bbe39904db81a6fb77597d17e0ed18b8d2f2386d62f136ab29f3d838952c1819abd6d1f61206f8cddfcb999103412d81cfdf79a69a2ca14cdc8dd99e0f9704d8218e52d4793f4b5370ec1883433ef1cf17ea5c2e5b50c75a9e18b7f04d87d5db0bddbb63fb8bd6cceeaeccb0eb5af471d7320bfba01c1073ee025a95dfc63519f1e2b067d4fcaa9117fd81ec9205632439f59f12bfb005e2f6c4829d52276e54bb375fc6e7938845c2b10ceb2da4c292961ca15381203df13bbf71a84795725f63622453eb828c38c80ba3ba13b193c0c3f571357f0e75f824035d4ff4f55e0917ac1c7d27eeeb58ec24fd73ed17bb894098caef186ad0fb1b7ffd96a8eda1e86651d5b90c3ff762e022c40fa59ac05b04d3a78c9ef10e03db37b235020fcf328bfe3278a58d3e7efe77fe889e67d24673ced44cd0144415f61e30a9ce709620d8940735ea94737f4e7d19e79f7e454480575341598adb6b7870a7080d6a7e29d20978705b770d0de4a86d91c5b0bb2177b9e5c04719dab406dc5060b8ef273faf267ca1d50bf6453817d4b5222c7f9f74367a5c16fbd0ee68520782a2034abe08b53f99d9676aa6ff568adc2dc43fdae0bd7b199a7911e91097c12b301d453b44f2ba04716bcc7656716524f59f55dda20d00cb640e70cd56df01cb095de528ce12f82303bbea95a916abe412bb442bdda06d3787ee20747ae9ee56f15e28f80150cfdc9058fc630d3648a7982f189f84559914b177b658d0dbe015eaf4e950d83071039c0bbfa60009f5029c1b65e33576a7f840fd6c3cc9f1e2ad62e90882226121335440ce774b4eaa235fa4f29b4fa92d5efb7ee39e2518127556cdd8330e074238463f039c051ca76b509a96e8147f54be39abe7fd65616a006fe7904cf651bfbd9f46bc37851c8b28ae035be98c8f9e8aad8363183d7a08ba2d9111c83dee75479e39a85827a764bc5e20afca905dbc9ce78f83e30f3bb5e8a3e80fc62bfa85b70b07d8e74eb40de1512d4211c8e9d4652ab2f19ce36c588529cf24561bef374409122c21678aefa62d5382481287efeee2254f12b83671d01431d951e108222c710ae350f6ed3c56616889c0f2d9b2a9f6c256b2e0e68e951b6ad563588b4ab772d466d5b5951bce0417d6340375af1bf32d436ac2cb592fd3f39f039f0c12b1e21f56ece4ac4023eb29854d33aa7fdb21b18122a1f0e6d29b9edaa6e14c7cf8f4e4ea28f897bf514856ff362b9acd13685ec6ba5f2f9346f2b418a522bf6628e17490d51cc3d9dfa1d64f4cf55def96d02bab41c08977db2f34891a4a0c9afb61a969c6b21b20f48127b49e5d04cff37d9b4988c43cb7b772d82a66c9d34eaf0848883b14302474236bea52913cd7fcc098bc31f54bb7a5c808a5ab6d0f3a7b051ab069bb02454c91689b5f23a7e9310c082d2baf73f3b63e8ff05dfc78a2c580035ac84e02e104ade534788c2b3add093276b39b72e0ff8ca11b041d993f28e8ad0e9dc747637d076faf5d7823d04e4d7eee8deace20cb08559928de8c0d52bfc2225d7e6c9fd94b24be8f669517e20cb322b338c840800c7d88e4378aa9289c748dba20950f891fca2e0015dd28bc65e7085ba0988c6cc4fc0b6ba42b198bc6dac0b750c5204f8996a58f311502792faf78962f534d2ec4357ecfe4ef35f5d71a6493f355e481030e8f1fe0f0d0cab4e62b68b19efb4ce66236e676330df2173064eb6de6afb4a14a32431f52bb3d7ab2b0b1f6c9712f4de985cdfc5fbb854573593fd4298554d0adf561308e6696082ea1d570df158865cf9bb296e8f4d9e65995bdeeb857a528ac46faca50f57d1a5e0eb3c15fbba58d8b90497e59292406c2e5680fc496e1c83c6dff10355b9bc366ceca1a5ca26370ce8e32329b724d8955802051e6fe92687fc17d9b9d6c7debf30ac634725b90bf855641d7dc478010a96c979fb863c4194b04b86a5065f5a89dff1236cda4d1b4eef6e769e422d16bfdc00cf1e8807aa698b3eb5a0b69b901c8dcf95799894d95258f57f773fcb7bfa819a1d36d1fb925424a45e4a8b2797e889e2c7b6717f325e57b853f3ed47a5d7089463d4da20c84e1a04ea4616026e20fdb79fb0fac30e51371b98cf4bfbc7954d46a699e57440f2340ea5099a1b6c73929343f8aa6bb7ce9e04c8166058b15b1ae8e58c1ac765df0493f475a0f85c9a90e3a4726954264a3837dcc3733230f103156d707ae9e1b63991ba1142aca734bd0441c6f139f854a0ae334ad4fbfd96348595bbc52137edf3a7c7ec5107b0068e95bb798b79e11c59257235b61bc680da4e3cee23941d235ba7780b4fc5a97565806669b941d7d4233332fac0aa9ddc293d225e59500b57f0450cb3cb2ac694a320d77301f6491c1a63e1212ebfd2aecc609d17ebfedf5684afcaae05c67a90af374f66c1e45c3f71b584545c3cf704800263fbf70beffff9a4e63524b085d019d372a42c20f88de2a5cca79c95dfdc9e53d99ea2749d3e4e1d7ee03c692b5fadd181cac827a9d32cb5439dbb8eade7fdfb64bde8696da9f76c82e7c8c620692bb129629080eb7ab75fad8187c34731ab7c02b53ad0e20797079790dc1c478cff75727c3cbe5a6c370fea816510ed8e9aa8c6da924cef9a3738f71b093c35b10077c22373f1ef2ac5dbe3544c2aad47ef8aa1b412190c032f8819b852b0543837a7ade257875925086a4c3f888d9d9347835c85ea575d6aa28f9aa0c7f6689e5982d6e6f9156f2bca4b75d210479baa18161264fc1638fb49f63e149ddf20d04c24c316872003653abeff7ee861e0a5e8e904805bbde50ebb490992f86d6347f3079debea364c27299bd992cce8c29838ef21467893ab9629597fce2138cd70dd059f523ff6b1ecee18f0bbd0cae503497140e8089a85f2d1e5a458bd121f37b1008f24d07a6b0c1a5f3a0ad7e73ccc181610b37b974b29cfd6ec14141c18350315161e8235b03996fa380ec762e2362b30b3671984eefd3ab415fb1b4ed0bb7add866f84e24d59ad5af5acd6df512fb7a434cf57d506b9e830a84be609193ebd187320e95753d2fa3716d8507efacf35ba6e1a4e8a38a3bc8894d89a7ae0d75efc33c910e0397c48dc3bc3254e7c55231899ac6078f31aa454021934510d9041695cb27a5f2e2979f8ce4be4e6142f17362de95e7aae7e1d2e45a9cacc65ff93559a6821a90430b7bfa12c3b6d97c524202687da70391f57a1632dcc35a4f6bc6fe27851224f6c352d57c11f10e8fef125f57844ae078e81d94761e1d503522c2e1143392731548fb156dedff0e9d29393dc1e81d642011d142fbf2cf088d4464cfe75f12bf371a98c5e09c60ff69e7698a61aa2913114495653729985b8d47e835693f74340547e7180b523a37737bacf766a27ef97ef7fc9674574c71904d8d9ccab6d6d96c813dc247eeba25c68976a4f7914a0da1a7e597e566f85d477288144308d1f47ca04705b5bbc6153e5b780d76ac6b1fe5b0c575787e44acb270bd3889fb89e57defc3b480b5debaa79b1a5a08a581c5640d98504806a387fc0e4da8d85cbbaa5f02d5673cf5fe488cbef94b85f4639119f51e68a5e17ecc938dc47a674d99efa637c1b778a29b672305265ffe2b83edbee849f930f28a6fc7608f6c17985ee860ae6cae8e52291d0d42580f9445fe0b11b1e38316b452af1a15d7f05f758737d286dc6a3db87e0c95bd61393345b79fb39c950a6e98cce14d3038f882d356c95279723abd61245a826ede7952c1d87504f7e5e09d2ec797715413f7ab33af9c0ee3e3247535c50b9570353b1d3744f7d50efd4589d4d07a356e4e6b8996c990afd18ec24adce1151d0b0b50dcd6a24cc3fea32f251296012d114c85e81fbd8b0719658e4e1be481107347bd57d41be414009a4f9cd06aadd382b6c3201e355525a7f1a05162a7ad258b112064539e76be46c2422b4c5e913d17be40e68eab18512ebb9f2cee5d4bc5f1b69934320ead2d2c4500585fcf4e5440d524434881d14e1ce752e6d76f6d968c82e732ee0a1e08ae70b969e2e57712a4dd2286b3062fe388185f1fad56a64c95fdb29f051a159b4d4efda788c719cacad3367ab3205180a9c256117fa62e0c5512fccadf6a8b9406e20cbe88b2ffaf3fab0bbc2bc064b34298d52d17a631a141124142e22ac5d39d6fa0a592747b1e5dd1e17c5b93c53e9c8a02b094a74cb8ce67773b4b2113b73fbe6b26b76d21c5ab882f90ce54da7d34d1aeba160736941dbfba101b162809dee2f5d9ae1c63f93681b7e667a830acd7fcc87a1bb2ce6e7d6f91d6e19a7d0e78f5cec87681ed1079f4e0b3e81f2902e4f2558ec6d24dfe8700d8bb46f113dfcb75ac1d6783590f183b121d1e692a3d37285e9f2a29fc66ab7a72168afcf7dd0b1f64b8ba27c57fd1281fbf0ed91fb46cbf4acb62ea4e17aeec090bf1ca99afd7499276be140e4fbd427b59c741b8aac7f121c2055c88001ef539cb59bd1d4618bb3432814c48e2ead882817a0c115dfa87f45edc75643c5df7bedb22753733a464c863af82a2fa7b67f7a9d0d52ff8d2c67a7c22166701ef07e918cb49ccf25c934dc26c87d0605f219b957f57300fe6e48abf9c96a8d3eaacba4fb9a38f4855bbb2bc25587b18bace8356734e4a5a67120c9db0188f44085c9efe8170b7a51826c573fe07d610280ecec9d7df13fff1877ade62cdc08fdc99d3b1982854c39368084d54be2b919839656a9a6767d13ef7f209b16e433b098e48b467f69f978f9326f906b38ca06cc410ad36daee9fda5b3d015ba2699d781b1aecc611c795bd1f70d17294fd915195de6aa24986d056e1d2259b8da11c7801bbe34293b8515ba4f4ba312b0811c183681028086a20b06c07b3f1cfd31bd377b5fda2734b1f5f2b75c933d9c7b8534ffda6f2066ed63e174142ea67b5e24767728d82d6b99cc58b84255f912044fc0f9507ec5133614ba4b80b57eb939d68dd6cd82d9147cdf4004f694ece907d96f3549ad513cf932acc2756a52ff262e7b76e56d41f0a12a677331c35eb1848e9424947f19d56d1b561eb555fb8ab1898b7481865e7b56829fcef63291f2d4190a062356486e892ad61da2e437386000ce1bb1f7ced68510adae3c322f1027fbe4994f51378312fcbf5c9c63680ac38ae9c0041d42a78103257ce66806d6d370599d791505425b23686b7d6fd9e0390c328ba43e3b6acaf67a1b80b756a454d&lt;/script&gt;
  &lt;div class=&quot;hbe hbe-content&quot;&gt;
    &lt;div class=&quot;hbe hbe-input hbe-input-flip&quot;&gt;
      &lt;input class=&quot;hbe hbe-input-field hbe-input-field-flip&quot; type=&quot;password&quot; id=&quot;hbePass&quot;&gt;
      &lt;label class=&quot;hbe hbe-input-label hbe-input-label-flip&quot; for=&quot;hbePass&quot;&gt;
        &lt;span class=&quot;hbe hbe-input-label-content hbe-input-label-content-flip&quot; data-content=&quot;您好, 这里需要密码。&quot;&gt;您好, 这里需要密码。&lt;/span&gt;
      &lt;/label&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;
    
    </summary>
    
      <category term="AI" scheme="http://www.helioswei.top/categories/AI/"/>
    
      <category term="PaddleHub" scheme="http://www.helioswei.top/categories/AI/PaddleHub/"/>
    
    
      <category term="PaddleHub" scheme="http://www.helioswei.top/tags/PaddleHub/"/>
    
  </entry>
  
  <entry>
    <title>centos7-libreoffice安装和启动</title>
    <link href="http://www.helioswei.top/article/3025513893.html"/>
    <id>http://www.helioswei.top/article/3025513893.html</id>
    <published>2020-12-03T02:17:38.000Z</published>
    <updated>2021-03-01T02:04:04.264Z</updated>
    
    <content type="html"><![CDATA[<p>​    centos7下的文档转码的利器<code>libreoffice</code>，下面介绍一下centos7平台上对于这个软件的安装</p><h3 id="libreoffice下载"><a href="#libreoffice下载" class="headerlink" title="libreoffice下载"></a>libreoffice下载</h3><p><a href="https://www.libreoffice.org/download/download/">libreoffice下载</a>，在这里可以下载LO的最新的版本</p><p>这个是网上找的镜像，<a href="http://mirrors.ustc.edu.cn/tdf/libreoffice/stable/">可以参考</a></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LibreOffice_6.4.3_Linux_x86-64_rpm_langpack_zh-CN.tar</span><br><span class="line">LibreOffice_6.4.3_Linux_x86-64_rpm.tar.gz</span><br><span class="line">LibreOffice_6.4.3_Linux_x86-64_rpm_sdk.tar.gz</span><br></pre></td></tr></table></figure><h4 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf LibreOffice_6.4.3_Linux_x86-64_rpm_langpack_zh-CN.tar -C /root/libreoffice</span><br><span class="line">tar -zxvf LibreOffice_6.4.3_Linux_x86-64_rpm.tar.gz -C /root/libreoffice</span><br><span class="line">tar -zxvf LibreOffice_6.4.3_Linux_x86-64_rpm_sdk.tar.gz -C /root/libreoffice</span><br></pre></td></tr></table></figure><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>进入每个目录下的RPMS目录下使用以下命令执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum localinstall *.rpm</span><br></pre></td></tr></table></figure><h4 id="安装依赖包"><a href="#安装依赖包" class="headerlink" title="安装依赖包"></a>安装依赖包</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum install cairo</span><br><span class="line">yum install cups-libs</span><br><span class="line">yum install libSM</span><br></pre></td></tr></table></figure><h4 id="汉化"><a href="#汉化" class="headerlink" title="汉化"></a>汉化</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum groupinstall &quot;fonts&quot;</span><br></pre></td></tr></table></figure><h4 id="example"><a href="#example" class="headerlink" title="example"></a>example</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">libreoffice6.4 --headless --invisible --convert-to pdf test.docx --outdir /data/file</span><br></pre></td></tr></table></figure><h3 id="bug提交"><a href="#bug提交" class="headerlink" title="bug提交"></a>bug提交</h3><p>在使用的过程中，我发现了一个bug，影响了我产品的功能，所有让社区的管理帮忙提交了bug修复，<a href="https://bbs.libreofficechina.org/thread-2616-1-1.html">见下</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;​    centos7下的文档转码的利器&lt;code&gt;libreoffice&lt;/code&gt;，下面介绍一下centos7平台上对于这个软件的安装&lt;/p&gt;
    
    </summary>
    
      <category term="Media" scheme="http://www.helioswei.top/categories/Media/"/>
    
      <category term="doc" scheme="http://www.helioswei.top/categories/Media/doc/"/>
    
    
      <category term="libreoffice" scheme="http://www.helioswei.top/tags/libreoffice/"/>
    
  </entry>
  
  <entry>
    <title>centos7-openoffice安装和启动</title>
    <link href="http://www.helioswei.top/article/1736132591.html"/>
    <id>http://www.helioswei.top/article/1736132591.html</id>
    <published>2020-12-03T02:17:28.000Z</published>
    <updated>2021-03-01T02:04:04.264Z</updated>
    
    <content type="html"><![CDATA[<p>  本文介绍了openoffice在Centos7下的安装和启动以及使用的方法，供大家学习和参考。</p><h3 id="openoffice包的下载"><a href="#openoffice包的下载" class="headerlink" title="openoffice包的下载"></a>openoffice包的下载</h3><p><a href="http://www.openoffice.org/download/">openoffice下载</a></p><p><img src="/images/openoffice/openoffice.png" alt="open"></p><h4 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf Apache_OpenOffice_4.1.8_Linux_x86-64_install-rpm_zh-CN.tar.gz</span><br></pre></td></tr></table></figure><h4 id="进入解压目录"><a href="#进入解压目录" class="headerlink" title="进入解压目录"></a>进入解压目录</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd zh-CN/RPMS</span><br></pre></td></tr></table></figure><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum localinstall *.rpm</span><br></pre></td></tr></table></figure><p><code>装完后会在当前目录下生成一个desktop-integration目录</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd zh-CN&#x2F;RPMS&#x2F;desktop-integration&#x2F;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh openoffice4.1.5-redhat-menus-4.1.5-9789.noarch.rpm</span><br></pre></td></tr></table></figure><h4 id="下载依赖包"><a href="#下载依赖包" class="headerlink" title="下载依赖包"></a>下载依赖包</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install libXext.x86_64</span><br></pre></td></tr></table></figure><h4 id="下载java环境"><a href="#下载java环境" class="headerlink" title="下载java环境"></a>下载java环境</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install jre java-devel</span><br></pre></td></tr></table></figure><h4 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/opt/openoffice4/program/soffice -headless -accept=<span class="string">&quot;socket,host=127.0.0.1,port=8100;urp;&quot;</span> -nofirststartwizard</span><br></pre></td></tr></table></figure><h3 id="JODConverter下载"><a href="#JODConverter下载" class="headerlink" title="JODConverter下载"></a>JODConverter下载</h3><p><a href="https://sourceforge.net/projects/jodconverter/">jodConverter下载</a></p><h4 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip jodconverter-2.2.2.zip</span><br></pre></td></tr></table></figure><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p><code>必须先启动openoffice的服务，然后再使用这个命令行</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar jodconverter-2.2.2/lib/jodconverter-cli-2.2.2.jar  inputfileName outputfileName</span><br></pre></td></tr></table></figure><h4 id="example"><a href="#example" class="headerlink" title="example"></a>example</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar jodconverter-2.2.2/lib/jodconverter-cli-2.2.2.jar  media/01-自然语言处理-中文分词算法的实现.pptx.pptx  media/o1.pdf</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  本文介绍了openoffice在Centos7下的安装和启动以及使用的方法，供大家学习和参考。&lt;/p&gt;
    
    </summary>
    
      <category term="Media" scheme="http://www.helioswei.top/categories/Media/"/>
    
      <category term="doc" scheme="http://www.helioswei.top/categories/Media/doc/"/>
    
    
      <category term="openoffice" scheme="http://www.helioswei.top/tags/openoffice/"/>
    
  </entry>
  
  <entry>
    <title>centos7-yum的使用</title>
    <link href="http://www.helioswei.top/article/1714992348.html"/>
    <id>http://www.helioswei.top/article/1714992348.html</id>
    <published>2020-11-19T09:40:53.000Z</published>
    <updated>2021-03-04T05:27:55.178Z</updated>
    
    <content type="html"><![CDATA[<p>记录yum的使用</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><h4 id="搜索指定的版本安装"><a href="#搜索指定的版本安装" class="headerlink" title="搜索指定的版本安装"></a>搜索指定的版本安装</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum list --showduplicates xxx</span><br></pre></td></tr></table></figure><h4 id="下载软件包"><a href="#下载软件包" class="headerlink" title="下载软件包"></a>下载软件包</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install yum-plugin-downloadonly</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install fontconfig --downloadonly --downloaddir&#x3D;&#x2F;root&#x2F;wei&#x2F;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录yum的使用&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://www.helioswei.top/categories/Linux/"/>
    
      <category term="centos7" scheme="http://www.helioswei.top/categories/Linux/centos7/"/>
    
    
      <category term="yum" scheme="http://www.helioswei.top/tags/yum/"/>
    
  </entry>
  
  <entry>
    <title>ffmpeg-内存io模式(内存区做输入或输出)</title>
    <link href="http://www.helioswei.top/article/2452888490.html"/>
    <id>http://www.helioswei.top/article/2452888490.html</id>
    <published>2020-10-14T07:03:21.000Z</published>
    <updated>2021-03-01T02:04:04.271Z</updated>
    
    <content type="html"><![CDATA[<p>​    在转码的过程中，我们有时候需要从远程下载文件，当文件很大的时候会占用本地的磁盘空间，同时下载的时间也比较的长，这时候我们考虑直接读取流信息或者写入流信息来进行操作，而不是上传或者下载整个文件来解决。</p><h3 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h3><p>​    转码的基础逻辑不变，仅仅是在输入输出读取的方式不同，我们需要自己实现输入输出的函数。</p><h4 id="关键结构体"><a href="#关键结构体" class="headerlink" title="关键结构体"></a>关键结构体</h4><p>​    <code>AVIOContext</code>，我们需要初始化这个结构体来存放内存的数据。</p><h3 id="内存读取数据"><a href="#内存读取数据" class="headerlink" title="内存读取数据"></a>内存读取数据</h3><p>​        转码的基本流程不变，仅仅是在开始读取数据的时候有些不同</p><h4 id="读取本地文件"><a href="#读取本地文件" class="headerlink" title="读取本地文件"></a>读取本地文件</h4><p><img src="/images/ffmpeg/file.png" alt="file"></p><h4 id="读取流文件"><a href="#读取流文件" class="headerlink" title="读取流文件"></a>读取流文件</h4><p><img src="/images/ffmpeg/stream.png" alt="stream"></p><p><img src="/images/ffmpeg/readstream.png" alt="read"></p><h3 id="ffmpeg内存读取数据"><a href="#ffmpeg内存读取数据" class="headerlink" title="ffmpeg内存读取数据"></a>ffmpeg内存读取数据</h3><p>​    如图,<font color="red">红色框</font>内是当输入是流时的处理，<font color="green">绿色框</font>内是当输入是文件时的处理，二选一即可。<img src="/images/ffmpeg/stream/input.png" alt="input.png"></p><p><code>fill_iobuffer</code> 函数是我们自己实现的输入流的函数，内容如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">359</span> <span class="comment">//读取流数据</span></span><br><span class="line"><span class="number">360</span> <span class="function"><span class="keyword">int</span> <span class="title">fill_iobuffer</span><span class="params">(<span class="keyword">void</span> *opaque, <span class="keyword">uint8_t</span> *buf, <span class="keyword">int</span> buf_size)</span> </span>&#123;</span><br><span class="line"><span class="number">361</span>     <span class="built_in">string</span> hosts = <span class="string">&quot;192.168.50.31:7480&quot;</span>;</span><br><span class="line"><span class="number">362</span>     <span class="built_in">string</span> ak = <span class="string">&quot;11043ee2070d01eb5740f9870dfe3abd&quot;</span>;</span><br><span class="line"><span class="number">363</span>     <span class="built_in">string</span> sk = <span class="string">&quot;bb31a3a96b829976513ee62b4e28ee3f&quot;</span>;</span><br><span class="line"><span class="number">364</span>     <span class="function">S3::Client <span class="title">client</span><span class="params">(hosts, ak, sk)</span></span>;</span><br><span class="line"><span class="number">365</span>     <span class="keyword">static</span> <span class="keyword">uint64_t</span> offset = <span class="number">0</span>;</span><br><span class="line"><span class="number">366</span>     <span class="keyword">uint64_t</span> num;</span><br><span class="line"><span class="number">367</span>     <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="number">368</span>         <span class="comment">// num  = client.GetObject(&quot;leopardsrc&quot;, &quot;video-H263-AC3.avi&quot;,offset,</span></span><br><span class="line"><span class="number">369</span>         <span class="comment">// buf_size, (char* )buf);</span></span><br><span class="line"><span class="number">370</span>         num = client.GetObject(<span class="string">&quot;leopardsrc&quot;</span>, <span class="string">&quot;video-H264-AAC.m4v&quot;</span>, offset,</span><br><span class="line"><span class="number">371</span>                                buf_size, (<span class="keyword">char</span> *)buf);</span><br><span class="line"><span class="number">372</span>         offset += num;</span><br><span class="line"><span class="number">373</span>         <span class="keyword">return</span> num;</span><br><span class="line"><span class="number">374</span>     &#125;</span><br><span class="line"><span class="number">375</span>     <span class="keyword">catch</span> (S3::S3Exception &amp;e) &#123;</span><br><span class="line"><span class="number">376</span>         LOG(ERROR) &lt;&lt; e.str();</span><br><span class="line"><span class="number">377</span>         <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">378</span>     &#125;</span><br><span class="line"><span class="number">379</span> &#125;   </span><br></pre></td></tr></table></figure><h3 id="ffmpeg内存存储数据"><a href="#ffmpeg内存存储数据" class="headerlink" title="ffmpeg内存存储数据"></a>ffmpeg内存存储数据</h3><p>​    如图,<font color="red">红色框</font>内是当输入是流时的处理，<font color="green">绿色框</font>内是当输入是文件时的处理，二选一即可。<img src="/images/ffmpeg/stream/output.png" alt="output.png"></p><p><code>write_buffer</code> 函数是我们自己实现的输出流的函数，内容如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">614</span> <span class="function"><span class="keyword">int</span> <span class="title">write_buffer</span><span class="params">(<span class="keyword">void</span> *opaque, <span class="keyword">uint8_t</span> *buf, <span class="keyword">int</span> buf_size)</span> </span>&#123;</span><br><span class="line"><span class="number">627</span>     <span class="keyword">if</span> (!feof(fp_write)) &#123;</span><br><span class="line"><span class="number">634</span>         <span class="keyword">int</span> true_size = fwrite(buf, <span class="number">1</span>, buf_size, fp_write);</span><br><span class="line"><span class="number">635</span>         <span class="keyword">return</span> true_size;</span><br><span class="line"><span class="number">636</span>     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="number">637</span>         <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="number">638</span>     &#125;</span><br><span class="line"><span class="number">639</span> &#125; </span><br></pre></td></tr></table></figure><p>​    目前这个是测试ffmpeg能够支持自己的输出函数，如果是关于s3的输出支持，需要看s3关于流的实现接口。目前s3是不支持流的处理，只能考虑s3的分块上传。</p><h4 id="输出到内存注意事项"><a href="#输出到内存注意事项" class="headerlink" title="输出到内存注意事项"></a>输出到内存注意事项</h4><h5 id="avio-open"><a href="#avio-open" class="headerlink" title="avio_open"></a>avio_open</h5><p>​    当你的输出函数是自己实现的，不是默认的写入到本地文件，则<code>avio_open</code>这个函数不能够被调用。如图,加入一个判断，当输出为自定义函数时不调用avio_open函数。<img src="/images/ffmpeg/stream/avio.png" alt="avio.png"></p><p>同样，在释放资源的时候也需要做相同的处理。在文件<code>mediainfo.h</code>中的<code>~FileInfoStruct()</code>函数中加入一层判断。<img src="/images/ffmpeg/stream/avio1.png" alt="avio1.png"></p><h5 id="输出封装格式的限制"><a href="#输出封装格式的限制" class="headerlink" title="输出封装格式的限制"></a>输出封装格式的限制</h5><p>​    有一些封装格式不支持以流的方式作为输出，如mp4，错误信息如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[mp4 @ 0x8d0c80] muxer does not support non seekable output</span><br></pre></td></tr></table></figure><p>​    解决方法：通过将mp4文件进行碎片化，即生成Fmp4格式来进行操作。如图  <img src="/images/ffmpeg/stream/fmp4.png" alt="fmp4.png"></p><p>​    我们需要添加<code>movflags</code>参数来进行处理。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;​    在转码的过程中，我们有时候需要从远程下载文件，当文件很大的时候会占用本地的磁盘空间，同时下载的时间也比较的长，这时候我们考虑直接读取流信息或者写入流信息来进行操作，而不是上传或者下载整个文件来解决。&lt;/p&gt;
    
    </summary>
    
      <category term="Media" scheme="http://www.helioswei.top/categories/Media/"/>
    
      <category term="video" scheme="http://www.helioswei.top/categories/Media/video/"/>
    
    
      <category term="ffmpeg" scheme="http://www.helioswei.top/tags/ffmpeg/"/>
    
      <category term="io" scheme="http://www.helioswei.top/tags/io/"/>
    
  </entry>
  
  <entry>
    <title>rabbitmq-AMQPCPP使用问题记录</title>
    <link href="http://www.helioswei.top/article/3077642244.html"/>
    <id>http://www.helioswei.top/article/3077642244.html</id>
    <published>2020-09-29T08:57:46.000Z</published>
    <updated>2021-03-01T02:04:04.285Z</updated>
    
    <content type="html"><![CDATA[<p>​        记录<a href="https://github.com/CopernicaMarketingSoftware/AMQP-CPP">AMQP_CPP</a>的使用过程中出现的问题，我是用的主要是<code>LibEvHandler</code>这个类来进行处理的,以下所有的问题都是在这个基础上面,仔细的查看头文件可以了解更多的使用方法。</p><h3 id="任务执行长时间后导致连接丢失的问题"><a href="#任务执行长时间后导致连接丢失的问题" class="headerlink" title="任务执行长时间后导致连接丢失的问题"></a>任务执行长时间后导致连接丢失的问题</h3><p><code>LibEvHandler</code>中对于rabbitmq的默认心跳是60s，如果当前队列没有任务处理，则其会自动的发送心跳，保持client和server之间的连接，如果你执行某个任务的时间过长，大于60s，则在执行任务期间，其不会自动的发送心跳导致两者之间的连接断开，导致下次获取数据时提示链接错误，获取数据失败。解决办法：</p><ol><li><p>重写LibEvHandler中的<code>onNegotiate</code>以及<code>onHeartbeat</code>这两个方法，前者用于设置心跳的时间，后者用于心跳发送时的函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; <span class="number">23</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHandler</span> :</span> <span class="keyword">public</span> AMQP::LibEvHandler &#123;</span><br><span class="line">   <span class="number">24</span>  </span><br><span class="line">   <span class="number">25</span>    <span class="keyword">public</span>:</span><br><span class="line">&gt;&gt; <span class="number">26</span>     MyHandler(struct ev_loop* loop) : AMQP::LibEvHandler(loop) &#123;&#125;</span><br><span class="line">   <span class="number">27</span>     <span class="comment">//解决consume在处理任务时的连接超时的问题</span></span><br><span class="line">&gt;&gt; <span class="number">28</span>     <span class="function"><span class="keyword">uint16_t</span> <span class="title">onNegotiate</span><span class="params">(AMQP::TcpConnection* connection, <span class="keyword">uint16_t</span> timeout)</span> </span>&#123;</span><br><span class="line">   <span class="number">29</span>         <span class="keyword">return</span> <span class="number">70</span>;<span class="comment">//必须设置一个值</span></span><br><span class="line">   <span class="number">30</span>     &#125;</span><br><span class="line">&gt;&gt; <span class="number">31</span>     <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onHeartbeat</span><span class="params">(AMQP::TcpConnection* connection)</span> </span>&#123;</span><br><span class="line">   <span class="number">32</span>         connection-&gt;heartbeat();</span><br><span class="line">   <span class="number">33</span>     &#125;</span><br><span class="line">   <span class="number">34</span> &#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>另外开一个线程，定时手动的发送心跳给rabbitmq</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">   <span class="number">46</span>     <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&gt;&gt; <span class="number">47</span>         <span class="class"><span class="keyword">struct</span> <span class="title">ev_loop</span>* <span class="title">loop</span> =</span> ev_loop_new();</span><br><span class="line">   <span class="number">48</span>         <span class="comment">// AMQP::LibEvHandler handler(loop);</span></span><br><span class="line">   <span class="number">49</span>         <span class="function">MyHandler <span class="title">handler</span><span class="params">(loop)</span></span>;</span><br><span class="line">   <span class="number">50</span>         <span class="function">AMQP::TcpConnection <span class="title">connection</span><span class="params">(&amp;handler, *_address)</span></span>;</span><br><span class="line">   <span class="number">51</span>         _connection = &amp;connection;</span><br><span class="line">   <span class="number">52</span>         <span class="function">AMQP::TcpChannel <span class="title">channel</span><span class="params">(&amp;connection)</span></span>;</span><br><span class="line">   <span class="number">53</span>         <span class="comment">//// channel.setQos(1);</span></span><br><span class="line">   <span class="number">54</span>         _channel = &amp;channel;</span><br><span class="line">              <span class="comment">//另外开一个线程，用于检测rabbitmq的链接，以及定时的发送心跳</span></span><br><span class="line">   <span class="number">55</span>         <span class="function"><span class="built_in">std</span>::thread <span class="title">check</span><span class="params">(&amp;Consume::checkConnect, <span class="keyword">this</span>)</span></span>;</span><br><span class="line">   <span class="number">56</span>         <span class="comment">// 1s后执行一次回调，之后每10s执行一次</span></span><br><span class="line">   <span class="number">57</span>         ev_timer_init(&amp;_timer, TClass::callback, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">   <span class="number">58</span>         _timer.data = <span class="keyword">this</span>;</span><br><span class="line">   <span class="number">59</span>         ev_timer_start(loop, &amp;_timer);</span><br><span class="line">   <span class="number">60</span>         ev_run(loop, <span class="number">0</span>);</span><br><span class="line">   <span class="number">61</span>         check.join();</span><br><span class="line">   <span class="number">62</span>     &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">165</span>     <span class="function"><span class="keyword">void</span> <span class="title">checkConnect</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="number">166</span>         <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="comment">//判读链接是否可用，可用即发送心跳</span></span><br><span class="line"><span class="number">167</span>             <span class="keyword">if</span> (_connection-&gt;usable()) _connection-&gt;heartbeat();</span><br><span class="line">                <span class="comment">//判读当前通道是否可用，如果失败则杀死当前程序</span></span><br><span class="line"><span class="number">168</span>             _channel-&gt;onError([&amp;](<span class="keyword">const</span> <span class="keyword">char</span>* message) &#123;</span><br><span class="line"><span class="number">169</span>                 LOG(ERROR) &lt;&lt; <span class="string">&quot;The channel is error, exit: &quot;</span> &lt;&lt; message;</span><br><span class="line"><span class="number">170</span>                 killAll();</span><br><span class="line"><span class="number">171</span>             &#125;);</span><br><span class="line">                <span class="comment">//判读当前连接是否关闭，如果关闭则杀死当前程序</span></span><br><span class="line"><span class="number">172</span>             <span class="keyword">if</span> (_connection-&gt;closed()) &#123;</span><br><span class="line"><span class="number">173</span>                 <span class="keyword">if</span> (_connection != <span class="literal">NULL</span>) _connection-&gt;close();</span><br><span class="line"><span class="number">174</span>                 LOG(ERROR) &lt;&lt; <span class="string">&quot;The connection is closed,exit&quot;</span>;</span><br><span class="line"><span class="number">175</span>                 killAll();</span><br><span class="line"><span class="number">176</span>             &#125;</span><br><span class="line">                <span class="comment">//sleep 5s</span></span><br><span class="line"><span class="number">177</span>             Poco::Thread::sleep(<span class="number">5000</span>);</span><br><span class="line"><span class="number">178</span>         &#125;</span><br><span class="line"><span class="number">179</span>     &#125;</span><br><span class="line"><span class="number">180</span>     <span class="function"><span class="keyword">void</span> <span class="title">killAll</span><span class="params">()</span> </span>&#123; kill(<span class="number">0</span>, SIGABRT); &#125;</span><br><span class="line">   </span><br></pre></td></tr></table></figure></li></ol><h3 id="每次仅仅处理一个任务的问题"><a href="#每次仅仅处理一个任务的问题" class="headerlink" title="每次仅仅处理一个任务的问题"></a>每次仅仅处理一个任务的问题</h3><p>​        对于消息者来说，监听一个队列，如果队列里面有多条的数据，其会一下子都消费掉（有个最大值可查文档），比如你的队列里面有100条数据，其会都拿到放到内存中，如果过程中你的服务挂掉，则数据会丢失，为了解决这个问题，我们需要设置消费者每次拿到的数据量。AMQP_CPP中使用<code>setQos()</code>来进行设置</p><font color="red"><code>注意：仅对手动ack有效</code></font><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">AMQP::TcpChannel <span class="title">channel</span><span class="params">(&amp;connection)</span></span>;</span><br><span class="line">channel.setQos(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><h3 id="无法重新连接的问题"><a href="#无法重新连接的问题" class="headerlink" title="无法重新连接的问题"></a>无法重新连接的问题</h3><p>如果我们的rabbitmq挂了我们的服务应该怎么办了，一般对于这种有两种方法来处理</p><ol><li>实现rabbitmq的重试机制，rabbitmq连接断开后，我们能够自动的恢复；</li><li>服务中断机制，rabbitmq连接断开，我们的服务也中断，再通过某个服务能够拉起（守护进程）</li></ol><p>再AMQP_CPP中重连的机制不好处理，所以我们选择第二种方法</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;​        记录&lt;a href=&quot;https://github.com/CopernicaMarketingSoftware/AMQP-CPP&quot;&gt;AMQP_CPP&lt;/a&gt;的使用过程中出现的问题，我是用的主要是&lt;code&gt;LibEvHandler&lt;/code&gt;这个类来进行处理的,以下所有的问题都是在这个基础上面,仔细的查看头文件可以了解更多的使用方法。&lt;/p&gt;
    
    </summary>
    
      <category term="Database" scheme="http://www.helioswei.top/categories/Database/"/>
    
      <category term="rabbitmq" scheme="http://www.helioswei.top/categories/Database/rabbitmq/"/>
    
    
      <category term="rabbitmq" scheme="http://www.helioswei.top/tags/rabbitmq/"/>
    
  </entry>
  
  <entry>
    <title>ffmpeg-转码后丢帧的问题</title>
    <link href="http://www.helioswei.top/article/3032443121.html"/>
    <id>http://www.helioswei.top/article/3032443121.html</id>
    <published>2020-09-29T08:35:30.000Z</published>
    <updated>2021-03-01T02:04:04.272Z</updated>
    
    <content type="html"><![CDATA[<p>在生产环境的使用中，我们转码有时候会出现缺帧的情况，比如一个10s的视频，经过转码后只有了7s，这就是因为转码逻辑没有处理好，导致丢失了大量的帧。</p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h5 id="ffmpeg提供了两组函数，分别用于编码和解码："><a href="#ffmpeg提供了两组函数，分别用于编码和解码：" class="headerlink" title="ffmpeg提供了两组函数，分别用于编码和解码："></a>ffmpeg提供了两组函数，分别用于编码和解码：</h5><ul><li>解码：<code>avcodec_send_packet()</code>、<code>avcodec_receive_frame()</code></li><li>编码：<code>avcodec_send_frame()</code>、<code>avcodec_receive_packet()</code></li></ul><h5 id="在一个循环体内去接收codec的输出"><a href="#在一个循环体内去接收codec的输出" class="headerlink" title="在一个循环体内去接收codec的输出"></a>在一个循环体内去接收codec的输出</h5><p>即周期性地调用<code>avcodec_receive_()</code>来接收codec输出的数据：</p><ul><li><p><strong>解码</strong>：调用<code>avcodec_receive_frame()</code>，如果成功会返回一个包含未压缩数据的<code>AVFrame</code>。</p></li><li><p><strong>编码</strong>：调用<code>avcodec_receive_packet()</code>，如果成功会返回一个包含压缩数据的<code>AVPacket</code>。</p></li><li><p><strong>反复</strong>地调用<code>avcodec_receive_packet()</code>直到返回 <code>AVERROR(EAGAIN)</code>或其他错误。返回<code>AVERROR(EAGAIN)</code>错误表示codec需要新的输入来输出更多的数据。对于每个输入的packet或frame，codec一般会输出一个frame或packet，<strong>但是也有可能输出0个或者多于1个</strong>。部分代码实例：</p></li><li><p>~~~cpp<br>1514     while(true){<br>  1515         //对于每个输入的packet或者frame，codec一般会输出一个frame或者packet，但是也有可能输出0个或者多于1个<br>  1516         //对于多于1个的情况，我们使用while来解决<br>  1517         error = avcodec_receive_packet(encCtx, &amp;outputPacket);<br>  1518         if (error == AVERROR(EAGAIN)) {<br>  1519             error = 0;<br>  1520             // cout &lt;&lt; “EAGAIN” &lt;&lt; endl;<br>  1521             goto cleanup;<br>  1522         } else if (error == AVERROR_EOF) {<br>  1523             error = 0;<br>  1524             goto cleanup;<br>  1525         } else if (error &lt; 0) {<br>  1526             av_log(NULL, AV_LOG_ERROR, “Could not encode frame\n”);<br>  1527             goto cleanup;<br>  1528         } else {<br>  1529             <em>dataPresent = 1;<br>  1530         }<br>  1531<br>  1532         outputPacket.stream_index = streamIndex;<br>  1533<br>  1534         //转换pts<br>  1535         av_packet_rescale_ts(&amp;outputPacket, encCtx-&gt;time_base,<br>  1536                              ofmtCtx-&gt;streams[streamIndex]-&gt;time_base);<br>  1537<br>  1538         // if (AVMEDIA_TYPE_AUDIO == encCtx -&gt; codec_type){<br>  1539         //  _pts2ms = outputPacket.pts </em>av_q2d(ofmtCtx -&gt; streams[streamIndex] -&gt;<br>  1540         // time_base) <em> 1000 ;//单位ms(微妙)<br>  1541         //}<br>  1542         //_pts2ms = outputPacket.pts </em>av_q2d(ofmtCtx -&gt; streams[streamIndex] -&gt;<br>  1543         // time_base) <em> 1000 ;//单位ms(微妙)<br>  1544         pts2ms = outputPacket.pts </em><br>  1545                  av_q2d(ofmtCtx-&gt;streams[streamIndex]-&gt;time_base) <em><br>  1546                  1000;  //单位ms(微妙)<br>  1547                         //编码视频和音频的时候，两者的时间是不一样的，为了保证进度一直向前，所以取最大值<br>  1548         if (pts2ms &gt; _pts2ms) _pts2ms = pts2ms;<br>  1549         av_log(NULL, AV_LOG_INFO, “progress: %s\n”, printProgress().c_str());<br>  1550         sendProgress();<br>  1551         if (!_ip.empty()) printProgress(_ip, _port);<br>  1552<br>  1553         if (</em>dataPresent &amp;&amp;<br>  1554             (error = av_interleaved_write_frame(ofmtCtx, &amp;outputPacket)) &lt; 0) {<br>  1555             av_log(NULL, AV_LOG_ERROR, “Could not write frame,%s,%s:%d\n”,<br>  1556                    av_err2str(error), <strong>FILE</strong>, <strong>LINE</strong>);<br>  1557             goto cleanup;<br>  1558         }<br>  1559     }   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 流处理结束的时候需要flush（洗刷） codec。因为codec可能在内部缓冲多个frame或packet，出于性能或其他必要的情况（如考虑B帧的情况）。 处理流程如下：</span><br><span class="line"></span><br><span class="line">  1. 调用&#96;avcodec_send_()&#96;传入的AVFrame或AVPacket指针设置为NULL。 这将开启draining mode（排水模式）</span><br><span class="line"></span><br><span class="line">     ~~~cpp</span><br><span class="line">       1653     int dataWritten;</span><br><span class="line">       1654     int ret;       </span><br><span class="line">       1655     if (NULL !&#x3D; output-&gt;videoStream) &#123;</span><br><span class="line">       1656         do &#123;       </span><br><span class="line">       1657             dataWritten &#x3D; 0;</span><br><span class="line">       1658             ret &#x3D; encodeMediaFrame(NULL, output-&gt;formatContext,</span><br><span class="line">       1659                                    output-&gt;videoCodecCtx, &amp;dataWritten,</span><br><span class="line">       1660                                    output-&gt;videoStream-&gt;index);</span><br><span class="line">       1661             if (0 &gt; ret) &#123;</span><br><span class="line">       1662                 av_log(NULL, AV_LOG_ERROR,</span><br><span class="line">       1663                        &quot;Failed whileflush video encode, %s:%d\n&quot;, __FILE__,</span><br><span class="line">       1664                        __LINE__);</span><br><span class="line">       1665                 return ret;</span><br><span class="line">       1666             &#125;      </span><br><span class="line">       1667             av_log(NULL, AV_LOG_INFO, &quot;flush video encoder data\n&quot;);</span><br><span class="line">       1668         &#125; while (dataWritten);</span><br><span class="line">       1669     &#125;  </span><br></pre></td></tr></table></figure><ol start="2"><li><p>反复地调用<code>avcodec_receive_()</code>直到返回<code>AVERROR_EOF</code>的错误，这个方法这个时候不会返回<code>AVERROR(EAGAIN)</code>的错误，除非你忘记了开启draining mode</p></li><li><p>codec可以重新开启，但是需要先调用 <code>avcodec_flush_buffers()</code>来重置codec</p></li></ol></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在生产环境的使用中，我们转码有时候会出现缺帧的情况，比如一个10s的视频，经过转码后只有了7s，这就是因为转码逻辑没有处理好，导致丢失了大量的帧。&lt;/p&gt;
    
    </summary>
    
      <category term="Media" scheme="http://www.helioswei.top/categories/Media/"/>
    
      <category term="video" scheme="http://www.helioswei.top/categories/Media/video/"/>
    
    
      <category term="ffmpeg" scheme="http://www.helioswei.top/tags/ffmpeg/"/>
    
  </entry>
  
</feed>

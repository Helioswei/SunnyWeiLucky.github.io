<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>AI-PaddleHub的体验使用</title>
    <url>/article/1959613013.html</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">
  <script id="hbeData" type="hbeData" data-hmacdigest="8521b7cbfc6ac040635f9a48dc1ac7925f28db77691d8b73fa1bb2f8c2cd55d9">4630436162ade97ba2718b7d0c4b3b63c7da53b2e21fbc742f4fcb8fd6f69935ce67815935b6f57a5b73addf9c977ccc0ea54af4dea5aa99daa2f80d61ca5fbac32625c835b1966fd872844401f18de6514b9581035e21af340f202ba6c0ff5f33825547078782189f6725a7a78cea80e919aab557e14006c86da505dd41b715b2fb028f618c8e1c2ba2482c71ff5b9db37c53e812d2e9631f20b1742e7f5c23187209e65dabf44a3e6056664b5597d7e1bff7385c58a577d0bdeda6d0dae9097ab61a278687581156d107efe5e349a2439e6dd131f771b7fc8cb850cbdffcd532b2388d80ecc765770869e67d1399ea5b51cb2ccf120cd90b783952e1cc8c567aa17ac3bfa002e2aef69fdfbe5dcfa7626ed4f2c22c5c06e211f3a85a046d5974a79db953724dd59937e49358192364197c139db1647cff3243f021b41d217fa261d68c7845e52f12afc5dd335126aeb6187ace9f0006d4f99327a08bce41202843d5a55d1182f4f2f30cd37d40a7e49776bcbb6c97a0b89a4054c5b0380c3e2f62b5a110095070c113a2997fc4dcfe8ec881a2034bc55931598dbfcd82cdddc76137a10450e8acb3e659b127a561a28f6eabfecc9db9a1e06806b80894a5d375e845b8f90d363904f1d3e575fcf69aa5972e5048d6bf719c02e19de31c3f9e9887e8681ea5ea35927d3d076d846d359a8fd799d92375841ec0354b33dfd9f974c56c4f4d2d280d02629672f529139ce4a14716f16c0ca17a6a90ac9c00574a4f776f524845ed5a597974e1b36d6439639eb6d45f0b36c02c7fcf8ecc063b8e8dbe0e967f2c0a54b18ba81d88f2053e363100282af8832f691bf6bbe39904db81a6fb77597d17e0ed18b8d2f2386d62f136ab29f3d838952c1819abd6d1f61206f8cddfcb999103412d81cfdf79a69a2ca14cdc8dd99e0f9704d8218e52d4793f4b5370ec1883433ef1cf17ea5c2e5b50c75a9e18b7f04d87d5db0bddbb63fb8bd6cceeaeccb0eb5af471d7320bfba01c1073ee025a95dfc63519f1e2b067d4fcaa9117fd81ec9205632439f59f12bfb005e2f6c4829d52276e54bb375fc6e7938845c2b10ceb2da4c292961ca15381203df13bbf71a84795725f63622453eb828c38c80ba3ba13b193c0c3f571357f0e75f824035d4ff4f55e0917ac1c7d27eeeb58ec24fd73ed17bb894098caef186ad0fb1b7ffd96a8eda1e86651d5b90c3ff762e022c40fa59ac05b04d3a78c9ef10e03db37b235020fcf328bfe3278a58d3e7efe77fe889e67d24673ced44cd0144415f61e30a9ce709620d8940735ea94737f4e7d19e79f7e454480575341598adb6b7870a7080d6a7e29d20978705b770d0de4a86d91c5b0bb2177b9e5c04719dab406dc5060b8ef273faf267ca1d50bf6453817d4b5222c7f9f74367a5c16fbd0ee68520782a2034abe08b53f99d9676aa6ff568adc2dc43fdae0bd7b199a7911e91097c12b301d453b44f2ba04716bcc7656716524f59f55dda20d00cb640e70cd56df01cb095de528ce12f82303bbea95a916abe412bb442bdda06d3787ee20747ae9ee56f15e28f80150cfdc9058fc630d3648a7982f189f84559914b177b658d0dbe015eaf4e950d83071039c0bbfa60009f5029c1b65e33576a7f840fd6c3cc9f1e2ad62e90882226121335440ce774b4eaa235fa4f29b4fa92d5efb7ee39e2518127556cdd8330e074238463f039c051ca76b509a96e8147f54be39abe7fd65616a006fe7904cf651bfbd9f46bc37851c8b28ae035be98c8f9e8aad8363183d7a08ba2d9111c83dee75479e39a85827a764bc5e20afca905dbc9ce78f83e30f3bb5e8a3e80fc62bfa85b70b07d8e74eb40de1512d4211c8e9d4652ab2f19ce36c588529cf24561bef374409122c21678aefa62d5382481287efeee2254f12b83671d01431d951e108222c710ae350f6ed3c56616889c0f2d9b2a9f6c256b2e0e68e951b6ad563588b4ab772d466d5b5951bce0417d6340375af1bf32d436ac2cb592fd3f39f039f0c12b1e21f56ece4ac4023eb29854d33aa7fdb21b18122a1f0e6d29b9edaa6e14c7cf8f4e4ea28f897bf514856ff362b9acd13685ec6ba5f2f9346f2b418a522bf6628e17490d51cc3d9dfa1d64f4cf55def96d02bab41c08977db2f34891a4a0c9afb61a969c6b21b20f48127b49e5d04cff37d9b4988c43cb7b772d82a66c9d34eaf0848883b14302474236bea52913cd7fcc098bc31f54bb7a5c808a5ab6d0f3a7b051ab069bb02454c91689b5f23a7e9310c082d2baf73f3b63e8ff05dfc78a2c580035ac84e02e104ade534788c2b3add093276b39b72e0ff8ca11b041d993f28e8ad0e9dc747637d076faf5d7823d04e4d7eee8deace20cb08559928de8c0d52bfc2225d7e6c9fd94b24be8f669517e20cb322b338c840800c7d88e4378aa9289c748dba20950f891fca2e0015dd28bc65e7085ba0988c6cc4fc0b6ba42b198bc6dac0b750c5204f8996a58f311502792faf78962f534d2ec4357ecfe4ef35f5d71a6493f355e481030e8f1fe0f0d0cab4e62b68b19efb4ce66236e676330df2173064eb6de6afb4a14a32431f52bb3d7ab2b0b1f6c9712f4de985cdfc5fbb854573593fd4298554d0adf561308e6696082ea1d570df158865cf9bb296e8f4d9e65995bdeeb857a528ac46faca50f57d1a5e0eb3c15fbba58d8b90497e59292406c2e5680fc496e1c83c6dff10355b9bc366ceca1a5ca26370ce8e32329b724d8955802051e6fe92687fc17d9b9d6c7debf30ac634725b90bf855641d7dc478010a96c979fb863c4194b04b86a5065f5a89dff1236cda4d1b4eef6e769e422d16bfdc00cf1e8807aa698b3eb5a0b69b901c8dcf95799894d95258f57f773fcb7bfa819a1d36d1fb925424a45e4a8b2797e889e2c7b6717f325e57b853f3ed47a5d7089463d4da20c84e1a04ea4616026e20fdb79fb0fac30e51371b98cf4bfbc7954d46a699e57440f2340ea5099a1b6c73929343f8aa6bb7ce9e04c8166058b15b1ae8e58c1ac765df0493f475a0f85c9a90e3a4726954264a3837dcc3733230f103156d707ae9e1b63991ba1142aca734bd0441c6f139f854a0ae334ad4fbfd96348595bbc52137edf3a7c7ec5107b0068e95bb798b79e11c59257235b61bc680da4e3cee23941d235ba7780b4fc5a97565806669b941d7d4233332fac0aa9ddc293d225e59500b57f0450cb3cb2ac694a320d77301f6491c1a63e1212ebfd2aecc609d17ebfedf5684afcaae05c67a90af374f66c1e45c3f71b584545c3cf704800263fbf70beffff9a4e63524b085d019d372a42c20f88de2a5cca79c95dfdc9e53d99ea2749d3e4e1d7ee03c692b5fadd181cac827a9d32cb5439dbb8eade7fdfb64bde8696da9f76c82e7c8c620692bb129629080eb7ab75fad8187c34731ab7c02b53ad0e20797079790dc1c478cff75727c3cbe5a6c370fea816510ed8e9aa8c6da924cef9a3738f71b093c35b10077c22373f1ef2ac5dbe3544c2aad47ef8aa1b412190c032f8819b852b0543837a7ade257875925086a4c3f888d9d9347835c85ea575d6aa28f9aa0c7f6689e5982d6e6f9156f2bca4b75d210479baa18161264fc1638fb49f63e149ddf20d04c24c316872003653abeff7ee861e0a5e8e904805bbde50ebb490992f86d6347f3079debea364c27299bd992cce8c29838ef21467893ab9629597fce2138cd70dd059f523ff6b1ecee18f0bbd0cae503497140e8089a85f2d1e5a458bd121f37b1008f24d07a6b0c1a5f3a0ad7e73ccc181610b37b974b29cfd6ec14141c18350315161e8235b03996fa380ec762e2362b30b3671984eefd3ab415fb1b4ed0bb7add866f84e24d59ad5af5acd6df512fb7a434cf57d506b9e830a84be609193ebd187320e95753d2fa3716d8507efacf35ba6e1a4e8a38a3bc8894d89a7ae0d75efc33c910e0397c48dc3bc3254e7c55231899ac6078f31aa454021934510d9041695cb27a5f2e2979f8ce4be4e6142f17362de95e7aae7e1d2e45a9cacc65ff93559a6821a90430b7bfa12c3b6d97c524202687da70391f57a1632dcc35a4f6bc6fe27851224f6c352d57c11f10e8fef125f57844ae078e81d94761e1d503522c2e1143392731548fb156dedff0e9d29393dc1e81d642011d142fbf2cf088d4464cfe75f12bf371a98c5e09c60ff69e7698a61aa2913114495653729985b8d47e835693f74340547e7180b523a37737bacf766a27ef97ef7fc9674574c71904d8d9ccab6d6d96c813dc247eeba25c68976a4f7914a0da1a7e597e566f85d477288144308d1f47ca04705b5bbc6153e5b780d76ac6b1fe5b0c575787e44acb270bd3889fb89e57defc3b480b5debaa79b1a5a08a581c5640d98504806a387fc0e4da8d85cbbaa5f02d5673cf5fe488cbef94b85f4639119f51e68a5e17ecc938dc47a674d99efa637c1b778a29b672305265ffe2b83edbee849f930f28a6fc7608f6c17985ee860ae6cae8e52291d0d42580f9445fe0b11b1e38316b452af1a15d7f05f758737d286dc6a3db87e0c95bd61393345b79fb39c950a6e98cce14d3038f882d356c95279723abd61245a826ede7952c1d87504f7e5e09d2ec797715413f7ab33af9c0ee3e3247535c50b9570353b1d3744f7d50efd4589d4d07a356e4e6b8996c990afd18ec24adce1151d0b0b50dcd6a24cc3fea32f251296012d114c85e81fbd8b0719658e4e1be481107347bd57d41be414009a4f9cd06aadd382b6c3201e355525a7f1a05162a7ad258b112064539e76be46c2422b4c5e913d17be40e68eab18512ebb9f2cee5d4bc5f1b69934320ead2d2c4500585fcf4e5440d524434881d14e1ce752e6d76f6d968c82e732ee0a1e08ae70b969e2e57712a4dd2286b3062fe388185f1fad56a64c95fdb29f051a159b4d4efda788c719cacad3367ab3205180a9c256117fa62e0c5512fccadf6a8b9406e20cbe88b2ffaf3fab0bbc2bc064b34298d52d17a631a141124142e22ac5d39d6fa0a592747b1e5dd1e17c5b93c53e9c8a02b094a74cb8ce67773b4b2113b73fbe6b26b76d21c5ab882f90ce54da7d34d1aeba160736941dbfba101b162809dee2f5d9ae1c63f93681b7e667a830acd7fcc87a1bb2ce6e7d6f91d6e19a7d0e78f5cec87681ed1079f4e0b3e81f2902e4f2558ec6d24dfe8700d8bb46f113dfcb75ac1d6783590f183b121d1e692a3d37285e9f2a29fc66ab7a72168afcf7dd0b1f64b8ba27c57fd1281fbf0ed91fb46cbf4acb62ea4e17aeec090bf1ca99afd7499276be140e4fbd427b59c741b8aac7f121c2055c88001ef539cb59bd1d4618bb3432814c48e2ead882817a0c115dfa87f45edc75643c5df7bedb22753733a464c863af82a2fa7b67f7a9d0d52ff8d2c67a7c22166701ef07e918cb49ccf25c934dc26c87d0605f219b957f57300fe6e48abf9c96a8d3eaacba4fb9a38f4855bbb2bc25587b18bace8356734e4a5a67120c9db0188f44085c9efe8170b7a51826c573fe07d610280ecec9d7df13fff1877ade62cdc08fdc99d3b1982854c39368084d54be2b919839656a9a6767d13ef7f209b16e433b098e48b467f69f978f9326f906b38ca06cc410ad36daee9fda5b3d015ba2699d781b1aecc611c795bd1f70d17294fd915195de6aa24986d056e1d2259b8da11c7801bbe34293b8515ba4f4ba312b0811c183681028086a20b06c07b3f1cfd31bd377b5fda2734b1f5f2b75c933d9c7b8534ffda6f2066ed63e174142ea67b5e24767728d82d6b99cc58b84255f912044fc0f9507ec5133614ba4b80b57eb939d68dd6cd82d9147cdf4004f694ece907d96f3549ad513cf932acc2756a52ff262e7b76e56d41f0a12a677331c35eb1848e9424947f19d56d1b561eb555fb8ab1898b7481865e7b56829fcef63291f2d4190a062356486e892ad61da2e437386000ce1bb1f7ced68510adae3c322f1027fbe4994f51378312fcbf5c9c63680ac38ae9c0041d42a78103257ce66806d6d370599d791505425b23686b7d6fd9e0390c328ba43e3b6acaf67a1b80b756a454d</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-flip">
      <input class="hbe hbe-input-field hbe-input-field-flip" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-flip" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-flip" data-content="您好, 这里需要密码。">您好, 这里需要密码。</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>AI</category>
        <category>PaddleHub</category>
      </categories>
      <tags>
        <tag>PaddleHub</tag>
      </tags>
  </entry>
  <entry>
    <title>centos7-163yum源下载</title>
    <url>/article/2361785990.html</url>
    <content><![CDATA[<p>我们在centos7上下载东西的时候，有时候自带的源里面没有我们需要的软件，所有我们需要更换源来进行下载</p>
<h3 id="一，下载repo文件"><a href="#一，下载repo文件" class="headerlink" title="一，下载repo文件"></a>一，下载repo文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget http:&#x2F;&#x2F;mirrors.163.com&#x2F;.help&#x2F;CentOS7-Base-163.repo</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -o CentOS7-Base-163.repo http:&#x2F;&#x2F;mirrors.163.com&#x2F;.help&#x2F;CentOS7-Base-163.repo</span><br></pre></td></tr></table></figure>
<h3 id="二，备份并且替代系统的repo文件"><a href="#二，备份并且替代系统的repo文件" class="headerlink" title="二，备份并且替代系统的repo文件"></a>二，备份并且替代系统的repo文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp  CentOS7-Base-163.repo  &#x2F;etc&#x2F;yum.repos.d&#x2F; </span><br><span class="line"></span><br><span class="line">cd &#x2F;etc&#x2F;yum.repos.d&#x2F; </span><br><span class="line"></span><br><span class="line">mv CentOS-Base.repo CentOS-Base.repo.bak </span><br><span class="line"></span><br><span class="line">mv CentOS7-Base-163.repo CentOS-Base.repo</span><br></pre></td></tr></table></figure>
<h3 id="三，执行yum源更新命令"><a href="#三，执行yum源更新命令" class="headerlink" title="三，执行yum源更新命令"></a>三，执行yum源更新命令</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum clean all </span><br><span class="line"></span><br><span class="line">yum makecache </span><br><span class="line"></span><br><span class="line">yum update</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
        <category>centos7</category>
      </categories>
      <tags>
        <tag>yum</tag>
      </tags>
  </entry>
  <entry>
    <title>centos7-epel源下载</title>
    <url>/article/3859923575.html</url>
    <content><![CDATA[<h3 id="一，什么是epel"><a href="#一，什么是epel" class="headerlink" title="一，什么是epel"></a>一，什么是epel</h3><p><strong>EPEL的全称叫 Extra Packages for Enterprise Linux</strong> 。EPEL是由 Fedora 社区打造，为 RHEL 及衍生发行版如 CentOS、Scientific Linux 等提供高质量软件包的项目。装上了 EPEL之后，就相当于添加了一个第三方源。</p>
<p>如果你知道rpmfusion.org的话，拿 rpmfusion 做比较还是很恰当的，rpmfusion 主要为桌面发行版提供大量rpm包，而<strong><em>EPEL则为服务器版本提供大量的rpm包，而且大多数rpm包在官方 repository 中是找不到的\</em></strong></p>
<p>另外一个特点是<strong>绝大多数rpm包要比官方repository 的rpm包版本要来得新</strong>。所以，我们有时候在yum下载的时候如果没有找到某个包或者版本过低，可以使用这个方式来尝试。</p>
<h3 id="二，yum下载"><a href="#二，yum下载" class="headerlink" title="二，yum下载"></a>二，yum下载</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install -y epel-release</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
        <category>centos7</category>
      </categories>
      <tags>
        <tag>yum</tag>
      </tags>
  </entry>
  <entry>
    <title>centos7-libreoffice安装和启动</title>
    <url>/article/3025513893.html</url>
    <content><![CDATA[<p>​    centos7下的文档转码的利器<code>libreoffice</code>，下面介绍一下centos7平台上对于这个软件的安装</p>
<h3 id="libreoffice下载"><a href="#libreoffice下载" class="headerlink" title="libreoffice下载"></a>libreoffice下载</h3><p><a href="https://www.libreoffice.org/download/download/">libreoffice下载</a>，在这里可以下载LO的最新的版本</p>
<p>这个是网上找的镜像，<a href="http://mirrors.ustc.edu.cn/tdf/libreoffice/stable/">可以参考</a></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">LibreOffice_6.4.3_Linux_x86-64_rpm_langpack_zh-CN.tar</span><br><span class="line">LibreOffice_6.4.3_Linux_x86-64_rpm.tar.gz</span><br><span class="line">LibreOffice_6.4.3_Linux_x86-64_rpm_sdk.tar.gz</span><br></pre></td></tr></table></figure>
<h4 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -zxvf LibreOffice_6.4.3_Linux_x86-64_rpm_langpack_zh-CN.tar -C /root/libreoffice</span><br><span class="line">tar -zxvf LibreOffice_6.4.3_Linux_x86-64_rpm.tar.gz -C /root/libreoffice</span><br><span class="line">tar -zxvf LibreOffice_6.4.3_Linux_x86-64_rpm_sdk.tar.gz -C /root/libreoffice</span><br></pre></td></tr></table></figure>
<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>进入每个目录下的RPMS目录下使用以下命令执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum localinstall *.rpm</span><br></pre></td></tr></table></figure>
<h4 id="安装依赖包"><a href="#安装依赖包" class="headerlink" title="安装依赖包"></a>安装依赖包</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install cairo</span><br><span class="line">yum install cups-libs</span><br><span class="line">yum install libSM</span><br></pre></td></tr></table></figure>
<h4 id="汉化"><a href="#汉化" class="headerlink" title="汉化"></a>汉化</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum groupinstall &quot;fonts&quot;</span><br></pre></td></tr></table></figure>
<h4 id="example"><a href="#example" class="headerlink" title="example"></a>example</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">libreoffice6.4 --headless --invisible --convert-to pdf test.docx --outdir /data/file</span><br></pre></td></tr></table></figure>
<h3 id="bug提交"><a href="#bug提交" class="headerlink" title="bug提交"></a>bug提交</h3><p>在使用的过程中，我发现了一个bug，影响了我产品的功能，所有让社区的管理帮忙提交了bug修复，<a href="https://bbs.libreofficechina.org/thread-2616-1-1.html">见下</a></p>
]]></content>
      <categories>
        <category>Media</category>
        <category>doc</category>
      </categories>
      <tags>
        <tag>libreoffice</tag>
      </tags>
  </entry>
  <entry>
    <title>centos7-openoffice安装和启动</title>
    <url>/article/1736132591.html</url>
    <content><![CDATA[<p>  本文介绍了openoffice在Centos7下的安装和启动以及使用的方法，供大家学习和参考。</p>
<h3 id="openoffice包的下载"><a href="#openoffice包的下载" class="headerlink" title="openoffice包的下载"></a>openoffice包的下载</h3><p><a href="http://www.openoffice.org/download/">openoffice下载</a></p>
<p><img src="/images/openoffice/openoffice.png" alt="open"></p>
<h4 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -zxvf Apache_OpenOffice_4.1.8_Linux_x86-64_install-rpm_zh-CN.tar.gz</span><br></pre></td></tr></table></figure>
<h4 id="进入解压目录"><a href="#进入解压目录" class="headerlink" title="进入解压目录"></a>进入解压目录</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd zh-CN/RPMS</span><br></pre></td></tr></table></figure>
<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum localinstall *.rpm</span><br></pre></td></tr></table></figure>
<p><code>装完后会在当前目录下生成一个desktop-integration目录</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd zh-CN&#x2F;RPMS&#x2F;desktop-integration&#x2F;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpm -ivh openoffice4.1.5-redhat-menus-4.1.5-9789.noarch.rpm</span><br></pre></td></tr></table></figure>
<h4 id="下载依赖包"><a href="#下载依赖包" class="headerlink" title="下载依赖包"></a>下载依赖包</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install libXext.x86_64</span><br></pre></td></tr></table></figure>
<h4 id="下载java环境"><a href="#下载java环境" class="headerlink" title="下载java环境"></a>下载java环境</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install jre java-devel</span><br></pre></td></tr></table></figure>
<h4 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">/opt/openoffice4/program/soffice -headless -accept=<span class="string">&quot;socket,host=127.0.0.1,port=8100;urp;&quot;</span> -nofirststartwizard</span><br></pre></td></tr></table></figure>
<h3 id="JODConverter下载"><a href="#JODConverter下载" class="headerlink" title="JODConverter下载"></a>JODConverter下载</h3><p><a href="https://sourceforge.net/projects/jodconverter/">jodConverter下载</a></p>
<h4 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">unzip jodconverter-2.2.2.zip</span><br></pre></td></tr></table></figure>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p><code>必须先启动openoffice的服务，然后再使用这个命令行</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">java -jar jodconverter-2.2.2/lib/jodconverter-cli-2.2.2.jar  inputfileName outputfileName</span><br></pre></td></tr></table></figure>
<h4 id="example"><a href="#example" class="headerlink" title="example"></a>example</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">java -jar jodconverter-2.2.2/lib/jodconverter-cli-2.2.2.jar  media/01-自然语言处理-中文分词算法的实现.pptx.pptx  media/o1.pdf</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Media</category>
        <category>doc</category>
      </categories>
      <tags>
        <tag>openoffice</tag>
      </tags>
  </entry>
  <entry>
    <title>centos7-yum的使用</title>
    <url>/article/1714992348.html</url>
    <content><![CDATA[<p>记录yum的使用</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><h4 id="搜索指定的版本安装"><a href="#搜索指定的版本安装" class="headerlink" title="搜索指定的版本安装"></a>搜索指定的版本安装</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">yum list --showduplicates xxx</span><br></pre></td></tr></table></figure>
<h4 id="下载软件包"><a href="#下载软件包" class="headerlink" title="下载软件包"></a>下载软件包</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install yum-plugin-downloadonly</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install fontconfig --downloadonly --downloaddir&#x3D;&#x2F;root&#x2F;wei&#x2F;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
        <category>centos7</category>
      </categories>
      <tags>
        <tag>yum</tag>
      </tags>
  </entry>
  <entry>
    <title>centos7-zsh的使用和配置</title>
    <url>/article/192192511.html</url>
    <content><![CDATA[<p>​     本文主要是记录centos7搭建自己个性的命令行。</p>
<h3 id="安装zsh"><a href="#安装zsh" class="headerlink" title="安装zsh"></a>安装zsh</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">yum install zsh</span><br></pre></td></tr></table></figure>
<h4 id="将其设置为默认shell"><a href="#将其设置为默认shell" class="headerlink" title="将其设置为默认shell"></a>将其设置为默认shell</h4><p>~~~`<br>chsh -s /bin/zsh<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#96;可以通过echo $SHELL来查看当前默认的shell，如果没有改为&#x2F;bin&#x2F;zsh,那么需要重新启动shell&#96;</span><br><span class="line"></span><br><span class="line">### 安装oh-my-zsh</span><br><span class="line"></span><br><span class="line">[地址](https:&#x2F;&#x2F;github.com&#x2F;ohmyzsh&#x2F;ohmyzsh)</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>    sh -c “$(wget -O- <a href="https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot;">https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot;</a><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#### 配置文件</span><br><span class="line"></span><br><span class="line">​	默认的配置文件是在&#96;&#x2F;root&#x2F;.zshrc&#96;，可以通过配置文件来配置一下插件以及功能</span><br><span class="line"></span><br><span class="line">##### 主题修改</span><br><span class="line"></span><br><span class="line">在&#96;.zshrc&#96;中找到&#96;ZSH_THEME&#96;，即可修改主题，[主题地址](https:&#x2F;&#x2F;github.com&#x2F;ohmyzsh&#x2F;ohmyzsh&#x2F;wiki&#x2F;themes)可自己修改</span><br><span class="line"></span><br><span class="line">##### zsh扩展</span><br><span class="line"></span><br><span class="line">​	在&#96;&#x2F;root&#x2F;.zshrc&#96;中找到&#96;plugins&#96;关键字，就可以自定义启用的插件了，目前插件存放在workspace上</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>centos7</category>
      </categories>
      <tags>
        <tag>zsh</tag>
      </tags>
  </entry>
  <entry>
    <title>centos7-常用的命令</title>
    <url>/article/2689943165.html</url>
    <content><![CDATA[<p>记录一下自己常用的centos7上的命令行</p>
<h3 id="mount挂载"><a href="#mount挂载" class="headerlink" title="mount挂载"></a>mount挂载</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">虚拟机和主机共享目录</span><br><span class="line">mount -t cifs &#x2F;&#x2F;192.168.30.97&#x2F;code &#x2F;mnt -o username&#x3D;Administrator,password&#x3D;Helios</span><br><span class="line"></span><br><span class="line">&#x2F;code 是主机上的目录，需要设置为共享的</span><br><span class="line">username 为主机的用户名</span><br><span class="line">password 是主机的密码</span><br><span class="line">&#x2F;mnt 是虚拟机上的目录</span><br><span class="line"></span><br><span class="line">卸载：</span><br><span class="line">umount &#x2F;mnt</span><br><span class="line">卸载失败可以重启服务器</span><br></pre></td></tr></table></figure>
<h3 id="nohup常驻服务"><a href="#nohup常驻服务" class="headerlink" title="nohup常驻服务"></a>nohup常驻服务</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">linux平台上，要在后台运行脚本的话，一般是在命令之后加上&amp;即可。</span><br><span class="line">常驻服务的运行，退出终端也可以的命令行</span><br><span class="line">nohup</span><br><span class="line">具体方法</span><br><span class="line">nohup .&#x2F;videotool &amp;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="查看系统的状态的命令"><a href="#查看系统的状态的命令" class="headerlink" title="查看系统的状态的命令"></a>查看系统的状态的命令</h3><h5 id="查看内存"><a href="#查看内存" class="headerlink" title="查看内存"></a>查看内存</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">free -h</span><br></pre></td></tr></table></figure>
<h5 id="查看磁盘使用"><a href="#查看磁盘使用" class="headerlink" title="查看磁盘使用"></a>查看磁盘使用</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df -h </span><br></pre></td></tr></table></figure>
<h5 id="查看文件大小"><a href="#查看文件大小" class="headerlink" title="查看文件大小"></a>查看文件大小</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">du -sh 11.mkv</span><br></pre></td></tr></table></figure>
<h5 id="查看进程的线程数"><a href="#查看进程的线程数" class="headerlink" title="查看进程的线程数"></a>查看进程的线程数</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ps -T -p pid</span><br></pre></td></tr></table></figure>
<h5 id="查看centos7的物理核数"><a href="#查看centos7的物理核数" class="headerlink" title="查看centos7的物理核数"></a>查看centos7的物理核数</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &#x2F;proc&#x2F;cpuinfo| grep &quot;physical id&quot;| sort| uniq| wc -l</span><br></pre></td></tr></table></figure>
<h5 id="查看centos7的逻辑核数"><a href="#查看centos7的逻辑核数" class="headerlink" title="查看centos7的逻辑核数"></a>查看centos7的逻辑核数</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &#x2F;proc&#x2F;cpuinfo| grep &quot;processor&quot;| wc -l</span><br></pre></td></tr></table></figure>
<h5 id="测试系统的io速度"><a href="#测试系统的io速度" class="headerlink" title="测试系统的io速度"></a>测试系统的io速度</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">time dd bs&#x3D;4M count&#x3D;1024 if&#x3D;&#x2F;dev&#x2F;zero of&#x3D;test_02 conv&#x3D;fdatasync</span><br></pre></td></tr></table></figure>
<h3 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp  -rfd   .&#x2F;oldname  .&#x2F;newname</span><br><span class="line">-r 复制目录</span><br><span class="line">-f 强制复制</span><br><span class="line">-d 复制软连接</span><br><span class="line"></span><br><span class="line">忽略冲突复制</span><br><span class="line">\cp  -rfd   .&#x2F;oldname  .&#x2F;newname </span><br></pre></td></tr></table></figure>
<h3 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">基本格式：</span><br><span class="line">* * * * * command  </span><br><span class="line">含义：</span><br><span class="line">分 时 天 月 周  </span><br><span class="line">使用*&#x2F;n 表示此字段上每隔n执行一次，同时注意如果低时间使用了，会覆盖高时间的*&#x2F;n,不要同时使用某一天与一周的某一天，如果这个两个相等，则会执行两次</span><br></pre></td></tr></table></figure>
<h5 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">crontab -e</span><br></pre></td></tr></table></figure>
<h5 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">crontab -l</span><br></pre></td></tr></table></figure>
<h5 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">crontab -r  这个表示删除所有的定时任务，如果需要删除单个，则使用crontab -e 进行编辑，然后删除某一行</span><br></pre></td></tr></table></figure>
<h3 id="获取服务运行时使用的内存"><a href="#获取服务运行时使用的内存" class="headerlink" title="获取服务运行时使用的内存"></a>获取服务运行时使用的内存</h3><p><img src="/images/linux/cache.png" alt="cache.png"></p>
<h3 id="控制进程使用cpu数目"><a href="#控制进程使用cpu数目" class="headerlink" title="控制进程使用cpu数目"></a>控制进程使用cpu数目</h3><h5 id="获取进程id"><a href="#获取进程id" class="headerlink" title="获取进程id"></a>获取进程id</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pgrep  -f   servername</span><br><span class="line"></span><br><span class="line">pidof   servername</span><br></pre></td></tr></table></figure>
<h5 id="设置CPU使用"><a href="#设置CPU使用" class="headerlink" title="设置CPU使用"></a>设置CPU使用</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">注意： 默认情况下，taskset不会影响进程的所有线程（LWP）。使用任务集的“-a”选项来影响流程中的所有线程</span><br><span class="line"></span><br><span class="line">一般可以这样设置：   taskset   -apc  0   8991     (这个目前最有效）</span><br></pre></td></tr></table></figure>
<h3 id="脚本中生成随机数"><a href="#脚本中生成随机数" class="headerlink" title="脚本中生成随机数"></a>脚本中生成随机数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UUID&#x3D;&#96;echo $RANDOM&#96;</span><br></pre></td></tr></table></figure>
<h3 id="记录程序运行的资源到文件中"><a href="#记录程序运行的资源到文件中" class="headerlink" title="记录程序运行的资源到文件中"></a>记录程序运行的资源到文件中</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install -y time</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;usr&#x2F;bin&#x2F;time -v -o video.log ffmpeg -i xxx.mp4</span><br></pre></td></tr></table></figure>
<h3 id="查看机器是物理机还是虚拟机"><a href="#查看机器是物理机还是虚拟机" class="headerlink" title="查看机器是物理机还是虚拟机"></a>查看机器是物理机还是虚拟机</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dmidecode -s system-product-name</span><br></pre></td></tr></table></figure>
<p>结果如图：</p>
<p><img src="/images/linux/syss.png" alt="syss.png"></p>
<p><img src="/images/linux/sysv.png" alt="sysv.png"></p>
<h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><h5 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h5><p>搜索文件中包含某个单词</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grep -rn  weiyang *</span><br></pre></td></tr></table></figure>
<h5 id="过滤本身"><a href="#过滤本身" class="headerlink" title="过滤本身"></a>过滤本身</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ps -ef | grep vim |grep -v grep</span><br></pre></td></tr></table></figure>
<h3 id="编码问题"><a href="#编码问题" class="headerlink" title="编码问题"></a>编码问题</h3><p>centos7常常会遇到一些编码问题，我们可以通过命令行来进行一些编码的转码</p>
<h5 id="enca"><a href="#enca" class="headerlink" title="enca"></a><a href="https://www.2cto.com/os/201404/295528.html">enca</a></h5><p>支持的编码比较少，一些无法转换，如UTF16,UCS-2就无法通过这个转换</p>
<p>直接识别字符集</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">enca -L zh_CN test.cpp</span><br></pre></td></tr></table></figure>
<p> 转换命令简单</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">enca -L zh_CN -x UTF-8 test.cpp or enca -L zh_CN -x GB2312 test.cpp</span><br></pre></td></tr></table></figure>
<h5 id="iconv"><a href="#iconv" class="headerlink" title="iconv"></a>iconv</h5><p>可以支持多种编码，有一个缺点，必须知道原来文件的编码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iconv  -f UTF-16 -t UTF-8 b.txt -o uni3.txt</span><br></pre></td></tr></table></figure>
<h5 id="任意转换"><a href="#任意转换" class="headerlink" title="任意转换"></a>任意转换</h5><p>所有可以通过enca和iconv两者结合来使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iconv -f $(enca -L zh_CN b.txt |head -n 1|cut -d &quot;;&quot; -f 2) -t UTF-8 b.txt -o b.txt</span><br></pre></td></tr></table></figure>
<p>leopard修改<code>/opt/dana/leopard/python/fileConv.py</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">codecmd&#x3D; &#39;iconv -f $(enca -L zh_CN %s |head -n 1|cut -d &quot;;&quot; -f 2) -t UTF-8 %s -o %s&#39;% (input_name, input_name, input_name)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
        <category>centos7</category>
      </categories>
      <tags>
        <tag>cmd</tag>
      </tags>
  </entry>
  <entry>
    <title>centos7-网络设置</title>
    <url>/article/3594159119.html</url>
    <content><![CDATA[<p>配置centos7的网络，让其可以正常的连接网络</p>
<h3 id="一，打开网络配置所在的文件"><a href="#一，打开网络配置所在的文件" class="headerlink" title="一，打开网络配置所在的文件"></a>一，打开网络配置所在的文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts</span><br><span class="line">vi ifcfg-ens160 (不同的系统，文件名不同)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TYPE&#x3D;Ethernet</span><br><span class="line">PROXY_METHOD&#x3D;none</span><br><span class="line">BROWSER_ONLY&#x3D;no</span><br><span class="line">#设置静态ip还是动态IP</span><br><span class="line">BOOTPROTO&#x3D;static</span><br><span class="line">DEFROUTE&#x3D;yes</span><br><span class="line">IPV4_FAILURE_FATAL&#x3D;no</span><br><span class="line">IPV6INIT&#x3D;yes</span><br><span class="line">IPV6_AUTOCONF&#x3D;yes</span><br><span class="line">IPV6_DEFROUTE&#x3D;yes</span><br><span class="line">IPV6_FAILURE_FATAL&#x3D;no</span><br><span class="line">IPV6_ADDR_GEN_MODE&#x3D;stable-privacy</span><br><span class="line">NAME&#x3D;ens160</span><br><span class="line">UUID&#x3D;750fb5d2-4bff-437d-ab4e-75eaf038429d</span><br><span class="line">DEVICE&#x3D;ens160</span><br><span class="line">#开机自启动</span><br><span class="line">ONBOOT&#x3D;yes</span><br><span class="line">#静态ip地址</span><br><span class="line">IPADDR&#x3D;192.168.50.72</span><br><span class="line">#静态网关</span><br><span class="line">NETMASK&#x3D;255.255.255.0</span><br><span class="line">#路由</span><br><span class="line">GATEWAY&#x3D;192.168.50.1</span><br></pre></td></tr></table></figure>
<p>设置好之后，重启网络服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl restart network</span><br></pre></td></tr></table></figure>
<h3 id="二，配置域名解析"><a href="#二，配置域名解析" class="headerlink" title="二，配置域名解析"></a>二，配置域名解析</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi &#x2F;etc&#x2F;resolv.conf</span><br></pre></td></tr></table></figure>
<p>添加内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nameserver   8.8.8.8</span><br><span class="line"></span><br><span class="line">nameserver   8.8.4.4</span><br><span class="line"></span><br><span class="line">nameserver    114.114.114.114</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
        <category>centos7</category>
      </categories>
      <tags>
        <tag>network</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp-centos7常用环境变量的设置</title>
    <url>/article/1768093973.html</url>
    <content><![CDATA[<p>我们在centos7开发的cpp的时候，在编译的时候需要设置一些常有的环境变量，如头文件的路径，动态库的路径</p>
<h3 id="设置c语言的头文件的搜索路径"><a href="#设置c语言的头文件的搜索路径" class="headerlink" title="设置c语言的头文件的搜索路径"></a>设置c语言的头文件的搜索路径</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export C_INCLUDE_PATH &#x3D;</span><br></pre></td></tr></table></figure>
<h3 id="设置c语言的链接库的搜索路径"><a href="#设置c语言的链接库的搜索路径" class="headerlink" title="设置c语言的链接库的搜索路径"></a>设置c语言的链接库的搜索路径</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export LIBRARY_PATH &#x3D; </span><br></pre></td></tr></table></figure>
<h3 id="设置cpp的头文件的搜索路径"><a href="#设置cpp的头文件的搜索路径" class="headerlink" title="设置cpp的头文件的搜索路径"></a>设置cpp的头文件的搜索路径</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export CPLUS_INCLUDE_PATH &#x3D; </span><br></pre></td></tr></table></figure>
<h3 id="设置cpp的链接库的搜索路径"><a href="#设置cpp的链接库的搜索路径" class="headerlink" title="设置cpp的链接库的搜索路径"></a>设置cpp的链接库的搜索路径</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export LD_LIBRARY_PATH &#x3D; </span><br></pre></td></tr></table></figure>
<h3 id="对于GCC版本的选择"><a href="#对于GCC版本的选择" class="headerlink" title="对于GCC版本的选择"></a>对于GCC版本的选择</h3><p>我们在用cmake编译源码的时候，有时候需要gcc不同的版本，以支持c++11的特性</p>
<p><code>gcc4.8.5以下不支持`</code>gcc5.1.0支持c++11`,我们在编译的时候可以显示的设置编译器的选择,下面是我自己编译的gcc5.1.0版本，这样在编译的时候就会调用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export CC&#x3D;&#x2F;usr&#x2F;local&#x2F;bin&#x2F;gcc</span><br><span class="line">export CXX&#x3D;&#x2F;usr&#x2F;local&#x2F;bin&#x2F;g++</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Cpp</category>
        <category>gcc</category>
      </categories>
      <tags>
        <tag>env</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp-devtoolset切换gcc的版本</title>
    <url>/article/2538200340.html</url>
    <content><![CDATA[<p>我们在编译cpp的时候，有时候需要支持c++11/14的一些特性，就需要升级gcc的版本，为了简单的升级，Red Hat提供了scl软件集来为用户提供一种以方便、安全地安装和使用应用程序和运行时环境的多个（而且可能是更新的）版本的方式，同时避免把系统搞乱。下载devtoolset</p>
<p>使用scl升级gcc的步骤</p>
<h3 id="一，安装scl源"><a href="#一，安装scl源" class="headerlink" title="一，安装scl源"></a>一，安装scl源</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install centos-release-scl scl-utils-build</span><br></pre></td></tr></table></figure>
<h3 id="二，列出scl有哪些可用的源"><a href="#二，列出scl有哪些可用的源" class="headerlink" title="二，列出scl有哪些可用的源"></a>二，列出scl有哪些可用的源</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum list all --enablerepo&#x3D;&#39;centos-sclo-rh&#39; | grep devtoolset</span><br></pre></td></tr></table></figure>
<h3 id="三，安装gcc，g"><a href="#三，安装gcc，g" class="headerlink" title="三，安装gcc，g++"></a>三，安装gcc，g++</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install devtoolset-7-gcc devtoolset-7-gcc-c++</span><br></pre></td></tr></table></figure>
<h3 id="四，切换版本"><a href="#四，切换版本" class="headerlink" title="四，切换版本"></a>四，切换版本</h3><p>这个版本的切换仅对当前的环境有用</p>
<h5 id="启动环境"><a href="#启动环境" class="headerlink" title="启动环境"></a>启动环境</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scl enable devtoolset-7 bash</span><br><span class="line">gcc -v</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="退出环境"><a href="#退出环境" class="headerlink" title="退出环境"></a>退出环境</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">exit</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Cpp</category>
        <category>gcc</category>
      </categories>
      <tags>
        <tag>gcc</tag>
        <tag>devtoolset</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp-gtest集成Lcov代码覆盖率测试</title>
    <url>/article/3264464113.html</url>
    <content><![CDATA[<p>​    做好了单元测试但是别人并不知道我们的单元测试做的如何，是否覆盖了所有的需要被测试的类方法或者变量等，所以我们需要对单测case做一个覆盖率统计。其实本质就是看代码执行时候运行了你需要测试文件里面的所有代码，比如switch分支 if分支等。</p>
<h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><h4 id="安装下载lcov"><a href="#安装下载lcov" class="headerlink" title="安装下载lcov"></a>安装下载lcov</h4><pre><code>http://ltp.sourceforge.net/coverage/lcov.php，有rpm包和源码包。（以源码包为例）
</code></pre><p>解压lcov-x.xx.tar.gz，进入源码包，执行make install<br>在命令行执行lcov -v，正确输出版本号即安装成功</p>
<h4 id="增加Lcov编译选项"><a href="#增加Lcov编译选项" class="headerlink" title="增加Lcov编译选项"></a>增加Lcov编译选项</h4><p>​    在项目顶层目录CmakeLists.txt中添加以下编译指令：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coverage option</span></span><br><span class="line"><span class="keyword">OPTION</span> (ENABLE_COVERAGE <span class="string">&quot;Use gcov&quot;</span> <span class="keyword">ON</span>)</span><br><span class="line"><span class="keyword">MESSAGE</span>(STATUS ENABLE_COVERAGE=<span class="variable">$&#123;ENABLE_COVERAGE&#125;</span>)</span><br><span class="line"><span class="keyword">IF</span>(ENABLE_COVERAGE)</span><br><span class="line">    <span class="keyword">SET</span>(CMAKE_CXX_FLAGS <span class="string">&quot;$&#123;CMAKE_CXX_FLAGS&#125; -fprofile-arcs -ftest-coverage&quot;</span>)</span><br><span class="line">    <span class="keyword">SET</span>(CMAKE_C_FLAGS <span class="string">&quot;$&#123;CMAKE_C_FLAGS&#125; -fprofile-arcs -ftest-coverage&quot;</span>)</span><br><span class="line">    <span class="keyword">SET</span>(CMAKE_EXE_LINKER_FLAGS <span class="string">&quot;$&#123;CMAKE_EXE_LINKER_FLAGS&#125; -fprofile-arcs -ftest-coverage&quot;</span>)</span><br><span class="line"><span class="keyword">ENDIF</span>()</span><br></pre></td></tr></table></figure>
<h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><ol>
<li><p>将cmake编译选项设置为-DENABLE_COVERAGE=OFF …，或者将顶层目录CmakeLists.txt中OPTION (ENABLE_COVERAGE “Use gcov” OFF)编译选项手动设置为ON；</p>
</li>
<li><p>编译产生<code>.gcno</code>文件，运行则产生<code>.gcda</code>（与.gcno对应）文件；</p>
<ul>
<li>我们使用的是<code>cmake编译</code>，则编译后生成的.gcno文件存在build目录下的每个项目中，例如：<img src="/images/cpp/gcno.png" alt="gcno" style="zoom:75%;" /></li>
<li><code>运行</code>我们的测试代码才会产生.gcda文件，如图是运行后产生的。<ul>
<li>若用户进程<code>并非调用 exit 正常退出</code>，覆盖率统计数据就无法输出，也就无从生成报告了。后台服务程序若非专门设计，一旦启动就很少主动退出，用 kill 杀死进程强制退出时就不会调用 exit，因此没有覆盖率统计结果产生。所以必须当前进程退出后才会产生.gcda文件。</li>
</ul>
</li>
</ul>
</li>
<li><p>使用Lcov生成覆盖率统计文件；</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lcov -d cmake-build-debug -t test -o test.info -b . -c  --no-external</span><br></pre></td></tr></table></figure>
<p>命令参数含义解释如下：</p>
<ul>
<li>-d src_dir： 待覆盖率测试的源码目录，本工程设置为cmake-build-debug；</li>
<li>-t ‘test’: 目标的名称，此处为test；</li>
<li>-o ‘test.info’: 生成的覆盖率文件，可自定义，可不带引号；</li>
<li>-b .：相对目录的起始位置；</li>
<li>-c: capture，采集覆盖率；</li>
</ul>
<p>因为我们是cmake进行编译的，所以我们可以直接在build目录下使用lcov命令生成覆盖率报表</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lcov -c -o result.info  -b . -d . </span><br></pre></td></tr></table></figure>
</li>
<li><p>使用genhtml生成覆盖率报表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">genhtml -o report test.info</span><br></pre></td></tr></table></figure>
<ul>
<li><p>-o result: 输出的目标文件夹，可带路径，此处为当前目录下的result目录；</p>
</li>
<li><p>test.info: 覆盖率的统计文件；</p>
</li>
</ul>
<p>如果我们需要对覆盖率报表进行过滤，比如把include文件或者系统的文件给过滤掉，可以使用下面的命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lcov --remove result.info  &#x27;/usr/*&#x27; &#x27;*/inc/*&#x27; -o finalresult.info</span><br><span class="line">genhtml finalresult.info  -o cppreport</span><br></pre></td></tr></table></figure>
</li>
<li><p>html报表生成如下，这个是未过滤的。<img src="/images/cpp/html.png" alt="html.png"></p>
</li>
</ol>
<p>相关文章参考：</p>
<ul>
<li><a href="https://blog.csdn.net/weixin_43892514/article/details/107822769">这篇文章</a>对lcov讲解的比较详细以及cmake添加的选项比较好用，但是对生成的.gcno和.gcda文件在哪里没有说明，对于我这个初学者来说比较的蒙。</li>
<li><a href="https://www.cnblogs.com/zhaoxd07/p/5608177.html">这篇文章</a>对文件生成的位置有详细的说明。</li>
</ul>
]]></content>
      <categories>
        <category>Cpp</category>
        <category>unitTest</category>
      </categories>
      <tags>
        <tag>gtest</tag>
        <tag>lcov</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp-pistache源码编译之实现cpp restful接口</title>
    <url>/article/2728951675.html</url>
    <content><![CDATA[<p>cpp实现restful类型的接口比较的复杂，我们使用pistache库来解决这个问题，经对比，这个库是速度最快的。</p>
<h3 id="源码下载"><a href="#源码下载" class="headerlink" title="源码下载"></a>源码下载</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;oktal&#x2F;pistache.git</span><br></pre></td></tr></table></figure>
<h3 id="第三方库更新"><a href="#第三方库更新" class="headerlink" title="第三方库更新"></a>第三方库更新</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git submodule update --init</span><br></pre></td></tr></table></figure>
<h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><h5 id="依赖下载gcc升级"><a href="#依赖下载gcc升级" class="headerlink" title="依赖下载gcc升级"></a>依赖下载gcc升级</h5><p><a href="http://www.helioswei.top/article/2230395924.html">gcc5.1.0源码编译</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc version &gt;5.1.0 #我们需要支持c++14</span><br></pre></td></tr></table></figure>
<p>我们虽然重新编译安装了gcc，但系统有多个gcc的环境，我们在使用的时候可能还是默认的调用gcc4.8的低级版本，为了解决这个问题，我们可以显示的设置调用，我们需要设置编译器的环境变量，将5.1.0的编译器命令行设置到环境变量中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export CC&#x3D;&#x2F;usr&#x2F;local&#x2F;bin&#x2F;gcc</span><br><span class="line">export CXX&#x3D;&#x2F;usr&#x2F;local&#x2F;bin&#x2F;g++</span><br></pre></td></tr></table></figure>
<h5 id="cmake升级"><a href="#cmake升级" class="headerlink" title="cmake升级"></a>cmake升级</h5><p><a href="https://cmake.org/download/">cmake下载</a>，选择最新的下载即可，然后执行安装三部曲</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cmake version &gt; 3.18.0</span><br></pre></td></tr></table></figure>
<h5 id="curl-devel下载"><a href="#curl-devel下载" class="headerlink" title="curl-devel下载"></a>curl-devel下载</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install curl-devel -y</span><br></pre></td></tr></table></figure>
<h5 id="编译-1"><a href="#编译-1" class="headerlink" title="编译"></a>编译</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd pistache</span><br><span class="line">mkdir build</span><br><span class="line">cd build</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cmake -G &quot;Unix Makefiles&quot; -DCMAKE_BUILD_TYPE&#x3D;Release -DPISTACHE_BUILD_EXAMPLES&#x3D;true -DPISTACHE_BUILD_TESTS&#x3D;true -DPISTACHE_BUILD_DOCS&#x3D;false -DPISTACHE_USE_SSL&#x3D;true -DCMAKE_INSTALL_PREFIX&#x3D;&#x2F;usr&#x2F;local&#x2F;pistache ..</span><br><span class="line">make -j 4</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p><code>注意，这个在使用的时候需要选择c++的标准,设置</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">g++ -std&#x3D;c++14 #一般常用的是c++11</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Cpp</category>
        <category>restful</category>
      </categories>
      <tags>
        <tag>pistache</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp-包管理工具vcpkg使用</title>
    <url>/article/2441447756.html</url>
    <content><![CDATA[<p>​    体验一下cpp的包管理工具vcpkg的使用，<a href="https://github.com/microsoft/vcpkg/blob/master/README_zh_CN.md">git地址</a>。vcpkg是Microsoft的跨平台开源软件包的管理器，极大的简化了在不同平台上第三方库的安装。如果项目要使用第三方库，建议通过 vcpkg 来安装它们。vcpkg 同时支持开源和专有库。微软对其的介绍可以查看<a href="https://docs.microsoft.com/zh-cn/cpp/build/vcpkg?view=msvc-160&amp;viewFallbackFrom=vs-2019">地址</a>。我们在做cpp的开发时，经常会使用到第三方的库，在编译这些时我们要做哪些考虑呢?比如：Debug还是Release、动态库还是静态库、MD还是MT、32位还是64位。光是这三种组合就有16种可能性。如果像libcurl这种还要考虑是否引用其他开源库的功能，那么编译类型的组合会更多。管理起来很麻烦。由于多样的编译类型，工程目录也必须仔细设定才能保证自己的软件项目能够正常编译。</p>
<p>​    使用vcpkg的优点：</p>
<ul>
<li>自动下载开源库源代码</li>
<li>源码包的缓存管理和版本管理，可以升级版本</li>
<li>轻松编译</li>
<li>依赖关系检查（比如编译libcurl，会自动下载zlib、openssl进行编译）</li>
<li>无缝集成Visual Studio，不需要设置库文件、头文件的所在目录，自动集成。</li>
<li>Visual Studio全平台支持，不仅支持Debug/Release、x86/x64编译，还支持UWP、ARM平台的编译。</li>
</ul>
<h3 id="Ubuntu下部署"><a href="#Ubuntu下部署" class="headerlink" title="Ubuntu下部署"></a>Ubuntu下部署</h3><h4 id="依赖软件"><a href="#依赖软件" class="headerlink" title="依赖软件"></a>依赖软件</h4><ul>
<li>git</li>
<li>g++ &gt;=6</li>
</ul>
<h4 id="依赖工具"><a href="#依赖工具" class="headerlink" title="依赖工具"></a>依赖工具</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install build-essential tar curl zip unzip</span><br></pre></td></tr></table></figure>
<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>​    安装过程可以参考<a href="https://docs.microsoft.com/zh-cn/cpp/build/install-vcpkg?view=msvc-160&amp;tabs=linux">地址</a>。如果电脑中没有安装cmake，vcpkg会自动下载portable版本的cmake。但是由于各种原因，下载的网速很慢，所以建议先自行下载安装msi版本的cmake。最好是下载最新版本的cmake。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/microsoft/vcpkg</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;vcpkg&#x2F;bootstrap-vcpkg.sh</span><br></pre></td></tr></table></figure>
<p>安装成功后会在当前vcpkg的目录下产生一个vcpkg的命令行的工具。</p>
<h5 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h5><p>所有 vcpkg 功能和数据都自包含在实例的单独目录层次结构中。 没有注册表设置或环境变量。 可以在一台计算机上设置任意数量的 vcpkg 实例，它们彼此互不干扰。</p>
<p>vcpkg 实例的内容如下：</p>
<ul>
<li><code>buildtrees</code> - 包含从中生成每个库的源的子文件夹。</li>
<li><code>docs</code> - 文档和示例。</li>
<li><code>downloads</code> - 所有已下载的工具或源的缓存副本。 运行安装命令时，vcpkg 会首先搜索此处。</li>
<li><code>installed</code> - 包含每个已安装库的标头和二进制文件。 与 Visual Studio 集成时，实质上是相当于告知它将此文件夹添加到其搜索路径。</li>
<li><code>packages</code> - 在不同的安装之间用于暂存的内部文件夹。</li>
<li><code>ports</code> - 用于描述每个库的目录、版本和下载位置的文件。 如有需要，可添加自己的端口。</li>
<li><code>scripts</code> - 由 vcpkg 使用的脚本（CMake、PowerShell）。</li>
<li><code>toolsrc</code> - vcpkg 和相关组件的 C++ 源代码。</li>
<li><code>triplets</code> - 包含每个受支持目标平台（如 x86-windows 或 x64-uwp）的设置。</li>
</ul>
<h4 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h4><p>​    vcpkg 包管理器在 GitHub 上定期更新。 若要将 vcpkg 的克隆更新到最新版本，请从 vcpkg 根目录运行 <code>git pull</code>。 此命令会将 vcpkg 的副本与 GitHub 上的版本同步。 下载完成后，再次运行引导程序。 引导程序会重新生成 vcpkg 程序，但保留已安装的库。</p>
<h4 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h4><p>​    若要卸载 vcpkg，只需删除 <code>vcpkg</code> 目录。 删除此目录会卸载 vcpkg 分发以及 vcpkg 已安装的所有库。</p>
<p>但是，如果已执行 <code>vcpkg integrate install</code>，则应执行 <code>vcpkg integrate remove</code> 来确保在删除文件夹之前已清理集成 。 有关详细信息，请参阅<a href="https://docs.microsoft.com/zh-cn/cpp/build/integrate-vcpkg?view=msvc-160">集成 vcpkg</a>。这个是Windows下集成到IDE使用的，在Linux下开发的不用关心。</p>
<h3 id="命令行使用"><a href="#命令行使用" class="headerlink" title="命令行使用"></a>命令行使用</h3><p>​    记录一下常用的命令行。具体的命令行的使用可以参考<a href="https://docs.microsoft.com/zh-cn/cpp/build/vcpkg-command-line-reference?view=msvc-160">地址</a></p>
<h4 id="search"><a href="#search" class="headerlink" title="search"></a>search</h4><p>​    您也可以使用 <code>search</code> 子命令来查找vcpkg中已集成的库。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./vcpkg/vcpkg search [search term]</span><br></pre></td></tr></table></figure>
<p>​    您也可以查看具体的某个包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./vcpkg/vcpkg search uuid</span><br></pre></td></tr></table></figure>
<h4 id="install"><a href="#install" class="headerlink" title="install"></a>install</h4><p>​    使用以下命令安装任意包。linux下默认编译生成的是静态库。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;vcpkg&#x2F;vcpkg install [packages to install]</span><br></pre></td></tr></table></figure>
<h5 id="指定编译某种架构的程序库"><a href="#指定编译某种架构的程序库" class="headerlink" title="指定编译某种架构的程序库"></a>指定编译某种架构的程序库</h5><p>​    如果不指定安装的架构，vcpkg默认把开源库编译成x86的Windows版本的库。那vcpkg总共支持多少种架构呢？我们可以使用如下命令便知：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;vcpkg&#x2F;vcpkg help triplet</span><br></pre></td></tr></table></figure>
<p>​    vcpkg不仅支持x86架构，还支持arm架构。注意：这里的arm架构特指类似于surface这种运行在arm处理器上的Win10平台，而并非我们传统意义上的Linux或android的ARM平台。那如果要安装编译某一个架构的开源库，我们该怎么写呢？我们只需要在需要安装的包后面指定相应的triplet即可。例如我们需要编译64位版本的jsoncpp，那么执行如下命令即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;vcpkg&#x2F;vcpkg  install jsoncpp:x64-linux</span><br></pre></td></tr></table></figure>
<p>​    例如安装uuid,先用<code>search</code>命令查找具体的包的名字，然后在使用<code>install</code>进行安装。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./vcpkg/vcpkg search uuid</span><br><span class="line">./vcpkg/vcpkg install libuuid</span><br></pre></td></tr></table></figure>
<h5 id="动态库编译"><a href="#动态库编译" class="headerlink" title="动态库编译"></a>动态库编译</h5><p>​    Linux平台默认编译的是静态库，如果要编译动态库则可以参照<a href="https://github.com/microsoft/vcpkg/blob/master/docs/examples/overlay-triplets-linux-dynamic.md">这篇文章</a></p>
<h4 id="list"><a href="#list" class="headerlink" title="list"></a>list</h4><p>​    查看已经安装的开源库。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./vcpkg/vcpkg list</span><br></pre></td></tr></table></figure>
<h4 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h4><p>​    移除一个已经安装的库。 如果有其他库依赖它，系统会提示你使用 <code>--recurse</code> 重新运行命令；重新运行会导致下游的所有库都被删除。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./vcpkg/vcpkg remove libuuid</span><br></pre></td></tr></table></figure>
<h4 id="upgrade"><a href="#upgrade" class="headerlink" title="upgrade"></a>upgrade</h4><p>​    公共目录始终与最新版本的库保持一致。 要判断哪个本地库已过期，请使用 <code>vcpkg update</code>。 准备好将端口集合更新到最新版本的公共目录后，请运行 <code>vcpkg upgrade</code> 命令。 它会自动下载并重新生成已过期的任意或所有已安装的库。</p>
<p>默认情况下，<code>vcpkg upgrade</code> 命令仅列出过期库，不对它们进行升级。 若要真正升级这些库，请使用 <code>--no-dry-run</code> 选项。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vcpkg upgrade --no-dry-run</span><br></pre></td></tr></table></figure>
<p>升级选项：</p>
<ul>
<li><code>--no-dry-run</code>：执行升级；若未指定，该命令将仅列出过期的包。</li>
<li><code>--keep-going</code>：继续安装包（即使某项失败）。</li>
<li><code>--triplet &lt;t&gt;</code>：为非限定的包设置默认的三元组。</li>
<li><code>--vcpkg-root &lt;path&gt;</code>：指定要使用的 vcpkg 目录，而不是使用当前目录或工具目录。</li>
</ul>
<h4 id="export"><a href="#export" class="headerlink" title="export"></a>export</h4><p>​    导出一个安装好的包。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;vcpkg&#x2F;vcpkg export jsoncpp --zip</span><br></pre></td></tr></table></figure>
<p>注意，导出时必须指定导出的包格式。vcpkg支持5种导出包格式，有：</p>
<table>
<thead>
<tr>
<th style="text-align:left">参数</th>
<th style="text-align:left">格式</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">–raw</td>
<td style="text-align:left">以不打包的目录格式导出</td>
</tr>
<tr>
<td style="text-align:left">–nuget</td>
<td style="text-align:left">以nuget包形式导出</td>
</tr>
<tr>
<td style="text-align:left">–ifw</td>
<td style="text-align:left">我也不知道这是啥格式</td>
</tr>
<tr>
<td style="text-align:left">–zip</td>
<td style="text-align:left">以zip压缩包形式导出</td>
</tr>
<tr>
<td style="text-align:left">–7zip</td>
<td style="text-align:left">以7z压缩包形式导出</td>
</tr>
</tbody>
</table>
<p>​    如果要指定输出目录和特定文件名，需使用”–output=”参数</p>
<h4 id="import"><a href="#import" class="headerlink" title="import"></a>import</h4><p>​    导入一个包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;vcpkg&#x2F;vcpkg import xxx.zip</span><br></pre></td></tr></table></figure>
<h4 id="cmake"><a href="#cmake" class="headerlink" title="cmake"></a>cmake</h4><p>​    和cmake配合使用可以通过下面的命令。这个是需要在命令行中输入。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-DCMAKE_TOOLCHAIN_FILE&#x3D;&quot;&#x2F;home&#x2F;helios&#x2F;work&#x2F;source&#x2F;vcpkg&#x2F;scripts&#x2F;buildsystems&#x2F;vcpkg.cmake&quot;</span><br></pre></td></tr></table></figure>
<p>​    另一种方法是直接在项目顶层的CMakeLists.txt中设置变量，必须在project参数设置之前设置下面的参数。在需要使用的地方通过find_package既可以。</p>
<ul>
<li>CMAKE_TOOLCHAIN_FILE  你的vcpkg.cmake的路径;</li>
<li>VCPKG_TARGET_TRIPLET  你的平台架构名字，通过<code>./vcpkg/vcpkg help tripl</code> 来查看</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">set(CMAKE_TOOLCHAIN_FILE /home/helios/work/source/vcpkg/scripts/buildsystems/vcpkg.cmake CACHE PATH &quot;&quot;)</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="built_in">set</span>(VCPKG_TARGET_TRIPLET x64-linux CACHE PATH <span class="string">&quot;&quot;</span>)</span></span><br></pre></td></tr></table></figure>
<p>​    对于你安装的软件，执行<code>install</code>之后会告诉你怎么在camke中使用，例如下面的：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">The package sqlite3:x64-linux provides CMake targets:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">find_package</span>(unofficial-sqlite3 CONFIG REQUIRED)</span><br><span class="line">    <span class="keyword">target_link_libraries</span>(main PRIVATE unofficial::sqlite3::sqlite3))</span><br></pre></td></tr></table></figure>
<p>​    最后一种方法，直接在cmake文件中添加其头文件和动态库的地址。</p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>​    官网介绍了一个例子，可以用于学习，<a href="https://github.com/microsoft/vcpkg/blob/master/docs/examples/installing-and-using-packages.md">地址</a>。</p>
]]></content>
      <categories>
        <category>Cpp</category>
        <category>vcpkg</category>
      </categories>
      <tags>
        <tag>vcpkg</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp-学习计划</title>
    <url>/article/3248960382.html</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">
  <script id="hbeData" type="hbeData" data-hmacdigest="0196dd85c43caac64bbfa355b3ca5e3e5665c94318adcf7a800c9b43f13c4a6b">fb9f6fbb8fc1d993240686705025b43532348148d53fb91ba5b377f724fe5b62c8b3848ff11810ef0eef03060f6fa9f6e50d44b812aff7d5fdc4437d49bc3ec3e31345cea2d12cf0e10c9263a9a720edff928b1331435c3804bd25a85f9996d78dbbe9dc1d7b7f8b067c0e6ab72a5244de9bfb995d4843af7c253efaf6e2fec00b653d0a3d104ff27b30871fa5d9d573046181f461ad2df13ae2a784c5beefb1a453a0e4f92a555e1053de39ef1ad8fad0b97503b1b218349f9fbad1388bc847448b3e178d64e5d1272e1f401c1edf874c176a20d808f075129a21b0aad9e0c5053566f26dc591b18fd817f14a3f907f1d35de0afe1f1ebde4dbfc57a6cf7e9d512dea436830ac2bf71fc1345931b2309bc730a8463fab9cdc10dde3ae2f2503c266c6bba6609f08b9245d973d3882cafb7c9f3447a40deddaec734cc607cde984d0098163d6ce69eaa1b3b794082e61455b2bf6f9791d3ae907269f301b98eeaffffc22a4f4213e858894cacce10edde3da2679e75f6ab333a2ce5d686868e18f8cb03814d2479f0e2774efb5530cd77f2d3e8c4ed354e8240481d4477536828e5d6af0b50eb43d8c362395dae9b6efa53ff7d5c71208134ebb53f662635c4435365e35059de2fe2c6aff04d13d64b7a8b2fa751922a8c9872b28efba30596ba9004699cb3dcd4896ba2f234a8a434299ab5d94f38a1bfeb6c861fdcdd70bd84de3aa5eafd0d45145028488924eb8963f37593d7b03cf6516781ec062f0933839c13aa332a5a3abed20e6f9e7b066143f36b909c51b98a637866fc8c63f27e4b0a836a6b8bd6bcf8a20920faa431370ca45d096c4efa237a1ce0d2b2cc70cef5d6672d0fd33f8ab6af34e5b720999286593004dfc75a83a0df6f3e79689d83614c02297619315243468250579241ac8d03ef9320c1173c9eb3727c5a9779f768c7acac2fa606d7009d5ec15b98238bc474fb5e8d96ca52a319f99c739272c909daa79a2ac59ede1fff686176c4ce47ef8db249073cb831fdbc94fd55be03fada6fb13910d71ad18fbed5f86da55552236642859ac12f99e1635a22b4e9a886d55e4d4834511c241fb7f66de318550fcd3dcfb141970e8099d8cacdd43feef3afc171dc1f4650d52966b8cf092c43a37bb5b29c793aaa8cd52cfac690cb4cefb837a9a030505cd5f147cc3abb5d372718f083412da4c91a7c905c9e2b6528bd1bdc597648351606f4e70705a3a34a1fc4b83b609f2d8e7efc299a2cea4df796897048acafe9247e9a32b366af8244bf3cfedef1676044f44d26c823a4fec672faa053f71a5e765ac5dfde7b3616fa20d1b68fbcea0d67bd8bff3548f9ce657cbf79bfcb9272b9213c27e3e1cce80a4c228191ab3eec2b305a504292053d2ee78dc4caf283f5d32a48511ebdaac7a2176736c5b5b53258376fc3acc4138d8c3c5affa138da0a531334c5c53668eeb661d8ff995bb95d46ab48b5c16c89f89682434830801d63b7cfdae2458797ac9455e6021abecc847a17dbec5279ac984e77e90178e45ad1f7dc718d03759f3790c04d63264ff7815b7827d475a8b4cea58f1496ef0e696e487776bea8e6f66627077826229f4ced8d7ac6e5a9a1ae2ef09087cf7082930a040787ec1ddef886de4f884765a767cbc5f11793aae222f1bdcc6e35f67e2303ec93a1c10955dcc7156fe6c8f33b7211e9d90949c2a6c16207e963dd1403631e51d78bed697b6622212222b5c4109fe1c17574ff39ffb83a1d1c40575109615873079a3b95533ebbcbe72219fabf30c055a666eebd0ad025c3d663bca9131a82bf044fc51f9b13b9c0d51d51bdc28afd7476f351f50ecd5fd7cf1a5bf40d1c9d8b5692ac443ee18e1d1c47aa917dfec4e4d09246e1329267c9689577bf566fc6f3c6678bbaf2478adcea5809aa0a187b10dc8ad3a9990ed11a137a943315ff6f2fee9ab0b4d3ba8200e905b8301f5e037f975ec74ff1c7037921ecff9d002f04a8f83de136bf2ae447c1a92ec0d6a748cde1873ccaf3685803bdd1704e36ca7dad35236f4f913be709b6f8d7db12a553cc51c987058dbca05bcc396776d0c7ccf09dde0421f7f5bcccaa72b155060d4fe21d2e69ef492dbcace542be74bb46b328f2b5f017769d70370ae612147433110cb3b92ad72ebcc65c4467f6b04f2356483a9d0315e1186e2b55b9ba7c115c5855110d0eea323935da0316bf635c30f0f6adb6f253636090a0ed43f446d5a36dec9915b76c2d0c67d79a8d10e23a22dfe99b3691f3b056251488e7075994b6e00293f01d9730a3478f91fbe388a4ddfc13ab17017ed0a41eaa371121b20511491082fe2d865ea70fb5c58a231a586facb8c99d0975f0afa7e3fffe76b274e7ee5fcafc01ef9cd5d1779405a2748aebea29238d6de71e7a38202c277ec706d82778f9f0da2121780b6bb799d3ec265d85bab9ab4706b3be28a403010f1075689e414f37c57b5a85625907a857f8935bcdaa65ab14dc7abe6ffcb4e18493f6693cfb3106cc970629643566821b3e591435255238bfdd1c84cf2e24f299d579ab99f252c7d349362905d8daf2c483922ac63d9b40afdbe23908da7a80b4659260af3704addae263d122e368b8322cffb10024efd238af0d7f17b6f96e15c0a6ddf0329930987dcdf5d15c20f338d44a05b42ab1f4a93a6629bbabc3d8869eb1004dd906af2915a3435680e469678367dd441f098c5f2a24481d93bb610eb3c7a3b5bdcf22c0064756af8d9f02749d21e0daca5f6a862081c72b0a10354436f3f37466663f74d68a3a360fcc44f394cb3c728d137e8dee34270770f2beeeff98e7bf2c4848a8e93a57b0a1c14ca52a4679c2960ae0337a57590acb81ad471c333e8ed3f82bbf44b1cd704f5de2ecc676da91b0bac1eb1685124924fb5fe488dda425554b4e8ae4f98d5f9e2c260a47265f4aa37583cb6556ad425ba9dfbbd999f7da19d5e36ebfb8ae64aabb990901affd2667da1080b37746f6c18dffec796c6d65e9e1336c2afe165e716d7310a2ce5a83ffa2f379e7e24090aa70a734d2fae2611f950d9b7b8f3424a5bd0e6f7434ca14fc2bc21b023802b9f4f602919fcc4be0c6c8ea97af2c8afc31c69201cbc67cf306be629c668a097e87e541925cdc09f786cbb5739895732a53229fc5f552c2299cf2fe909b6a8fe9bf67d5d0118a7fc5be5da51eb34a783371b9c572315f5b4c8999efa0b6943808c3b577d4261acd4cfd94ae63ad0c6e403051c53090d19ee9dc1f772ca5b4e04b0f854329a2380c72f5700b6d1ada5d814155279a0e639a715e0564115e7b26a5ffa51ccb00bb868469a7a8ada54fdaa31e77e35830508db80cb678b7ee3711302733291a440e9a798adea55be57f7876c36a7b408e99e7a59abc028570a1660d54410c2db9b99d896bdd27dee3f115179340ae46d69706dda0ba04acb3471719da4e032fa093de6ed0dfbe8a5ec7ed6942cd877dd2a814146e35e800137747fe32745fb4af60a0bd0d48bcbe53eabf67990a5afd1d68f816390705f539975b5ca49a7e880cf02814e9888a8ea91abf01d552174eb02da00fb8054eb7ea81c6b511e0789f44fec714ff2530ecc1a58bb9b27915d49e5756ec529fbc69e0902e88a33575cf5916b9291460f904856f6902cc7744db997812bbe410e3f550b83e0197b2456624a15a483a700ba3c9efc1c4a607c525afd0f9dffda91388d16410c12b4a83f99414970d8c75c53957ab0327acf9fee92909c19df1189e0cba98f35a29120d68a35d8281cd8d343fe6fc65b9a592d8a6115a97f24f58c116c046b362914e108a3301936537783c4b76082523b3124bcd71a36e5467b1549be4324ada8c6e45ac02fd1aaed8f1c12c1e610f3a7047ef8d4e8e2773039b7b4d7085f04439258c2b490f06bde28a038e23aaf85794bc33b574b6d2726d5ac6397ddfce2bcb91abc1fb3ff540e9d188b84f7cb8aa1a68ec5cc75786fc755d62ae600a2f2c1d648be95d9f2de92a9abaac6417662680073eda6e5838fd171d74cff71dd408708de8f07c6b5667d82c8f7efa69d400adabd6de6557c7e44292b1be77dc90d82b059b3ee01c32852759c59ac421075a7df042e1ad1d3706c3cd864a44f68ae2303f39f6abcab5e15b7de13ba3a1f85867739269fabde5ed340feab5dd24f8e7e86cac8f2981709d3a9f0b3372f468bb8f20ecfcdce7ca059a49d8e61dc12103b5003238343740d14ed45b6000361cb0ab277c34bc3cb1be55fd33dda317540b257d1dd2555ae0a56eafa4fc4da7c705667538a65f6e70c56a1fa04be1905305db0949a6a498481f8fd164d66c2676e9963d96f49371f4ba6dce170c32ab806684ae86df9d20baceb6bc4191e980591f833e648cfff2592c9d866bbce92257f69c946c37235d41ff3d073e1be62f0f2a10cae513e1a5f146ee9198ac9524ff5259f76d62ca0bf9d233361cc1ab6682ddc2f5fa38594a536beecd205d4c8b97d48b1186e934e021baa919d7510bdd114e9ba347747747681593369f4007d8d14ac3336e8ee33f93031297cd4e9279422f6cb1578faeb4b6c35088ad1c16eebd34f39145299d76dc960379f49522efeb96b82fae1294ee4c5b7e13cee8bf295fc64cc51418a5c03387f291560a4fd43969ec69acd874de0d770534731c8b2a3066190ad01c8acad0fd8627bedbdd3a0648de6b684911c61a976afb5a774abea8a00b15407dd79353b38789358783e09908b2d39f5fbdfe5aea98fd478bff5f3a8c55197671ae0442478943e9296338f87ca4862baab3dd55a75c4c6717e3a6b610882a979215747d0d9d9f976a99d4dd1c2f9bc68e9cc39b27696a0a6c6e85ec0052f81b7f10573e7a3b21de433da09e85109a040cd00730e3856fa43372c69da1fee87420ea9591632ed654a299d4a172610cd11c653e1c64c80a1eb9bf60972e6633ed51fa287dfd7c892031c3b2d123466f1b6ddc45ab09e518066e19095a1aa2c674f6e8b24dd09ce7514fcdc508681b7ba4e3dfe106229e246986e05044a3c5f03ac785020592640d3eb2e3a639ce79a72b24cef5dc772fa6831549e2b0d54ce36b241291fcc2a0fe77c61d0d0a21a30f6cad8e934c14809e5adeb0d039b84cfc8a919ec276ccf88ac7139fca948a64f9bf5ef709f7fbe1888fbc137c3fe571e54f3c38c4ee3eff155e17d67a3ca4d223ef50bc3eb1be6e278fc2a65e25432cbb66a6d393cded33bcb6f9de277fd9448947c6302535cf9ad4f8d74f53c004e257e7bb7850a0a48d6bf590c0b2872dceab86c393d34d3908c7b594f2d6212035ba7414f9b48a76c8947363fe631c71f5c031ce822c6a5b8dfcb965dbdc659493c01e63ce3eff2802dcc9b282ce8d1b0d282ae982d8c79e5a85d68b0882012aaf849002424f074fe24cd32fbe212c2b31874159332fdb7ea677008229a65f115b727b8a1cb050e71347f874373f11fcaed4b15693f459779ff2d0a2c978ededc1721167369177387c5b0a28e752abd5592d4d26712a1479959c66ee94f3bf1e514d72f3dc36080675bb10b1b1f84abab3146b66df570e5c74c394edd4718d17b083ce13331963f3440718e04dd48a8df0993c862b94df4718a567169fe65d72f25c6eacb64e18e33bb1239876ab4caf11a490c0330630cbb0fba89d2df42e90c1a3d57619d5992203fda3a6be02288e87416a809dbfecb09919b38e34b1574a9ac2ac71951c6bcbd914643722e1a93cadecb067574909cd2a53efdd2d0fce0f134b61e04c9d4a7ecd4fbe8e07afb3faf698deb9eefd701886f3937cc7b6fe756a6ef7621fb9f717363333fa324378d32057f1a624f5abbb2f1b9a440d82bd54bdf9cc7759645f37c3e397ad89fb679659be2318b83183b9a4fd871fe31f56167c9bd8a822f5d57b125c567c911dd5f3be42e6fbf29df8fe10b4deb123b8de5869ab318513280406c393d55878ebc63be0cb1cf1006b2c1d5320058f99b27420265007bfd6b12f0bd17e62de02296f0717b011acda0b6b288b5f78ae9083f0e841e62494a2d4da4cabd3a940ac2f540c032d196af73f6f66dcaf7da93a6da645000c886984058dbc995d64d032482506db36541084a917b876d087b965b33df63f4753e6a7c51786f5a03887bf5f64dd279a05f8393f937d64e8f983810620e799a60579a3b96699321f6379ff99b2610be9f12b9797d64c97aac7057368946a4a913c55ca66b91cbe900021b3c8188ecb1035d87442851fc3910115d5a85bca5b8644172dcf1a821d1e6321d99b95990aa68cf4231f0802082bf1da01e73df4300cbc9c25edbf1fcf5d964613eaba32190534eb109c97d9311664ebc8107162c91cb9638daba325ed12f9d77338de0a390ffe81123fb0c375d298fd4f7aa6dea0d15d4b8ac3b34e5be0c6575c8f9981d5e48e0e5ea71b2e3686327e6574f225f8c1d539b974be6ce935c814208211724e091d89afb76753b1e806fa141aaeeb1b13bee3b61234ae5ffd8d1fd79289a77e73792b3dce48bf2eea554cee68aefedec7e5e14a3cfa2a34f9920a2f9b7f07bc657ed4fe7f5f7336301b479c91581ded39c05526a603fc8790e47842d5ff1643b5e58a2d85b7e1fffac16708db65ce543180729214c460a5e51367cd3eb63945a5372b75c610e7e666d0cabec7ec4bb8ded012e69d5a1a350cc9734562c4aa98780ffd29769915b112d0a5bfb66fef86eb7b8182b21a53005adfe726028d7d62d6bfa53ff59865b9446df6a749636b448dc29b26df9815d2d4a25dd3a7d72af62e9f85e6b5f5ff09b70470e2e6103eb389e100c5bca3c50eed8896a155881547bbb2ca9036946aef902d074710aef7d822562a85264ae6b62a8f6e3de0766c342101875d7e8eaf9604f85bcb1ce9cb88003550479e8c76577b9697f9e0b3eb812b5bb3fa01d31d97eb6911ff604434a467fd4da1159f88cd4b50ee8b5c023cb570c420fc84d0408375db5126aab836fc62b0b8d7679720f8cdae8f63280eddf6ff79d990b0436ba816251a95672b7cb0a94e452ee02a0375ff54e52da1ead5d777b3be44f2188d574fcdab08235fdd5d834b4b4ae3e8a204e3dc0eae47b7134058d73dbe69fb5f67f5a09acaa36bf00e2e488b951ff29f76d7093aadb6b00e6894a89964bec8475a4d0c916a93db57546f36f1e62a99d792f463fc6abf3f6b88d541831e7a6c31491e7660656e8ef36dd83c28c22f1a667848be16d8b01b060310238ad17ff1325f64251742c580b2d9be39c1130b52edc1a47b3e1e5abfa2c3dddfaa6e470da7dc9fd35c83af6d9acf32a9e6beb68c3b7eba1e6614ef79c9797ffbf38dc99f38f8f359b68d917c77d39f62ab4ed91a23966ceaabc69d120dfb718601b000f312ce85faa81b558374555587be820d706f121fb54cbfdd8fbb2d7009ed4d696d4359462b4572bb50cb2b59697ef5e21cd6cb5edd84f9d1c8da62411193217b7ab0d0b0a29a7ec5dd3468d9d6c7516ac5d4315d4c6598fd856038b1db4d7e0b11aca8de88343eeddfe22e482b5589def594f81455c02754b5c06c3687c3852b3a9266f05f756f3d4426795b624235eb8a79d22f581d8283f5a33f55d05f647147f197cc8989920191b8ce944859ad8aed14e2d78ebd7b8d3a7844d1700517fb6d17586b26e9b8cf50c62613a0256944ede978c132930adec7f782ef2bc5707420c662b3362aba3702ead08856fab6055b92283f92ad68246170a773b012067067f17a2b629afcac4b4d4ea9929ef9172aacf690823fd77c77385f2bdeb768f353f295ef8d582e67d825b179a4727187c96e220bd5f23150124e281f4</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-flip">
      <input class="hbe hbe-input-field hbe-input-field-flip" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-flip" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-flip" data-content="您好, 这里需要密码。">您好, 这里需要密码。</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>Cpp</category>
      </categories>
  </entry>
  <entry>
    <title>cpp-日志库LOG的使用</title>
    <url>/article/1373770285.html</url>
    <content><![CDATA[<p>​    在开发的时候，我们经常要写日志，这里提供一个日志库的使用方法；</p>
<p>​    目前我常用的cpp的日志库是这个<a href="https://github.com/amrayn/easyloggingpp">easyloggingcpp</a>，官网有详细的一些说明怎么使用的，我这里记录一些使用中需要注意的地方：</p>
<h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>easyloggingcpp编译的时候比较的简单，直接把easyloggingcpp.h和easyloggingcpp.cpp放到自己的项目中进行编译就好了。</p>
<h3 id="多线程中使用"><a href="#多线程中使用" class="headerlink" title="多线程中使用"></a>多线程中使用</h3><p>在多线程中使用，需要设置几个比较重要的点，不然就会抛出异常的错误，导致程序中断，有以下几点</p>
<ol>
<li><p>在编译的时候需要需要添加参数，<code>-DELPP_THREAD_SAFE</code>用以支持多线程，使用cmake进行编译时，需要在Cmakefile文件中设置如下参数，并且cmake的版本需要在3.0以上</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SET(CMAKE_CXX_FLAGS &quot;-DELPP_THREAD_SAFE&quot;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>在使用的文件中，需要预定义一个变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define ELPP_THREAD_SAFE</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="主进程使用"><a href="#主进程使用" class="headerlink" title="主进程使用"></a>主进程使用</h3><p>我们需要在程序的入口位置设置下面的环境变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INITIALIZE_EASYLOGGINGPP</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Cpp</category>
        <category>log</category>
      </categories>
      <tags>
        <tag>easyloggingcpp</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp-菜鸟回炉-操作系统内存对齐</title>
    <url>/article/734109955.html</url>
    <content><![CDATA[<p> 最为一名程序员，你知道一个基础变量在计算机是怎样存储的吗？你知道一个整数占多大的空间？一个结构体占多大的空间？一个联合体占多个的空间？</p>
<h3 id="对齐"><a href="#对齐" class="headerlink" title="对齐"></a>对齐</h3><p>​    很多计算机系统对基础数据类型的可允许地址做了一个限制，要求某种类型的对象的地址必须是某个值k（通常是2，4，8）的倍数。这种对齐限制简化了处理器和存储器系统之间接口的硬件设计。假如，一个处理器总是从存储器中取8个字节的数据出来，则地址必须为8的倍数。如果我们能保证所有的double都将他们的地址对齐为8的倍数，那么就可以用一个存储器操作来读或者写值了。否则我们可能要执行两次存储器访问，因为对象可能分布在两个8字节存储器中。</p>
<p>​    确保每种数据类型都是按照指定方式来组织和分配的，即每种类型的对象都满足它的对齐限制，就可以保证实施对齐。<code>编译器</code>在汇编代码中放入命令，指明全局数据所需要的对齐。当然我们自己在代码中也可以控制，这个后面在说。</p>
<h3 id="对齐规则"><a href="#对齐规则" class="headerlink" title="对齐规则"></a>对齐规则</h3><p>​    每个特定平台上的编译器都有自己默认的“对齐系数”。可以通过预编译命令<code>#pragma pack(n)</code>, n = 1,2,4,8来改变这一系数。若没有手动指定，那么编译器就会默认将成员变量中最大的类型字节数设置为对齐值：m</p>
<h4 id="有效对齐值"><a href="#有效对齐值" class="headerlink" title="有效对齐值"></a>有效对齐值</h4><p>​    有效对其值：是给定值<code>#pragma pack(n)</code>和结构体中最长数据类型长度中<code>较小</code>的那个。有效对齐值也叫<strong>对齐单位</strong>。</p>
<p>了解了上面的概念后，我们现在可以来看看内存对齐需要遵循的规则：</p>
<p>(1) 结构体第一个成员的<strong>偏移量（offset）</strong>为0，以后每个成员相对于结构体首地址的 offset 都是<strong>该成员大小与有效对齐值中较小那个</strong>(即·<code>对齐单位</code>)的整数倍，如有需要编译器会在成员之间加上填充字节。</p>
<p>(2) <strong>结构体的总大小</strong>为 有效对齐值 的<strong>整数倍</strong>，如有需要编译器会在最末一个成员之后加上填充字节。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>考虑下面的结构体，使用系统默认的设置，分析其内存分布</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ubuntu 64位，sizeof(int) 4字节</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>假设编译器用的是最小的9字节分配，画出来的图是这样的<img src="/images/memory/offset1.png" alt="offset1.png"></p>
<p>它是不可能满足域i（偏移量是0）和j（偏移量是5）的4字节对齐要求的。所有编译器在域c和域j之间插入了一个3字节的空隙（此处用xxx表示）。<img src="/images/memory/offset2.png" alt="offset2.png"></p>
<p>另外编译器可能需要添加一些填充到结构体的末尾，这样结构数组的每个元素都会满足它的对齐要求。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ubuntu 64位，sizeof(int) 4字节</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="/images/memory/offset3.png" alt="offset3.png"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ubuntu64位，sizeof(int) 4字节，sizeof(double) 8字节</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">double</span> d;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">sizeof</span>(A) = <span class="number">24</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">double</span> d;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">sizeof</span>(B) = <span class="number">32</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Cpp</category>
        <category>memory</category>
      </categories>
      <tags>
        <tag>memory</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp-菜鸟回炉-操作系统内存管理</title>
    <url>/article/279221372.html</url>
    <content><![CDATA[<p>   本文介绍操作系统对变量的内存管理相关的内容。要能够更清楚的看懂本章的内容，需要先看一下我上一章程序编译原理中提到的操作系统的抽象相关内容。</p>
<h3 id="信息存储"><a href="#信息存储" class="headerlink" title="信息存储"></a>信息存储</h3><p>​    大多数的计算机使用8位的块，或称为<code>字节</code>（byte），来作为最小的可寻址的存储器单位，而不是访问存储器中单独的位。机器级程序将存储器视为一个非常大的字节数组，成为<code>虚拟存储器</code>。存储器的每个字节都由一个唯一的数字来标识，称为它的<code>地址</code>，所有可能地址的集合就称为<code>虚拟地址空间</code>。正如它的名字表明的，这个虚拟地址空间只是展现给机器级程序的概念性映像。实际的实现是随机访问存储器RAM，磁盘存储，特殊硬件和操作系统软件的结合，来为程序提供一个看上去统一的字节数组。</p>
<h4 id="十六进制表示法"><a href="#十六进制表示法" class="headerlink" title="十六进制表示法"></a>十六进制表示法</h4><p>​    <img src="/images/memory/hex.png" alt="hex.png"></p>
<h4 id="字"><a href="#字" class="headerlink" title="字"></a>字</h4><p>​    每台计算机都有一个字长，指明<code>整数</code>和<code>指针数据</code>的标称大小。因为虚拟地址就是以这样的字来编码的，所以字长决定的最重要的参数是虚拟地址空间的最大大小。也就是说，对于一个字长为n位的机器而言，虚拟地址的范围为0~2^n-1,程序最大访问2^n字节。</p>
<p>​    今天大多数的计算机的字长为64位，这就限制了虚拟地址空间为8千兆（8GB）。</p>
<h4 id="数据大小"><a href="#数据大小" class="headerlink" title="数据大小"></a>数据大小</h4><p>​    <code>计算机</code>和<code>编译器</code>使用不同的方式来编码数字，比如不同长度的整数和浮点数，从而支持多种数字格式。准确的字节数依赖于机器和编译器。我们展示典型的32位机器和64位机器中的基础类型的字节长度。<img src="/images/memory/byte.png" alt="byte.png"></p>
<h4 id="寻址和字节顺序"><a href="#寻址和字节顺序" class="headerlink" title="寻址和字节顺序"></a>寻址和字节顺序</h4><p>​    对于跨越多字节的程序对象，我们必须建立两个规则：</p>
<ul>
<li>这个对象的地址是什么；</li>
<li>我们在存储器中如何对这些字节排序；字节排序有两种形式，分为<code>大端法</code>和<code>小端法</code>：<ul>
<li><strong>小端法</strong>：某些机器选择在存储器中按照从最低有效字节到最高有效字节的顺序存储对象，最低有效字节在最前面的方式被称为小端法，即数据的高字节保存在内存的高地址中，数据的低字节保存在内存的低地址中；<ul>
<li>大多数源自以前的Digital Equipment公司（现在是Compaq公司的一部分）的机器及其Intel的机器都采用这种规则。</li>
</ul>
</li>
<li><strong>大端法</strong>：另外一些机器选择在存储器中按照从最高有效字节到最低有效字节的顺序存储对象，最高有效字节在最前面的方式被称为大端法，即数据的高字节保存在内存的低地址中，数据的低字节保存在内存的高地址中；这个与我们的阅读习惯一致。<ul>
<li>IBM，Motorola,Sun Microsytems的大多数机器都采用这种规则。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>​        在几乎所有的机器中，多字节对象都被存储为连续的字节序列，对象的地址为所使用字节序列中最小的地址。例如，假设一个类型为int的变量x的地址为0x100，也就是说，地址表达式&amp;x的值为0x100。那么x的四个字节将被存储在存储器的0x100,0x101,0x102,0x103位置。</p>
<p>​        对于大多数的程序员来说，他们机器字节的顺序是完成不可见的。无论为哪种类型的机器所编译的程序都可以得到相同的结果。不过有时间，字节顺序会成为问题。</p>
<ul>
<li><p>不同机器之间通过网络传递二进制数据时，当小端法机器产生的数据被发送到大端法的机器上或者反之时，接受程序会发现字里的字节成了反序的。为了避免这种问题，网络应用程序的代码编写必须遵守已经建立的关于字节顺序的规则，以确保发送方机器将其内部表示转换成网络标准，而接收方机器则将网络标准转换成其内部的表示。</p>
</li>
<li><p>判断机器是大端还是小端的方法；</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> a;</span><br><span class="line">        <span class="keyword">char</span> c;</span><br><span class="line">    &#125;Un;<span class="comment">//联合体共用内存</span></span><br><span class="line">    <span class="comment">//假设当前的内存地址为           00 01 02 03</span></span><br><span class="line">    <span class="comment">//int a 4个字节，大端法的内存分布 12 34 56 78;</span></span><br><span class="line">    <span class="comment">//int a 4个字节，小端法的内存分布 78 56 34 12;</span></span><br><span class="line">    Un.a = <span class="number">0x12345678</span>;<span class="comment">//12是数据的高字节哦                                                                                                  </span></span><br><span class="line">    <span class="keyword">if</span> (Un.c == <span class="number">0x12</span>)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;big&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(Un.c == <span class="number">0x78</span>)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;little&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="整数数据类型的存储"><a href="#整数数据类型的存储" class="headerlink" title="整数数据类型的存储"></a>整数数据类型的存储</h3><p>​    计算机编码整数有两种方式：</p>
<ul>
<li>一种只能表示非负数；<ul>
<li>对于这种整数，计算机的存储直接将其转换为对应的二进制，然后直接存储。</li>
</ul>
</li>
<li>另一种可以表示负数，零，正数；<ul>
<li>对于这种整数，计算机通过<code>二进制补码</code>的方式来进行存储，它的定义是将<code>最高有效位</code>解释为<code>负权</code>，也成为<code>符号位</code>。当被设置为<code>1</code>时，表示值为<code>负数</code>；当被设置为<code>0</code>时，值为<code>非负</code>。</li>
<li>原码：就是符号加绝对值</li>
<li>反码：正数的反码就是原码，负数的反码是保持符号位不变，其他位取反；</li>
<li>补码：正数的补码就是原码，负数的补码为反码+1；</li>
</ul>
</li>
</ul>
<p><img src="/images/memory/int.png" alt="int.png"></p>
<h3 id="浮点数数据类型的存储"><a href="#浮点数数据类型的存储" class="headerlink" title="浮点数数据类型的存储"></a>浮点数数据类型的存储</h3><p>​    计算机中的浮点数的存储是按照IEEE（电气电子工程师学会）标准来的 <img src="/images/memory/ieee.png" alt="ieee.png"></p>
<p>​    示例可以<a href="https://blog.csdn.net/xxssyyyyssxx/article/details/51586959">参考文章</a></p>
<h3 id="数组分配和访问"><a href="#数组分配和访问" class="headerlink" title="数组分配和访问"></a>数组分配和访问</h3><p><img src="/images/memory/array.png" alt="array.png"></p>
<h3 id="指针计算"><a href="#指针计算" class="headerlink" title="指针计算"></a>指针计算</h3><p><img src="/images/memory/ptr.png" alt="ptr.png"></p>
<h3 id="虚拟存储器"><a href="#虚拟存储器" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h3><p>​    为了更有效的管理存储器并且少出错，现代操作系统提供了一个对主存的抽象概念，叫做虚拟存储器。虚拟存储器是硬件异常，硬件地址翻译，主存，磁盘文件和内核软件的完美交互，它为进程提供了一个大的，一致的，私有地址空间。通过一个很清晰的机制，虚拟存储器提供了三个重要的能力：</p>
<ul>
<li>它将主存看成是一个存储在磁盘上的地址空间的高速缓存，在主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据，通过这种方式，它高效的使用了主存；</li>
<li>它为每个进程提供了一致的地址空间，从而简化了存储器管理；</li>
<li>它保护了每个进程的地址空间不被其他进程破环。</li>
</ul>
<p>虚拟存储器是计算机系统最重要的概念之一。它成功的一个主要的原因就是因为它是沉默地，自动的工作，不需要应用程序员的任何干涉。既然虚拟存储器在幕后工作的如此之好，为什么程序员还需要理解它呢？有以下几个原因：</p>
<ul>
<li><strong>虚拟存储器是中心的</strong>。虚拟存储器遍及计算机系统的所有层面，在硬件异常，汇编器，链接器，加载器，共享对象，文件和进程的设计中扮演着重要的角色。理解虚拟存储器将帮助你更好的理解系统通常是如何工作的。</li>
<li><strong>虚拟存储器是强大的</strong>。虚拟存储器给予应用程序强大的能力，可以创建和破坏存储器块，将存储器块映射到磁盘文件的某个部分，以及与其他进程共享存储器。比如，你知道你可以通过读写存储器位置读或者修改一个磁盘文件的内容吗？或者你可以加载一个文件的内容到存储器中，不需要进行任何的显示的拷贝吗？理解虚拟存储器将帮助你利用它的强大的能力在你的应用程序中添加动力。</li>
<li><strong>虚拟存储器是危险的</strong>。每个应用程序引用一个变量，间接引用一个指针，或者调用一个诸如malloc这样动态分配包程序时，它就会和虚拟存储器进行交互。如果虚拟存储器使用不当，应用将遇到复杂险恶的与存储器有关的错误。例如一个带有错误指针的程序可以立即崩溃于”<strong>段错误</strong>“或者”<strong>保护错误</strong>“。</li>
</ul>
<p>独立的地址空间允许每个进程为它的存储器映像使用相同的基本格式，而不管代码和数据实际存放在物理存储器的何处。例如每个Linux进程使用如图所示的格式。文本区总是从虚拟地址<strong>0x08048000</strong>处开始的，栈总是从地址<strong>0xbfffffff</strong>向下伸展，共享代码库总是从地址<strong>0x40000000</strong>，而操作系统代码和数据总是从地址<strong>0xc0000000</strong>开始。这样一致性极大的简化了链接器的设计和实现，允许链接器生成全链接的可执行目标文件，这些可执行文件是独立于物理存储器中代码和数据的最终位置。<img src="/images/memory/linuxmemory1.png" alt="linuxmemory1.png"></p>
<h3 id="程序中代码和数据的存储位置"><a href="#程序中代码和数据的存储位置" class="headerlink" title="程序中代码和数据的存储位置"></a>程序中代码和数据的存储位置</h3><p>​    在计算机中每个程序的内存是相互独立的，都是在虚拟存储器中开辟的空间。虚拟地址空间（查看我上一篇文章程序编译原理）有大量准确定义的区，每个区都有专门的功能：<img src="/images/memory/linuxmemory.png" alt="linuxmemory.png"></p>
<ul>
<li><code>栈</code>：位于虚拟地址空间顶部的是用户栈，系统自己分配，存放临时变量包括，局部变量，返回值，参数，返回地址等；</li>
<li><code>堆</code>:  主要用于动态内存的分配，在程序开发中，一般是开发人员进行分配与释放，</li>
<li><code>读/写区域</code>：主要存放全局变量，静态变量;<ul>
<li><code>data</code>：data区里主要存放的是已经初始化的全局变量、静态变量；</li>
<li><code>bss</code>：bss区主要存放的是未初始化的全局变量、静态变量，这些未初始化的数据在程序执行前会自动被系统初始化为0或者NULL；</li>
</ul>
</li>
<li><code>只读区</code>：主要存放const修饰的变量/字符常量，二进制代码。<ul>
<li>init：</li>
<li>text：已经编译的程序的代码；</li>
<li>rodata：只读数据，比如printf语句中的格式串和switch语句的跳转表；</li>
</ul>
</li>
</ul>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>​    全文皆是摘录自<a href="https://gitee.com/helioswei/books">《深入理解计算机系统》</a>一书，用于自己的学习和理解，若存在侵权请联系作者。</p>
]]></content>
      <categories>
        <category>Cpp</category>
        <category>memory</category>
      </categories>
      <tags>
        <tag>memory</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp-菜鸟回炉-程序编译原理</title>
    <url>/article/1580317473.html</url>
    <content><![CDATA[<p>​    菜鸟的自我学习之路。</p>
<p>​    本文介绍程序的编译原理以及运行过程中发生了什么。</p>
<h3 id="程序编译过程"><a href="#程序编译过程" class="headerlink" title="程序编译过程"></a>程序编译过程</h3><p>​    我们的源程序实际上就是一个由0和1组成的位（又成为比特）序列，这些位被组织成8个一组，称为字节，每个字节都表示程序中某个文本字符。大部分的操作系统都使用ASCII标准来表示文本字符，这种方式实际上就是用一个唯一的字节大小的整数值来表示每个字符。</p>
<p>​    为了能够在系统上运行我们的代码，每条ｃ语言都必须被其他程序转换为一系列的<strong>低级机器语言指令</strong>。然后这些指令按照一种称为<strong>可执行目标程序</strong>的格式打包好，并以<strong>二进制磁盘文件</strong>的形式存放起来。目标程序也称为可执行目标文件。在Unix系统上，从源文件到目标文件的转换是由编译器驱动程序完成的，如ｇcc。对于一个简单的程序，如hello.c，</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span>                                                                                                          </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="number">1111</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -o hello hello.c</span><br></pre></td></tr></table></figure>
<p>​    在这里gcc编译驱动程序读取源程序hello.c，并将其翻译成一个可执行目标文件hello。这个编译过程是分四个基本完成的。如图，执行这四个阶段的程序（预处理器，编译器，汇编器，链接器）一起构成了编译系统。<img src="/images/memory/gcc.png" alt="gcc.png"></p>
<ul>
<li><p>预处理阶段：预处理器（cpp）根据以字符#开头的命令，修改原始的c程序。比如hello.c中的第一行的#include&lt;stdio.h&gt;指令告诉预处理器读取系统头文件stdio.h的内容，并把其直接插入到程序文本中去。结果得到另一个c程序，通常是以<code>.i</code>作为文件扩展名。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -E hello.c  -o hello.i</span><br></pre></td></tr></table></figure>
</li>
<li><p>编译阶段：编译器（ccl）将文本文件<code>hello.i</code>翻译成文本文件<code>hello.s</code>,它包含一个<code>汇编语言程序</code>。汇编语言程序中的每条语句都以一种标准的文本格式确切描述了一条低级机器语言指令。汇编程序是非常有用的，因为它为不同高级语言程序中的不同编译器提供了通用的输出语句。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -S hello.i  -o hello.s</span><br></pre></td></tr></table></figure>
</li>
<li><p>汇编阶段：接下来汇编器（as）将<code>hello.s</code>翻译成<code>机器语言指令</code>，把这些指令打包成一种叫做<code>可重定位目标程序格式</code>。并将结果保存在目标文件<code>hello.o</code>中。hello.o文件是一个二进制的文件，它的字节编码是机器语言指令而不是字符，如果我们在文本编译器中打开hello.o文件，呈现的将是一堆乱码。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -c hello.s  -o hello.o</span><br></pre></td></tr></table></figure>
</li>
<li><p>链接阶段：请注意，我们的hello程序调用了printf函数，它是标准c库中的一个函数，每个c编译器都提供。printf函数存在于一个叫printf.o的单独的预编译目标文件中，而这个文件必须以某种方式并入到我们的hello.o程序中。链接器(ld)就是负责这种并入，结果得到一个hello文件，它是一个<code>可执行目标文件</code>(或称可执行文件)。可执行程序加载到存储器后，由系统负责执行。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc hello.o -o hello</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><code>cpp的编译过程同理，只是我们的编译成换成了g++,上面分步编译的命令同样适用</code></p>
<h3 id="理解编译系统如何工作的好处"><a href="#理解编译系统如何工作的好处" class="headerlink" title="理解编译系统如何工作的好处"></a>理解编译系统如何工作的好处</h3><h4 id="优化程序性能"><a href="#优化程序性能" class="headerlink" title="优化程序性能"></a>优化程序性能</h4><p>​    现代编译器都是成熟的工具，通常可以生成很好的代码。作为程序员，我们无需为了写出高效的代码而去了解编译器内部的工作。但是为了在我们的程序里面做出好的代码选择，我们确实需要对汇编语言以及编译器如何将不同的c语句转换为汇编语言有一些基础的了解。比如：一个switch语句是不是总是比一系列的if-else语句高效呢？一个函数的代价有多少？while循环比do循环更有效吗？指针引用比数组引用更有效吗?</p>
<h4 id="理解链接时出现的错误"><a href="#理解链接时出现的错误" class="headerlink" title="理解链接时出现的错误"></a>理解链接时出现的错误</h4><p>​    根据我们的经验，一些令人困扰的程序错误往往都与链接器操作有关，尤其是当你试图建立大型的软件系统时。比如，链接器报告说它无法解析一个引用，这是什么意思？静态变量和全局变量的区别是什么？静态库和动态库的区别是什么？</p>
<h4 id="避免安全漏洞"><a href="#避免安全漏洞" class="headerlink" title="避免安全漏洞"></a>避免安全漏洞</h4><p>​    近年来，缓冲区的溢出错误造成了大多数的网络和Internet服务器上的安全漏洞。这些错误的存在是因为大多数的程序员忽视了编译器用来为函数产生代码的堆栈规则。</p>
<h3 id="程序运行时发生了什么"><a href="#程序运行时发生了什么" class="headerlink" title="程序运行时发生了什么"></a>程序运行时发生了什么</h3><p>​    为了了解运行时hello程序发生了什么，我们需要理解一个典型系统的硬件组织，下图是Inter Pentium系统产品族的模型，<img src="/images/memory/system.png" alt="system.png"></p>
<p><code>CPU:中央处理器；ALU：算术/逻辑单元；PC：程序计数器；USB：通用串行总线</code></p>
<h4 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h4><p>​    贯穿整个系统的是一组电子管道，成为总线，它携带信息字节并负责在各个部件之间传递。通常总线被设计成传送定长的字节快，也就是字(word)。字中的字节数（即字长）是一个基本的系统参数，各个系统中也不尽相同。比如，Inter Pentiu系统的字长是4个字节，而服务器类的系统，比如Inter Itaninums和高端的Sun公司的SPARCS的字长是8个字节.用于汽车和工业中的嵌入式控制器之类较小的系统的字长往往只有一或两个字节.</p>
<h4 id="IO设备"><a href="#IO设备" class="headerlink" title="IO设备"></a>IO设备</h4><p>​    IO设备是系统与外界的联系通道.我们的示例系统包含了四个io设备:作为用户输入的键盘和鼠标,作为用户输出的显示器,以及用于长期存储数据和程序的磁盘驱动器(简单的说就是磁盘).</p>
<p>​    每个IO设备都是通过一个控制器和适配器与IO总线进行连接的.控制器和适配器之间的区别主要在于它们的组成方式.控制器是IO设备本身中或者系统的主印制电路板(通常称为主板)上的芯片组,而适配器则是一块插在主板插槽上的卡.无论无何,它们的功能都是在IO总线和IO设备之间传递信息.</p>
<h4 id="主存"><a href="#主存" class="headerlink" title="主存"></a>主存</h4><p>​    主存是一个临时存储设备,在处理器执行程序时,它被用来存放程序和程序处理的数据.物理上来说，主存是由一组DRAM（动态随机存储器）芯片组成的。逻辑上来说，存储器是由一个<strong>线性的字节数组</strong>组成的，每个字节都有字节唯一的地址（数组索引），这些地址是从0开始的。一般来说，组成程序的每条机器指令都由不定量的字节构成。与C程序变量相对应的数据项的大小是根据类型变化的。比如，运行LInux的Inter机器上，short类型的数据需要2个字节，int,float和long类型需要4个字节，而double类型需要8个字节。</p>
<h4 id="处理器"><a href="#处理器" class="headerlink" title="处理器"></a>处理器</h4><p>​    中央处理单元（CPU）简称处理器，只解释（或执行）存储在主存中指令的引擎。处理器的核心是一个被称为<code>程序计数器</code>（PC）的字长大小的存储设备（或寄存器。在任何时间点上，PC都指向主存中的某条<code>机器语言指令</code>（内含其地址）。</p>
<p>​    从系统通电开始，直到系统断电，处理器一直在不假思索的重复执行相同的基本任务：从程序计数器指向的存储器处读取指令，解释指令中的位，执行指令指示的简单操作，然后更新程序计数器指向下一条指令，而这条指令并不一定在存储器中和刚刚执行的指令相邻。</p>
<p>​    这样简单操作的数目并不多，它们在主存，寄存器文件和<code>算法逻辑单元</code>（ALU）之间循环。寄存器文件是一个小的存储设备，由一些字长大小的寄存器组成，这些寄存器每个都有唯一的名字。ALU计算新的数据和地址值。</p>
<h4 id="程序运行"><a href="#程序运行" class="headerlink" title="程序运行"></a>程序运行</h4><p>​    我们做一个粗略的描述：</p>
<p>​    首先，shell程序执行它的指令，等待我们输入命令。当我们在键盘输入字符串./hello后，shell程序就逐一读取字符到寄存器，再把它存储到存储器中，如下图。<img src="/images/memory/hello1.png" alt="hello1.png"></p>
<p>​    当我们在键盘上敲回车键时，shell就知道我们已经结束了命令的输入。然后shell执行一系列的指令将hello目标文件中的代码和数据从磁盘拷贝到主存中，从而加载hello文件。</p>
<p>​    利用称为DMA（直接存储器存取）的技术，数据可以不通过处理器而直接从磁盘到达主存，如图<img src="/images/memory/hello2.png" alt="hello2.png"></p>
<p>​    一旦hello目标文件中的代码和数据被加载到了存储器，处理器就开始执行hello程序的主程序中的机器指令。这些指令将<code>hello world</code>串中的字节从存储器拷贝到寄存器文件，再从寄存器中文件拷贝到显示设备，最终显示到设备上，如图<img src="/images/memory/hello3.png" alt="hello3.png"></p>
<p>​    通过这个简单的示例我们了解到了重要的一课，那就是系统花费了大量的时间把信息从一个地方挪到另一个地方。hello程序的机器指令最初存放在磁盘上，当程序加载的时候，它们被拷贝到主存。当处理器运行程序时，指令由从存储器拷贝到处理器。从一个程序员的角度来看，大量的拷贝减慢了程序实践的工作。因此，一个系统设计者的一个主要的目标就是使这些拷贝操作尽可能的快。下图是存储器层次模型的示例。<img src="/images/memory/memory.png" alt="memory.png"></p>
<h4 id="操作系统管理硬件"><a href="#操作系统管理硬件" class="headerlink" title="操作系统管理硬件"></a>操作系统管理硬件</h4><p>​    当shell加载和运行hello程序时,当hello程序输出自己的消息时,程序没有直接的访问键盘,显示器,磁盘或者主存储器.取而代之的是它们依靠操作系统提供的服务。我们可以把操作系统看成是应用程序和硬件之间插入的一层软件如下图，所有的应用程序对硬件的操作都必须通过操作系统。<img src="/images/memory/system2.png" alt="system2.png"></p>
<p>​    操作系统的两个基本的功能：</p>
<ul>
<li>防止硬件被失控的应用程序滥用；</li>
<li>在控制复杂而又通常广泛不同的低级硬件设备方面，为应用程序提供简单一致的方法；</li>
</ul>
<p>操作系统通过下面图片显示的几个基本的抽象概念（进程，虚拟存储器，文件）来实现上述的两个功能。</p>
<ul>
<li>文件：对IO设备的抽象表示；<ul>
<li>文件只不过就是字节序列。每个IO设备，包括磁盘，键盘，显示器，甚至是网络，都可以被看成是文件。系统中的所有输入和输出都是通过使用称为Unix IO的一小组系统函数调用读写文件来实现的</li>
</ul>
</li>
<li>虚拟存储器：对主存和磁盘IO设备的抽象表示；<ul>
<li>它为每个进程提供一个假象，好像每个进程都在独占地使用主存。每个进程看到的存储器都是一致的，称为虚拟地址空间，如下图是Linux进程的虚拟地址空间（其他的Unix系统的设计与此类似）。在Linux中，最上面的四分之一的地址空间是预留给操作系统中的代码和数据的，这对所有的进程都一样。底部的四分之三的地址空间用来存放用户进程定义的代码和数据。请注意图中的地址是从下往上增大的<img src="/images/memory/virtualmemory.png" alt="virtualmemory.png">每个进程进程看到的虚拟地址空间由大量准确定义的区（area)构成，每个区都有专门的功能。<ul>
<li>程序代码和数据：代码是从同一固定地址开始的，紧接着的是和C全局变量相对应的数据区。代码和数据区是由可执行目标文件直接初始化的；</li>
<li>堆：代码和数据区后紧随的就是运行时堆。代码和数据区是进程一旦开始运行时就被指定了大小，与次不同，作为调用了向malloc和free这边的c标准库函数的结果，堆可以在运行时动态的扩展和收缩；</li>
<li>共享库：在地址空间的中间附近是一块用来存放像C标准库和数学库这样共享库的代码和数据的区域；</li>
<li>栈：位于用户虚拟地址空间顶部的是用户栈，编译器用它来实现函数的调用。和堆一样，用户栈在程序执行期间可以动态的扩展和收缩。特别的，每次我们调用一个函数时，栈就会增长。每次我们从函数返回时，栈就会收缩；</li>
<li>内核虚拟存储器。内核是操作系统总是驻留在存储器中的部分。地址空间顶部的四分之一的部分是为内核预留的。应用程序不允许读写这块区域的内容或者直接调用内核代码定义的函数。</li>
</ul>
</li>
</ul>
</li>
<li>进程：对处理器，主存，和IO设备的抽象表示；</li>
</ul>
<p><img src="/images/memory/system3.png" alt="system3.png"></p>
<h4 id="Unix和Posix"><a href="#Unix和Posix" class="headerlink" title="Unix和Posix"></a>Unix和Posix</h4><p><img src="/images/memory/posix.png" alt="posix.png"></p>
<h4 id="Linux项目"><a href="#Linux项目" class="headerlink" title="Linux项目"></a>Linux项目</h4><p>​    1991年8月，一个名为Linux Torvalds的芬兰研究生谨慎的发布了一个新的类Unix的操作系统内核。<img src="/images/memory/linux.png" alt="linux.png"></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>​    全文皆是摘录自<a href="https://gitee.com/helioswei/books">《深入理解计算机系统》</a>一书，用于自己的学习和理解，若存在侵权请联系作者。</p>
]]></content>
      <categories>
        <category>Cpp</category>
        <category>memory</category>
      </categories>
      <tags>
        <tag>memory</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp-菜鸟回炉-程序链接详解</title>
    <url>/article/1117780254.html</url>
    <content><![CDATA[<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>链接就是将不同代码和数据收集和组合成为一个单一文件的过程，这个文件可被加载（或被拷贝）到存储器并执行。</p>
<p>链接发生的时机有以下几种：</p>
<ul>
<li>链接可以发生于编译时，也就是在源代码被翻译成机器代码时；</li>
<li>也可以发生与加载时，也就是在程序被加载器加载到存储器并执行时；</li>
<li>甚至执行与运行时，由应用程序来执行；</li>
</ul>
<p>链接通常是由链接器来安静的处理，对于那些在编程入门课堂上构造小程序的学生来说，链接不是一个重要的议题。那为什么还有这么麻烦的学习关于链接的知识呢？</p>
<p>​    链接器的两个主要的任务：</p>
<ul>
<li>符号解析（symbol resolution）：目标文件定义和引用符号。符号解析的作用是将每个符号引用和一个符号定义联系起来；</li>
<li>重定位（relocation）：编译器和汇编器生成从零开始的代码和数据节。链接器通过把每个符号定义与一个存储器位置联系起来，然后修改所有这些对符号的引用，使得他们指向这个存储器的位置，从而重定位这些节。</li>
</ul>
<p>在你阅读的时候，要记住关于链接器的一些基本的事实：目标文件存粹是字节快的集合。这些快中，有些包含程序代码，有效包含程序数据，而其他的则包含指导链接器和加载器的数据结构。链接器将这些库链接起来，确定被链接块的运行时位置，并且修改代码和数据块中的各个位置。链接器对目标机器了解甚少，产生目标文件的编译器和汇编器已经完成了大部分工作。</p>
<h3 id="了解链接的好处"><a href="#了解链接的好处" class="headerlink" title="了解链接的好处"></a>了解链接的好处</h3><ul>
<li>理解链接器将帮助你构造大型程序。构造大型程序的程序员经常会遇到由于缺少模块，缺少库或者不兼容的库版本引起的链接器错误。除非你理解链接器是如何的解析引用，什么是库以及链接器是如何的使用库来解析引用的，否则这些错误将会使用迷惑和挫败；</li>
<li>理解链接器将帮助你避免一些危险的编程错误。Unix链接器解析符号引用时所做的决定可以不动声色的影响你程序的正确性。在默认情况下，错误的定义多个全局变量的程序将通过链接器，而不产生任何警告信息。由此得到的程序会产生迷惑的运行时行为，而且非常难以调试。</li>
<li>理解链接将帮助你理解语言的作用域规则是如何实现的。例如全局和局部变量的区别是什么？当你定义一个具有静态属性的变量或者函数时，到底实际意味着什么？</li>
<li>理解链接器将帮助你理解其他重要的系统概念。</li>
<li>理解链接器将使你能够开发共享库。随着共享库和动态链接在现代操作系统中日益加强的重要性，链接成为了一个复杂的过程，它为知识丰富的程序员提供了强大的能力。比如，许多软件产品使用共享库在运行时来升级压缩包装的二进制程序。</li>
</ul>
<h3 id="目标文件"><a href="#目标文件" class="headerlink" title="目标文件"></a>目标文件</h3><p>​    目标文件有三种形式：</p>
<ul>
<li>可重定位目标文件：包含二进制代码和数据，其形式可以在编译时与其他可重定位目标文件合并起来，创建一个可执行目标文件；</li>
<li>可执行目标文件：包含二进制代码和数据，其形式可以直接被拷贝到存储器并执行；</li>
<li>共享目标文件：一种特殊类型的可重定位目标文件，可以在加载或者运行时，被动态的加载到存储器并链接。</li>
</ul>
<p>编译器和汇编器生成可重定位目标文件（包含共享目标文件），链接器生成可执行目标文件。</p>
<h3 id="加载可执行目标文件"><a href="#加载可执行目标文件" class="headerlink" title="加载可执行目标文件"></a>加载可执行目标文件</h3><p>​    每个Unix程序都有一个运行时存储器映像。如图<img src="/images/memory/linuxmemory.png" alt="linuxmemory.png"></p>
<h3 id="从应用程序中加载和链接共享库"><a href="#从应用程序中加载和链接共享库" class="headerlink" title="从应用程序中加载和链接共享库"></a>从应用程序中加载和链接共享库</h3><p>​    应用程序还可能在它运行时要求动态链接器加载和链接任意共享库，而无需在编译时链接那些库到应用中。动态链接是一项强大有用的技术。向linux这样的Unix系统，为动态链接器提供了一个简单的接口，允许应用程序在运行时加载和链接共享库。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dlfcn.h&gt;                                                                                                                          </span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">dlopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* filename, <span class="keyword">int</span> flag)</span></span>;</span><br><span class="line"><span class="comment">//返回：若成功则为指向句柄的指针，若出错则为NULL</span></span><br></pre></td></tr></table></figure>
<p>​    <code>dlopen</code>函数加载和链接共享库<code>filename</code>。用以前带<code>RELD_GLOBAL</code>选项打开的库解析filename中的外部符号。如果当前可执行文件是带<code>-rdynamic</code>选项编译的，那么对符号解析而言，它的全局符号也是可用的。flag参数必须要么包括<code>RELD_NOW</code>,该标志告诉链接器立即解析外部符号的引用，要么包含<code>RELD_LAZY</code>标志，该标志指示链接器推迟符号解析直到执行来自库中的代码时。这两个中的任何一个都可以和<code>RELD_GLOBAL</code>标志取或。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dlfcn.h&gt;                                                                                                                          </span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">dlsym</span><span class="params">(<span class="keyword">void</span>* handle, <span class="keyword">char</span>* symbol)</span></span>;</span><br><span class="line"><span class="comment">//返回：若成功则为指向符号的指针，若出错则为NULL</span></span><br></pre></td></tr></table></figure>
<p><code>dlsym</code>函数的输入是一个指向前面已经打开共享库的句柄和一个符号的名字，如果该符号存在，就返回符号的地址，否则则为NULL。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dlfcn.h&gt;                                                                                                                          </span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">dlclose</span><span class="params">(<span class="keyword">void</span>* handle, <span class="keyword">char</span>* symbol)</span></span>;</span><br><span class="line"><span class="comment">//返回：若成功则为指向符号的指针，若出错则为NULL</span></span><br></pre></td></tr></table></figure>
<p>如果没有其他共享库还在使用这个共享库，<code>dlclose</code>函数就卸载该共享库。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dlfcn.h&gt;                                                                                                                          </span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">dlerror</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="comment">//返回：若前面对dlopen,dlsym,dlclose的调用失败，则为错误消息，若前面的调用成功，则为NULL。</span></span><br></pre></td></tr></table></figure>
<p><code>dlerror</code>函数返回一个字符串,它描述的是调用<code>dlopen</code>,<code>dlsym</code>,<code>dlclose</code>函数时发生的最近的错误，如果没有错误发生则发回空。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>在addvec.c文件中，创建下面的代码，构建一个动态库。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;                                                                                                                           </span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addvec</span><span class="params">(<span class="keyword">int</span>* x, <span class="keyword">int</span>* y, <span class="keyword">int</span>* z, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;   </span><br><span class="line">        z[i] = x[i] + y[i];</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -shared -fPIC -o libaddvec.so addvec.c </span><br></pre></td></tr></table></figure>
<p>在test.c文件中，动态的加载共享库，如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x[<span class="number">2</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> y[<span class="number">2</span>] = &#123;<span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> z[<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span>* handle;</span><br><span class="line">    <span class="keyword">void</span> (*addvec)(<span class="keyword">int</span>*, <span class="keyword">int</span>*, <span class="keyword">int</span>*, <span class="keyword">int</span>);</span><br><span class="line">    <span class="keyword">char</span>* error;</span><br><span class="line">    <span class="comment">//dynamically load the shared library that contains addvec()</span></span><br><span class="line">    handle = dlopen(<span class="string">&quot;./libaddvec.so&quot;</span>, RTLD_LAZY);</span><br><span class="line">    <span class="keyword">if</span> (handle == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s\n&quot;</span>, dlerror());</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//get a pointer to the addvec() function we just loaded</span></span><br><span class="line">    addvec = dlsym(handle, <span class="string">&quot;addvec&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ((error = dlerror()) != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s\n&quot;</span>, dlerror());</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Now we can call addvec() just like any other function</span></span><br><span class="line">    addvec(x, y, z, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;z = [%d %d]\n&quot;</span>, z[<span class="number">0</span>], z[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">//unload the shared library</span></span><br><span class="line">    <span class="keyword">if</span> (dlclose(handle) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s\n&quot;</span>, dlerror());</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">                                                                                                                                                               </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">s</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -rdynamic -O2 -o test test.c  -ldl</span><br></pre></td></tr></table></figure>
<h3 id="处理目标文件的工具"><a href="#处理目标文件的工具" class="headerlink" title="处理目标文件的工具"></a>处理目标文件的工具</h3><p>​    在Unix系统中有大量可用的工具可以帮助你理解和处理目标文件。特别地，GNU binutils包尤其有帮助，而且可以运行在每个Unxi平台上。</p>
<ul>
<li><code>ar</code>：创建静态库，插入，删除，列出和提取成员；</li>
<li><code>strings</code>：列出一个目标文件中，所有可打印的字符串；</li>
<li><code>strip</code>：从目标文件中删除符号表信息；</li>
<li><code>nm</code>：列出一个目标文件的符号表中定义的符号；</li>
<li><code>size</code>：列出目标文件中节的名字和大小；</li>
<li><code>readelf</code>：显示一个目标文件中的完整结构，包括ELF头中编码的所有信息。包含size和nm的功能；</li>
<li><code>objdump</code>：所有二进制工具之母，能够显示一个目标文件中所有的信息。它最有用的功能是反汇编.text节中的二进制指令。</li>
<li><code>ldd</code>：列出一个可执行文件在运行时所需要的共享库；（Unix系统为共享库提供的ldd程序）</li>
</ul>
<h3 id="操作进程的工具"><a href="#操作进程的工具" class="headerlink" title="操作进程的工具"></a>操作进程的工具</h3><p>​    unix系统提供了大量的监控和操作进程的有用工具：</p>
<ul>
<li><code>strace</code>：打印一个程序和它的子程序调用的每个系统调用的轨迹。对于好奇的学生而言，这是一个令人着迷的工具。用-static编译你的程序，能得到一个清晰的轨迹，而不带有大量与共享库相关的输出；</li>
<li><code>ps</code>：列出系统中当前的进程（包括僵尸进程）；</li>
<li><code>top</code>：打印出关于当前进程资源的使用的信息；</li>
<li><code>kill</code>：发送一个信号给进程。对于调试带信号处理程序以及清除难以捉摸的进程是非常有用的。</li>
<li><code>/proc</code>：一个虚拟文件系统，以ASCII文本格式输出大量内核数据结构的内容，用户程序可以读取这些内容。</li>
</ul>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>​    全文皆是摘录自<a href="https://gitee.com/helioswei/books">《深入理解计算机系统》</a>一书，用于自己的学习和理解，若存在侵权请联系作者。</p>
]]></content>
      <categories>
        <category>Cpp</category>
        <category>memory</category>
      </categories>
      <tags>
        <tag>memory</tag>
      </tags>
  </entry>
  <entry>
    <title>cuda-cuda10.0安装</title>
    <url>/article/2055195890.html</url>
    <content><![CDATA[<p>​        在转码的过程中，我们可以使用硬件来进行转码的加速，今天记录一下在Centos7环境下安装驱动以及cuda模块。</p>
<h3 id="下载驱动"><a href="#下载驱动" class="headerlink" title="下载驱动"></a>下载驱动</h3><p><code>如果打算安装CUDA10.0及以上的版本则不需要单独安装驱动，cuda10.0自带驱动驱动</code><strong>忽略该驱动的安装</strong></p>
<p><a href="https://www.nvidia.cn/Download/Find.aspx?lang=cn&amp;QNF=1">驱动下载地址</a></p>
<p>例如我们下载Quadro P2000 linux64的驱动</p>
<p><img src="/images/cuda/图片1.png" alt="图片1.png"></p>
<p><img src="/images/cuda/图片2.png" alt="图片2.png"></p>
<p>之所以安装这个驱动是因为要安装的cuda10.0也是410的，之后运行安装驱动程序就好了。</p>
<h3 id="安装cuda10-0"><a href="#安装cuda10-0" class="headerlink" title="安装cuda10.0"></a>安装cuda10.0</h3><h5 id="1，下载安装包"><a href="#1，下载安装包" class="headerlink" title="1，下载安装包"></a>1，下载安装包</h5><p>​    <a href="https://developer.nvidia.com/cuda-downloads?target_os=Linux&amp;target_arch=x86_64&amp;target_distro=CentOS&amp;target_version=7&amp;target_type=runfilelocal">安装包下载</a>    在该网站上下载安装包</p>
<p><img src="/images/cuda/图片3.png" alt="图片3.png"></p>
<h5 id="2，版本选择"><a href="#2，版本选择" class="headerlink" title="2，版本选择"></a>2，版本选择</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">通过以下按钮选择历史版本的cuda，找到10.0下载，然后选择对应的系统</span><br></pre></td></tr></table></figure>
<p><img src="/images/cuda/图片4.png" alt="图片4.png"></p>
<h5 id="3，运行-run文件"><a href="#3，运行-run文件" class="headerlink" title="3，运行.run文件"></a>3，运行.run文件</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">下载完安装包放在linux上直接运行.run文件</span><br><span class="line"></span><br><span class="line">chmod +x cuda_10.0.130_410.48_linux.run </span><br><span class="line">.&#x2F;cuda_10.0.130_410.48_linux.run</span><br></pre></td></tr></table></figure>
<h5 id="4，然后一直按回车键直到："><a href="#4，然后一直按回车键直到：" class="headerlink" title="4，然后一直按回车键直到："></a>4，然后一直按回车键直到：</h5><p><img src="/images/cuda/图片5.png" alt="图片5.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">回答：accept</span><br></pre></td></tr></table></figure>
<h5 id="5，是否安装驱动"><a href="#5，是否安装驱动" class="headerlink" title="5，是否安装驱动"></a>5，是否安装驱动</h5><p><img src="/images/cuda/图片6.png" alt="图片6.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">是否安装驱动，这里选择安装：y,因为我们自己没有提前安装驱动，如果提前安装过驱动，这里就不选择安装：n</span><br></pre></td></tr></table></figure>
<h5 id="6，是否安装OpenGL"><a href="#6，是否安装OpenGL" class="headerlink" title="6，是否安装OpenGL"></a>6，是否安装OpenGL</h5><p><img src="/images/cuda/图片7.png" alt="图片7.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">选择;n</span><br></pre></td></tr></table></figure>
<h5 id="7，是否安装x-config"><a href="#7，是否安装x-config" class="headerlink" title="7，是否安装x-config"></a>7，是否安装x-config</h5><p><img src="/images/cuda/图片8.png" alt="图片8.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">选择：n</span><br></pre></td></tr></table></figure>
<h5 id="8，是否安装Toolkit"><a href="#8，是否安装Toolkit" class="headerlink" title="8，是否安装Toolkit"></a>8，是否安装Toolkit</h5><p><img src="/images/cuda/图片10.png" alt="图片10.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">选择：y</span><br></pre></td></tr></table></figure>
<h5 id="9，cuda目录"><a href="#9，cuda目录" class="headerlink" title="9，cuda目录"></a>9，cuda目录</h5><p><img src="/images/cuda/图片11.png" alt="图片11.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">直接回车，选择默认安装路径</span><br></pre></td></tr></table></figure>
<h5 id="10，是否创建软连接"><a href="#10，是否创建软连接" class="headerlink" title="10，是否创建软连接"></a>10，是否创建软连接</h5><p><img src="/images/cuda/图片12.png" alt="图片12.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">选择：y</span><br></pre></td></tr></table></figure>
<h5 id="11，是否安装示例"><a href="#11，是否安装示例" class="headerlink" title="11，是否安装示例"></a>11，是否安装示例</h5><p><img src="/images/cuda/图片13.png" alt="图片13.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">为了节约空间，这个不安装</span><br><span class="line">选择：n</span><br></pre></td></tr></table></figure>
<h5 id="12，然后开始安装"><a href="#12，然后开始安装" class="headerlink" title="12，然后开始安装"></a>12，然后开始安装</h5><p><img src="/images/cuda/图片14.png" alt="图片14.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">表示安装成功</span><br></pre></td></tr></table></figure>
<h5 id="13，添加配置文件"><a href="#13，添加配置文件" class="headerlink" title="13，添加配置文件"></a>13，添加配置文件</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim  &#x2F;etc&#x2F;profile</span><br><span class="line">写入：</span><br><span class="line">export PATH&#x3D;&#x2F;usr&#x2F;local&#x2F;cuda-10.0&#x2F;bin:$PATH</span><br><span class="line">export LD_LIBRARY_PATH&#x3D;&#x2F;usr&#x2F;local&#x2F;cuda&#x2F;lib64:$LD_LIBRARY_PATH</span><br><span class="line">保存：</span><br><span class="line">source &#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure>
<h5 id="14，卸载驱动及cuda"><a href="#14，卸载驱动及cuda" class="headerlink" title="14，卸载驱动及cuda"></a>14，卸载驱动及cuda</h5><p><img src="/images/cuda/图片15.png" alt="图片15.png"></p>
<font color="red"><strong>注意</strong></font>

<p><code>1,千万不要重复安装显卡驱动，会导致系统损坏</code></p>
<p><code>2.升级cuda的时候，一定要将旧版本的cuda卸载干净，否则会出现意想不到的错误</code></p>
<h5 id="15，查看命令"><a href="#15，查看命令" class="headerlink" title="15，查看命令"></a>15，查看命令</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1，检查显卡类型</span><br><span class="line">yum install pciutils（如果没有这个命令，则下载）</span><br><span class="line">lspci | grep VGA</span><br></pre></td></tr></table></figure>
<p><img src="/images/cuda/图片17.png" alt="图片17.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2，检查安装是否成功</span><br><span class="line">nvidia-smi</span><br></pre></td></tr></table></figure>
<p><img src="/images/cuda/图片16.png" alt="图片16.png"></p>
<h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><h5 id="1，-usr-bin-perl-bad-interpreter-No-such-file-or-directory"><a href="#1，-usr-bin-perl-bad-interpreter-No-such-file-or-directory" class="headerlink" title="1， /usr/bin/perl: bad interpreter: No such file or directory"></a>1， /usr/bin/perl: bad interpreter: No such file or directory</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install gcc</span><br><span class="line">yum install perl</span><br></pre></td></tr></table></figure>
<h5 id="2，kernel源安装"><a href="#2，kernel源安装" class="headerlink" title="2，kernel源安装"></a>2，kernel源安装</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">检查系统版本</span><br><span class="line">uname -a</span><br><span class="line">yum install kernel-devel-$(uname -r) kernel-headers-$(uname -r)</span><br><span class="line">先查看源是否相同，如果没有则需要下载</span><br></pre></td></tr></table></figure>
<h5 id="3，禁用nouveau（对某些版本需要）"><a href="#3，禁用nouveau（对某些版本需要）" class="headerlink" title="3，禁用nouveau（对某些版本需要）"></a>3，禁用nouveau（对某些版本需要）</h5><h6 id="1，修改文件"><a href="#1，修改文件" class="headerlink" title="1，修改文件"></a>1，修改文件</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1，修改文件</span><br><span class="line">cd &#x2F;etc&#x2F;modprobe.d</span><br><span class="line">vim nvidia-installer-disable-nouveau.conf（如果没有这个文件，则手动生成）</span><br><span class="line"> </span><br><span class="line"> 内容：</span><br><span class="line"> # generated by nvidia-installer</span><br><span class="line"> blacklist nouveau</span><br><span class="line"> options nouveau modeset&#x3D;0</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h6 id="2，备份-initramfs"><a href="#2，备份-initramfs" class="headerlink" title="2，备份 initramfs"></a>2，备份 initramfs</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mv &#x2F;boot&#x2F;initramfs-$(uname -r).img &#x2F;boot&#x2F;initramfs-$(uname -r).img.bak</span><br></pre></td></tr></table></figure>
<h6 id="3，重建-initramfs"><a href="#3，重建-initramfs" class="headerlink" title="3，重建 initramfs"></a>3，重建 initramfs</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dracut -v &#x2F;boot&#x2F;initramfs-$(uname -r).img $(uname -r)</span><br></pre></td></tr></table></figure>
<h6 id="4，重启机器"><a href="#4，重启机器" class="headerlink" title="4，重启机器"></a>4，重启机器</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">reboot</span><br></pre></td></tr></table></figure>
<h6 id="5，检查nouveau-driver确保没有被加载"><a href="#5，检查nouveau-driver确保没有被加载" class="headerlink" title="5，检查nouveau driver确保没有被加载"></a>5，检查nouveau driver确保没有被加载</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lsmod | grep nouveau</span><br><span class="line">没有加载则为空，有加载则如图，说明设置没有生效，需要重新设置</span><br></pre></td></tr></table></figure>
<p><img src="/images/cuda/nouveau.png" alt="nouveau.png"></p>
]]></content>
      <categories>
        <category>Media</category>
        <category>video</category>
      </categories>
      <tags>
        <tag>cuda</tag>
      </tags>
  </entry>
  <entry>
    <title>docker-docker常用命令</title>
    <url>/article/2019996800.html</url>
    <content><![CDATA[<p>记录一下自己在工作中常用的docker命令</p>
<h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum -y install docker</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure>
<p>验证是否可以正常运行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure>
<h3 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h3><h5 id="镜像构建通过dockfile"><a href="#镜像构建通过dockfile" class="headerlink" title="镜像构建通过dockfile"></a>镜像构建通过dockfile</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker build -t datatom&#x2F;video-worker:v4.2.0 -f Dockerfile .</span><br></pre></td></tr></table></figure>
<h5 id="镜像打包"><a href="#镜像打包" class="headerlink" title="镜像打包"></a>镜像打包</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker save -o video-worker.v4.2.0.tar datatom&#x2F;video-worker:v4.2.0</span><br></pre></td></tr></table></figure>
<h5 id="镜像导入"><a href="#镜像导入" class="headerlink" title="镜像导入"></a>镜像导入</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker load -i video-worker.v4.2.0.tar</span><br></pre></td></tr></table></figure>
<h5 id="查看镜像"><a href="#查看镜像" class="headerlink" title="查看镜像"></a>查看镜像</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure>
<p><img src="/images/docker/docker.png" alt="docker.png"></p>
<h5 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker rmi IMAGEID </span><br></pre></td></tr></table></figure>
<p>如果当前镜像正在被容器使用，则需要先删除容器，可以使用如下命令删除</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker rm $(docker ps -a | grep IMAGEID|awk &#39;&#123;print $1&#125;&#39;) -f</span><br><span class="line">docker rmi IMAGEID</span><br></pre></td></tr></table></figure>
<h5 id="删除none镜像"><a href="#删除none镜像" class="headerlink" title="删除none镜像"></a>删除none镜像</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker rmi $(docker images | grep &#39;&lt;none&gt;&#39;|awk &#39;&#123;print $3&#125;&#39;) -f</span><br></pre></td></tr></table></figure>
<h5 id="镜像运行"><a href="#镜像运行" class="headerlink" title="镜像运行"></a>镜像运行</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -it e2cbe0447a2b &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure>
<p>镜像运行时添加环境变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -e MEDIA_REDIS_IP&#x3D;127.0.0.1 -e MEDIA_REDIS_PORT&#x3D;5555  -it d3796bd153f8 &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure>
<h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><h5 id="查看正在运行的容器"><a href="#查看正在运行的容器" class="headerlink" title="查看正在运行的容器"></a>查看正在运行的容器</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></table></figure>
<h5 id="停止容器"><a href="#停止容器" class="headerlink" title="停止容器"></a>停止容器</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker stop CONTAINERID</span><br></pre></td></tr></table></figure>
<h5 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker rm CONTAINERID</span><br></pre></td></tr></table></figure>
<h5 id="强制删除"><a href="#强制删除" class="headerlink" title="强制删除"></a>强制删除</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker rm CONTAINERID -f</span><br></pre></td></tr></table></figure>
<h3 id="tag"><a href="#tag" class="headerlink" title="tag"></a>tag</h3><h5 id="修改镜像的tagid"><a href="#修改镜像的tagid" class="headerlink" title="修改镜像的tagid"></a>修改镜像的tagid</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker  tag   f92b7e4509da  datatom&#x2F;image-worker:v4.1.1</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>cmd</tag>
      </tags>
  </entry>
  <entry>
    <title>ffmpeg_avfilter的使用详解</title>
    <url>/article/4030313287.html</url>
    <content><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;在ffmpeg，我们对视音频进行一些处理，如添加水印，有个很方便的库，avfilter，</p>
<p>过滤的过程<br>解码后的画面 -&gt; buffer过滤器 -&gt; 其他过滤器 -&gt; buffersink 过滤器 -&gt; 处理好的画面</p>
]]></content>
      <categories>
        <category>Media</category>
        <category>video</category>
      </categories>
      <tags>
        <tag>ffmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title>ffmpeg-内存io模式(内存区做输入或输出)</title>
    <url>/article/2452888490.html</url>
    <content><![CDATA[<p>​    在转码的过程中，我们有时候需要从远程下载文件，当文件很大的时候会占用本地的磁盘空间，同时下载的时间也比较的长，这时候我们考虑直接读取流信息或者写入流信息来进行操作，而不是上传或者下载整个文件来解决。</p>
<h3 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h3><p>​    转码的基础逻辑不变，仅仅是在输入输出读取的方式不同，我们需要自己实现输入输出的函数。</p>
<h4 id="关键结构体"><a href="#关键结构体" class="headerlink" title="关键结构体"></a>关键结构体</h4><p>​    <code>AVIOContext</code>，我们需要初始化这个结构体来存放内存的数据。</p>
<h3 id="内存读取数据"><a href="#内存读取数据" class="headerlink" title="内存读取数据"></a>内存读取数据</h3><p>​        转码的基本流程不变，仅仅是在开始读取数据的时候有些不同</p>
<h4 id="读取本地文件"><a href="#读取本地文件" class="headerlink" title="读取本地文件"></a>读取本地文件</h4><p><img src="/images/ffmpeg/file.png" alt="file"></p>
<h4 id="读取流文件"><a href="#读取流文件" class="headerlink" title="读取流文件"></a>读取流文件</h4><p><img src="/images/ffmpeg/stream.png" alt="stream"></p>
<p><img src="/images/ffmpeg/readstream.png" alt="read"></p>
<h3 id="ffmpeg内存读取数据"><a href="#ffmpeg内存读取数据" class="headerlink" title="ffmpeg内存读取数据"></a>ffmpeg内存读取数据</h3><p>​    如图,<font color="red">红色框</font>内是当输入是流时的处理，<font color="green">绿色框</font>内是当输入是文件时的处理，二选一即可。<img src="/images/ffmpeg/stream/input.png" alt="input.png"></p>
<p><code>fill_iobuffer</code> 函数是我们自己实现的输入流的函数，内容如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">359</span> <span class="comment">//读取流数据</span></span><br><span class="line"><span class="number">360</span> <span class="function"><span class="keyword">int</span> <span class="title">fill_iobuffer</span><span class="params">(<span class="keyword">void</span> *opaque, <span class="keyword">uint8_t</span> *buf, <span class="keyword">int</span> buf_size)</span> </span>&#123;</span><br><span class="line"><span class="number">361</span>     <span class="built_in">string</span> hosts = <span class="string">&quot;192.168.50.31:7480&quot;</span>;</span><br><span class="line"><span class="number">362</span>     <span class="built_in">string</span> ak = <span class="string">&quot;11043ee2070d01eb5740f9870dfe3abd&quot;</span>;</span><br><span class="line"><span class="number">363</span>     <span class="built_in">string</span> sk = <span class="string">&quot;bb31a3a96b829976513ee62b4e28ee3f&quot;</span>;</span><br><span class="line"><span class="number">364</span>     <span class="function">S3::Client <span class="title">client</span><span class="params">(hosts, ak, sk)</span></span>;</span><br><span class="line"><span class="number">365</span>     <span class="keyword">static</span> <span class="keyword">uint64_t</span> offset = <span class="number">0</span>;</span><br><span class="line"><span class="number">366</span>     <span class="keyword">uint64_t</span> num;</span><br><span class="line"><span class="number">367</span>     <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="number">368</span>         <span class="comment">// num  = client.GetObject(&quot;leopardsrc&quot;, &quot;video-H263-AC3.avi&quot;,offset,</span></span><br><span class="line"><span class="number">369</span>         <span class="comment">// buf_size, (char* )buf);</span></span><br><span class="line"><span class="number">370</span>         num = client.GetObject(<span class="string">&quot;leopardsrc&quot;</span>, <span class="string">&quot;video-H264-AAC.m4v&quot;</span>, offset,</span><br><span class="line"><span class="number">371</span>                                buf_size, (<span class="keyword">char</span> *)buf);</span><br><span class="line"><span class="number">372</span>         offset += num;</span><br><span class="line"><span class="number">373</span>         <span class="keyword">return</span> num;</span><br><span class="line"><span class="number">374</span>     &#125;</span><br><span class="line"><span class="number">375</span>     <span class="keyword">catch</span> (S3::S3Exception &amp;e) &#123;</span><br><span class="line"><span class="number">376</span>         LOG(ERROR) &lt;&lt; e.str();</span><br><span class="line"><span class="number">377</span>         <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">378</span>     &#125;</span><br><span class="line"><span class="number">379</span> &#125;   </span><br></pre></td></tr></table></figure>
<h3 id="ffmpeg内存存储数据"><a href="#ffmpeg内存存储数据" class="headerlink" title="ffmpeg内存存储数据"></a>ffmpeg内存存储数据</h3><p>​    如图,<font color="red">红色框</font>内是当输入是流时的处理，<font color="green">绿色框</font>内是当输入是文件时的处理，二选一即可。<img src="/images/ffmpeg/stream/output.png" alt="output.png"></p>
<p><code>write_buffer</code> 函数是我们自己实现的输出流的函数，内容如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">614</span> <span class="function"><span class="keyword">int</span> <span class="title">write_buffer</span><span class="params">(<span class="keyword">void</span> *opaque, <span class="keyword">uint8_t</span> *buf, <span class="keyword">int</span> buf_size)</span> </span>&#123;</span><br><span class="line"><span class="number">627</span>     <span class="keyword">if</span> (!feof(fp_write)) &#123;</span><br><span class="line"><span class="number">634</span>         <span class="keyword">int</span> true_size = fwrite(buf, <span class="number">1</span>, buf_size, fp_write);</span><br><span class="line"><span class="number">635</span>         <span class="keyword">return</span> true_size;</span><br><span class="line"><span class="number">636</span>     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="number">637</span>         <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="number">638</span>     &#125;</span><br><span class="line"><span class="number">639</span> &#125; </span><br></pre></td></tr></table></figure>
<p>​    目前这个是测试ffmpeg能够支持自己的输出函数，如果是关于s3的输出支持，需要看s3关于流的实现接口。目前s3是不支持流的处理，只能考虑s3的分块上传。</p>
<h4 id="输出到内存注意事项"><a href="#输出到内存注意事项" class="headerlink" title="输出到内存注意事项"></a>输出到内存注意事项</h4><h5 id="avio-open"><a href="#avio-open" class="headerlink" title="avio_open"></a>avio_open</h5><p>​    当你的输出函数是自己实现的，不是默认的写入到本地文件，则<code>avio_open</code>这个函数不能够被调用。如图,加入一个判断，当输出为自定义函数时不调用avio_open函数。<img src="/images/ffmpeg/stream/avio.png" alt="avio.png"></p>
<p>同样，在释放资源的时候也需要做相同的处理。在文件<code>mediainfo.h</code>中的<code>~FileInfoStruct()</code>函数中加入一层判断。<img src="/images/ffmpeg/stream/avio1.png" alt="avio1.png"></p>
<h5 id="输出封装格式的限制"><a href="#输出封装格式的限制" class="headerlink" title="输出封装格式的限制"></a>输出封装格式的限制</h5><p>​    有一些封装格式不支持以流的方式作为输出，如mp4，错误信息如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[mp4 @ 0x8d0c80] muxer does not support non seekable output</span><br></pre></td></tr></table></figure>
<p>​    解决方法：通过将mp4文件进行碎片化，即生成Fmp4格式来进行操作。如图  <img src="/images/ffmpeg/stream/fmp4.png" alt="fmp4.png"></p>
<p>​    我们需要添加<code>movflags</code>参数来进行处理。</p>
]]></content>
      <categories>
        <category>Media</category>
        <category>video</category>
      </categories>
      <tags>
        <tag>ffmpeg</tag>
        <tag>io</tag>
      </tags>
  </entry>
  <entry>
    <title>ffmpeg-源码编译支持GPU</title>
    <url>/article/2764140538.html</url>
    <content><![CDATA[<blockquote>
<p>​    源码编译需要很多的库的支持，一种是基础的库，一种是你需要的编解码信息的库</p>
</blockquote>
<h2 id="一，ffmpeg源码的下载"><a href="#一，ffmpeg源码的下载" class="headerlink" title="一，ffmpeg源码的下载"></a>一，ffmpeg源码的下载</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在git上找个你需要的版本的库，直接通过git下载</span><br><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;FFmpeg&#x2F;FFmpeg.git</span><br><span class="line"></span><br><span class="line">ffmpeg 版本 ffmpeg version n4.1.1-3-g53f3f52</span><br><span class="line">cuda 版本 CUDA Version 10.0.130（这个版本自带驱动，可以不用安装驱动）</span><br><span class="line">drive 驱动版本 Driver Version: 410.48 </span><br><span class="line">nv-codec-headers 版本 sdk&#x2F;8.1</span><br></pre></td></tr></table></figure>
<h2 id="二，基础环境的准备"><a href="#二，基础环境的准备" class="headerlink" title="二，基础环境的准备"></a>二，基础环境的准备</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum -y install autoconf automake freetype-devel gcc gcc-c++ git libtool make nasm pkgconfig zlib-devel bzip2 bzip2-devel</span><br></pre></td></tr></table></figure>
<h2 id="三，编码过程"><a href="#三，编码过程" class="headerlink" title="三，编码过程"></a>三，编码过程</h2><h4 id="1，设置环境路径"><a href="#1，设置环境路径" class="headerlink" title="1，设置环境路径"></a>1，设置环境路径</h4><blockquote>
<p>​    在  /etc/profile 文件中，设置 PKG_CONFIG_PATH  路径</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;profile</span><br><span class="line">export PKG_CONFIG_PATH&#x3D;&#x2F;usr&#x2F;local&#x2F;lib64&#x2F;pkgconfig:&#x2F;usr&#x2F;lib64&#x2F;pkgconfig:&#x2F;usr&#x2F;local&#x2F;lib&#x2F;pkgconfig:&#x2F;usr&#x2F;lib&#x2F;pkgconfig</span><br></pre></td></tr></table></figure>
<h4 id="2，编码"><a href="#2，编码" class="headerlink" title="2，编码"></a>2，编码</h4><blockquote>
<p>​    配置好configure之后，通过make可以一步步试探你缺少的库是什么，然后在下载，编译</p>
<p>下载完之后，通过命令来配置你需要的东西<br>./configure  –help</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make 编译的常用命令</span><br><span class="line">.&#x2F;configure</span><br><span class="line">make -j 10 (编译，并行10个核来一起编译，可以取消)</span><br><span class="line">make install (安装)</span><br><span class="line">make disclean (卸载)</span><br><span class="line">make clean (清除编译)</span><br></pre></td></tr></table></figure>
<h4 id="3，解决gnutls的问题"><a href="#3，解决gnutls的问题" class="headerlink" title="3，解决gnutls的问题"></a>3，解决gnutls的问题</h4><p><img src="/images/gnutls.png" alt="gnutls"></p>
<blockquote>
<p>我们需要手动的安装gnutls，gnutls3.5.19版本的可以，大于这个版本的有问题,</p>
<p><a href="http://www.linuxfromscratch.org/blfs/view/svn/postlfs/gnutls.html">http://www.linuxfromscratch.org/blfs/view/svn/postlfs/gnutls.html</a> </p>
<p>有安装的方法</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1,安装gnutls需要先安装gnutls，所有先手动下载这个</span><br><span class="line">wget https:&#x2F;&#x2F;ftp.gnu.org&#x2F;gnu&#x2F;nettle&#x2F;nettle-3.1.1.tar.gz</span><br><span class="line">tar zxf nettle-3.1.1.tar.gz  </span><br><span class="line">.&#x2F;configure --enable-shared</span><br><span class="line">make</span><br><span class="line">make install</span><br><span class="line">2,安装gnutls</span><br><span class="line">wget https:&#x2F;&#x2F;www.gnupg.org&#x2F;ftp&#x2F;gcrypt&#x2F;gnutls&#x2F;v3.5&#x2F;gnutls-3.5.19.tar.xz</span><br><span class="line">xz  -d gnutls-3.5.19.tar.xz</span><br><span class="line">tar xf gnutls-3.5.19.tar</span><br><span class="line">cd gnutls-3.5.19</span><br><span class="line">.&#x2F;configure --enable-shared</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<p>在安装gnutls时，我们使用./configure –enable-shared时，可能遇到以下的问题;</p>
<ul>
<li><p><img src="/images/gmp.png" alt="gmp"></p>
<blockquote>
<p>解决：</p>
<p>yum install gmp-devel</p>
</blockquote>
</li>
<li><p><img src="/images/libtasn1.png" alt="libtasn1.png"></p>
<blockquote>
<p>解决：</p>
<p>yum install libffi libffi-devel</p>
<p>./configure –enable-shared –with-included-libtasn1</p>
</blockquote>
</li>
</ul>
<ul>
<li><p><img src="/images/unistring.png" alt="unistring.png"></p>
<blockquote>
<p>解决：</p>
<p>yum install libunistring-devel</p>
<p>./configure –enable-shared –with-included-libtasn1 –with-included-unistring</p>
</blockquote>
</li>
<li><p><img src="/images/P11.png" alt="P11.png"></p>
<blockquote>
<p>解决：</p>
<p>yum install p11-kit-devel</p>
</blockquote>
</li>
<li><p><img src="/images/dnssec.png" alt="dnssec.png"></p>
<blockquote>
<p>yum install unbound unbound-devel unbound-libs</p>
<p>./configure –enable-shared –with-included-libtasn1 –with-included-unistring</p>
</blockquote>
</li>
</ul>
<h4 id="4，解决ladspa-h的问题"><a href="#4，解决ladspa-h的问题" class="headerlink" title="4，解决ladspa.h的问题"></a>4，解决ladspa.h的问题</h4><p><img src="/images/ladspa.png" alt="ladspa.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install  ladspa*</span><br></pre></td></tr></table></figure>
<h4 id="5，解决libass的问题"><a href="#5，解决libass的问题" class="headerlink" title="5，解决libass的问题"></a>5，解决libass的问题</h4><p><img src="/images/libass.png" alt="libass.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install libass*</span><br></pre></td></tr></table></figure>
<h4 id="6，解决libdc1394-2的问题"><a href="#6，解决libdc1394-2的问题" class="headerlink" title="6，解决libdc1394-2的问题"></a>6，解决libdc1394-2的问题</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1,官网下载源码</span><br><span class="line">https:&#x2F;&#x2F;sourceforge.net&#x2F;projects&#x2F;libdc1394&#x2F;files&#x2F;libdc1394-2&#x2F;</span><br><span class="line">2，编译</span><br><span class="line">.&#x2F;configure</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<h4 id="7，解决libgsm的问题"><a href="#7，解决libgsm的问题" class="headerlink" title="7，解决libgsm的问题"></a>7，解决libgsm的问题</h4><p><img src="/images/libgsm.png" alt="libgsm.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install gsm-tools gsm-devel</span><br></pre></td></tr></table></figure>
<h4 id="8，解决libmp3lame版本的问题"><a href="#8，解决libmp3lame版本的问题" class="headerlink" title="8，解决libmp3lame版本的问题"></a>8，解决libmp3lame版本的问题</h4><p><img src="/images/libmp3lame.png" alt="libmp3lame.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">源码安装，地址</span><br><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;gypified&#x2F;libmp3lame.git</span><br><span class="line">.&#x2F;configure</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<h4 id="9，解决libopencore-amrnb的问题"><a href="#9，解决libopencore-amrnb的问题" class="headerlink" title="9，解决libopencore_amrnb的问题"></a>9，解决libopencore_amrnb的问题</h4><p><img src="/images/libopencore_amrnb.png" alt="libopencore_amrnb.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">官网下载源码，再手动编译</span><br><span class="line">https:&#x2F;&#x2F;sourceforge.net&#x2F;projects&#x2F;opencore-amr&#x2F;files&#x2F;opencore-amr&#x2F;</span><br><span class="line"> .&#x2F;configure</span><br><span class="line"> make</span><br><span class="line"> make install</span><br></pre></td></tr></table></figure>
<h4 id="10，解决opencv的问题"><a href="#10，解决opencv的问题" class="headerlink" title="10，解决opencv的问题"></a>10，解决opencv的问题</h4><h4 id="11，解决openh264的问题"><a href="#11，解决openh264的问题" class="headerlink" title="11，解决openh264的问题"></a>11，解决openh264的问题</h4><p><img src="/images/openh264.png" alt="openh264.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">从git上下载源码</span><br><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;cisco&#x2F;openh264</span><br><span class="line">如果下载失败，则直接下载zip包，然后解压安装</span><br><span class="line">make ARCH&#x3D;x86_64</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<h4 id="12，解决libopenjp2版本的问题"><a href="#12，解决libopenjp2版本的问题" class="headerlink" title="12，解决libopenjp2版本的问题"></a>12，解决libopenjp2版本的问题</h4><p><img src="/images/libopenjp2.png" alt="libopenjp2.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git下载源码来编译安装</span><br><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;uclouvain&#x2F;openjpeg.git</span><br><span class="line">如果下载不下来，则下载zip包解压安装 </span><br><span class="line">unzip openjpeg-master.zip</span><br><span class="line">cmake 安装</span><br><span class="line">mkdir build</span><br><span class="line">cd build</span><br><span class="line">cmake .. -DCMAKE_BUILD_TYPE&#x3D;Release</span><br><span class="line">make -j 10</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<h4 id="13，解决opus的问题"><a href="#13，解决opus的问题" class="headerlink" title="13，解决opus的问题"></a>13，解决opus的问题</h4><p><img src="/images/opus.png" alt="opus.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#需要手动的下载安装</span><br><span class="line">https:&#x2F;&#x2F;ftp.osuosl.org&#x2F;pub&#x2F;xiph&#x2F;releases&#x2F;opus&#x2F;</span><br><span class="line">#安装步骤</span><br><span class="line">wget http:&#x2F;&#x2F;downloads.xiph.org&#x2F;releases&#x2F;opus&#x2F;opus-1.2.1.tar.gz</span><br><span class="line">tar -zxvf opus-1.2.1.tar.gz</span><br><span class="line">cd opus-1.2.1</span><br><span class="line">.&#x2F;configure</span><br><span class="line">make</span><br><span class="line">make install</span><br><span class="line">#注意：如果pkg_config没有找到，需要手动的设置路径，见前面PKG_CONFIG_PATH路径的设置，如果设置好之后，库也存在还是不行，则要检查是否使用yum下载了低版本的，若是则删除</span><br><span class="line">yum remove opus-1.0.2-6.el7.x86_64 opus-tools-0.1.6-1.el7.x86_64 opusfile-0.5-1.el7.x86_64 opus-devel-1.0.2-6.el7.x86_64 opusfile-devel-0.5-1.el7.x86_64</span><br></pre></td></tr></table></figure>
<h4 id="14，解决libpulse的问题"><a href="#14，解决libpulse的问题" class="headerlink" title="14，解决libpulse的问题"></a>14，解决libpulse的问题</h4><h4 id="15，解决libsoxr的问题"><a href="#15，解决libsoxr的问题" class="headerlink" title="15，解决libsoxr的问题"></a>15，解决libsoxr的问题</h4><p><img src="/images/libsoxr.png" alt="libsoxr.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#手动下载包，然后编译安装</span><br><span class="line">https:&#x2F;&#x2F;sourceforge.net&#x2F;projects&#x2F;soxr&#x2F;files&#x2F;</span><br><span class="line">tar -xvf soxr-0.1.3-Source.tar</span><br><span class="line">.&#x2F;go</span><br><span class="line">cd Realse</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<p>在执行go的时候可能遇到这个问题,则需要下载cmake高级版本</p>
<p><img src="/images/go.png" alt="go.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># cmake 安装</span><br><span class="line">https:&#x2F;&#x2F;cmake.org&#x2F;download&#x2F;</span><br><span class="line">tar -zxvf cmake-3.13.0-rc1.tar.gz</span><br><span class="line">.&#x2F;configure</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<h4 id="16，解决speex的问题"><a href="#16，解决speex的问题" class="headerlink" title="16，解决speex的问题"></a>16，解决speex的问题</h4><p><img src="/images/speex.png" alt="speex.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">##手动下载安装包，编译，选择 libspeex下载</span><br><span class="line">https:&#x2F;&#x2F;xiph.org&#x2F;downloads&#x2F;</span><br><span class="line">.&#x2F;configure  --enable-shared</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<h4 id="17，解决libtheora的问题"><a href="#17，解决libtheora的问题" class="headerlink" title="17，解决libtheora的问题"></a>17，解决libtheora的问题</h4><p><img src="/images/libtheora.png" alt="libtheora.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">## 手动下载安装包，编译，选择libtheora下载</span><br><span class="line">https:&#x2F;&#x2F;xiph.org&#x2F;downloads&#x2F;</span><br><span class="line">unzip libtheora-1.1.1.zip</span><br><span class="line">.&#x2F;configure</span><br><span class="line">make</span><br><span class="line">make install</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在configure的过程中，可能error,则我们需要下载安装这个</p>
<p><img src="/images/ogg.png" alt="ogg.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install libogg*</span><br></pre></td></tr></table></figure>
<h4 id="18，解决libv412的问题"><a href="#18，解决libv412的问题" class="headerlink" title="18，解决libv412的问题"></a>18，解决libv412的问题</h4><h4 id="19，解决vorbis的问题"><a href="#19，解决vorbis的问题" class="headerlink" title="19，解决vorbis的问题"></a>19，解决vorbis的问题</h4><p><img src="/images/vorbis.png" alt="vorbis.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;xiph&#x2F;vorbis.git</span><br><span class="line">.&#x2F;autogen.sh</span><br><span class="line">.&#x2F;configure  --enable-shared</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<h4 id="20，解决libx264的问题"><a href="#20，解决libx264的问题" class="headerlink" title="20，解决libx264的问题"></a>20，解决libx264的问题</h4><p><img src="/images/libx264.png" alt="h264.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone --depth 1 http:&#x2F;&#x2F;git.videolan.org&#x2F;git&#x2F;x264</span><br><span class="line">.&#x2F;configure --enable-shared</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<p>如果编译时报错，则需要安装nasm</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -O -L http:&#x2F;&#x2F;www.nasm.us&#x2F;pub&#x2F;nasm&#x2F;releasebuilds&#x2F;2.13.02&#x2F;nasm-2.13.02.tar.bz2  </span><br><span class="line">tar -xjvf nasm-2.13.02.tar.bz2</span><br><span class="line">cd nasm-2.13.02</span><br><span class="line">.&#x2F;autogen.sh </span><br><span class="line">.&#x2F;configure  --enable-shared </span><br><span class="line">make</span><br><span class="line">make install</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="21，解决libx265的问题"><a href="#21，解决libx265的问题" class="headerlink" title="21，解决libx265的问题"></a>21，解决libx265的问题</h4><p><img src="/images/x265.png" alt="x265.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone  --depth 1 https:&#x2F;&#x2F;github.com&#x2F;videolan&#x2F;x265.git</span><br><span class="line">cd x265</span><br><span class="line">cd build</span><br><span class="line">cmake ..&#x2F;source</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<h4 id="22，解决libxvid的问题"><a href="#22，解决libxvid的问题" class="headerlink" title="22，解决libxvid的问题"></a>22，解决libxvid的问题</h4><p><img src="/images/libxvid.png" alt="libxvid.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">##官网下载</span><br><span class="line">https:&#x2F;&#x2F;www.xvid.com&#x2F;download&#x2F;</span><br><span class="line">## 按下图过程来查找</span><br><span class="line">## 然后按照README来安装</span><br><span class="line">cd build&#x2F;generic</span><br><span class="line">.&#x2F;configure</span><br><span class="line">make -j 10</span><br><span class="line"></span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<p><img src="/images/xvid.png" alt=" xvid"></p>
<p><img src="C:/Users/Administrator/Desktop/leopard4.1/images/readme.png" alt="readme.png"></p>
<p><img src="/images/bar.png" alt="bar.png"></p>
<h4 id="23，解决openal的问题"><a href="#23，解决openal的问题" class="headerlink" title="23，解决openal的问题"></a>23，解决openal的问题</h4><p><img src="/images/openal.png" alt="openal.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install openal-soft openal-soft-devel</span><br></pre></td></tr></table></figure>
<h4 id="24，解决libcdio的问题"><a href="#24，解决libcdio的问题" class="headerlink" title="24，解决libcdio的问题"></a>24，解决libcdio的问题</h4><h4 id="25，解决bzlib的问题"><a href="#25，解决bzlib的问题" class="headerlink" title="25，解决bzlib的问题"></a>25，解决bzlib的问题</h4><h4 id="26，解决libxcb的问题"><a href="#26，解决libxcb的问题" class="headerlink" title="26，解决libxcb的问题"></a>26，解决libxcb的问题</h4><p><img src="/images/libxcb.png" alt="libxcb.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install libxcb-devel</span><br></pre></td></tr></table></figure>
<h2 id="四，添加硬件编解码"><a href="#四，添加硬件编解码" class="headerlink" title="四，添加硬件编解码"></a>四，添加硬件编解码</h2><h4 id="1，查看机器上显卡的型号"><a href="#1，查看机器上显卡的型号" class="headerlink" title="1，查看机器上显卡的型号"></a>1，查看机器上显卡的型号</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lspci | grep VGA</span><br></pre></td></tr></table></figure>
<p><img src="/images/vga.png" alt="vga"></p>
<h4 id="2，安装对应显卡的驱动"><a href="#2，安装对应显卡的驱动" class="headerlink" title="2，安装对应显卡的驱动"></a>2，安装对应显卡的驱动</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;www.nvidia.com&#x2F;Download&#x2F;index.aspx?lang&#x3D;en-us</span><br><span class="line">安装的方法见显卡驱动安装的文档</span><br></pre></td></tr></table></figure>
<h4 id="3，重新编译ffmpeg"><a href="#3，重新编译ffmpeg" class="headerlink" title="3，重新编译ffmpeg"></a>3，重新编译ffmpeg</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在.&#x2F;configure时添加以下的选项，来重新编译ffmpeg，既可以驱动显卡</span><br><span class="line">--enable-cuda-sdk \</span><br><span class="line">--enable-cuvid \</span><br><span class="line">--enable-nvenc \</span><br><span class="line">--enable-nonfree \</span><br><span class="line">--enable-libnpp \</span><br><span class="line">--extra-cflags&#x3D;-I&#x2F;usr&#x2F;local&#x2F;cuda&#x2F;include \</span><br><span class="line">--extra-ldflags&#x3D;-L&#x2F;usr&#x2F;local&#x2F;cuda&#x2F;lib64 \</span><br></pre></td></tr></table></figure>
<h4 id="4，查看是否安装成功"><a href="#4，查看是否安装成功" class="headerlink" title="4，查看是否安装成功"></a>4，查看是否安装成功</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">使用ffmpeg -hwaccels命令查看支持的硬件加速选项</span><br><span class="line">ffmpeg -hwaccels</span><br></pre></td></tr></table></figure>
<p><img src="/images/hw.png" alt="hw.png"></p>
<h4 id="5，查看cuvid提供的GPU编解码器"><a href="#5，查看cuvid提供的GPU编解码器" class="headerlink" title="5，查看cuvid提供的GPU编解码器"></a>5，查看cuvid提供的GPU编解码器</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ffmpeg -codecs | grep cuvid</span><br></pre></td></tr></table></figure>
<p><img src="/images/cuvid.png" alt="cuvid.png"></p>
<h4 id="6，使用GPU进行转码"><a href="#6，使用GPU进行转码" class="headerlink" title="6，使用GPU进行转码"></a>6，使用GPU进行转码</h4><blockquote>
<p>用GPU进行转码的命令和软转码命令不太一样，CPU转码的时候，我们可以依赖ffmpeg识别输入视频的编码格式并选择对应的解码器，但ffmpeg只会自动选择CPU解码器，要让ffmpeg使用GPU解码器，必须先用ffprobe识别出输入视频的编码格式，然后在命令行中指定对应的GPU解码器。</p>
<p>例如，将h264编码的源视频转码为指定尺寸和码率的h264编码视频：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ffmpeg  -hwaccel cuvid -c:v h264_cuvid -i video&#x2F;video-H264-AAC.mkv -c:v h264_nvenc -b:v 2048k -vf scale_npp&#x3D;1280:-1 -y &#x2F;root&#x2F;transcode.mp4</span><br><span class="line"></span><br><span class="line">-hwaccel cuvid：指定使用cuvid硬件加速</span><br><span class="line">-c:v h264_cuvid：使用h264_cuvid进行视频解码</span><br><span class="line">-c:v h264_nvenc：使用h264_nvenc进行视频编码</span><br><span class="line">-vf scale_npp&#x3D;1280:-1：指定输出视频的宽高，注意，这里和软解码时使用的-vf scale&#x3D;x:x不一样</span><br><span class="line">转码期间使用nvidia-smi查看显卡状态，能够看到ffmpeg确实是在使用GPU进行转码：</span><br></pre></td></tr></table></figure>
<p>如果在执行命令的时候报错，则需要,进行nv-codec-headers和驱动的版本匹配的处理</p>
<p><img src="/images/drive.png" alt="drive.png"></p>
<p>我开始编译nv-codec-headers使用的是最新版本9.1的，编译出错，有两种方法，一种是升级drive的版本，升级到430以上，这个比较的麻烦，另一种是降低nv-codec-headers的版本，我降低到8.1版本，就可以成功</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ffmpeg 版本 ffmpeg version n4.1.1-3-g53f3f52</span><br><span class="line">cuda 版本 CUDA Version 10.0.130（这个版本自带驱动，可以不用安装驱动）</span><br><span class="line">drive 驱动版本 Driver Version: 410.48 </span><br><span class="line">nv-codec-headers 版本 sdk&#x2F;8.1</span><br></pre></td></tr></table></figure>
<h4 id="7-在容器中使用NVIDIA"><a href="#7-在容器中使用NVIDIA" class="headerlink" title="7,在容器中使用NVIDIA"></a>7,在容器中使用NVIDIA</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在将自己的服务打包成镜像的时候，开始没有设置环境变量，导致怎么都无法调用NVIDIA进行硬件的转码；</span><br><span class="line">最后查询了很多的资料，发现需要添加一个环境变量，在Dockfile中</span><br><span class="line">ENV NVIDIA_DRIVER_CAPABILITIES video,compute,utility</span><br><span class="line">才能保证容器中使用成功</span><br></pre></td></tr></table></figure>
<h4 id="8，gpu和cpu转码测试"><a href="#8，gpu和cpu转码测试" class="headerlink" title="8，gpu和cpu转码测试"></a>8，gpu和cpu转码测试</h4><p>​    对于同一个视频，分别采用cpu和GPU两种方式来进行转码，对比这两者之间的效率</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#机器信息</span><br><span class="line">逻辑核：24</span><br><span class="line">内存：64G</span><br><span class="line">24  Intel(R) Xeon(R) CPU E5-2620 v2 @ 2.10GHz</span><br><span class="line">系统：CentOS Linux release 7.6.1810 (Core)</span><br><span class="line">#视频信息：</span><br><span class="line">name: 11.mkv</span><br><span class="line">size： 1.1G</span><br><span class="line">Video: h264 (High), yuv420p(progressive), 1280x720 [SAR 1:1 DAR 16:9], 25 fps, 25 tbr, 1k tbn, 50 tbc (default)</span><br><span class="line">Audio: ac3, 48000 Hz, stereo, fltp, 192 kb&#x2F;s (default)</span><br><span class="line">#软件转码：</span><br><span class="line">[time] ffmpeg  -i video&#x2F;11.mkv -c:v libx264 -b:v 2048k -vf scale&#x3D;1280:-1 -y &#x2F;root&#x2F;transcode.mp4</span><br><span class="line">#结果</span><br><span class="line">real	11m18.807s</span><br><span class="line">user	180m16.290s</span><br><span class="line">sys		1m36.925s</span><br><span class="line">cpu占用	平均1600%</span><br><span class="line">[time] .&#x2F;softhw &#x2F;root&#x2F;video&#x2F;11.mkv &#x2F;opt&#x2F;nvitra1.mp4</span><br><span class="line">real	14m51.166s</span><br><span class="line">user	220m2.857s</span><br><span class="line">sys		1m21.718s</span><br><span class="line">cpu占用  平均1600%</span><br><span class="line">#硬件转码：</span><br><span class="line">[time] ffmpeg  -hwaccel cuvid -c:v h264_cuvid -i video&#x2F;11.mkv -c:v h264_nvenc -b:v 2048k -vf scale_npp&#x3D;1280:-1 -y &#x2F;root&#x2F;transcode.mp4</span><br><span class="line">#结果</span><br><span class="line">real	1m45.228s</span><br><span class="line">user	1m15.910s</span><br><span class="line">sys		0m18.734s</span><br><span class="line">cpu占用	平均90%</span><br><span class="line">[time] .&#x2F;hw &#x2F;root&#x2F;video&#x2F;11.mkv &#x2F;opt&#x2F;nvitra.mp4</span><br><span class="line">real	1m29.478s</span><br><span class="line">user	0m22.754s</span><br><span class="line">sys		0m23.465s</span><br><span class="line">cpu占用 50%</span><br></pre></td></tr></table></figure>
<h4 id="8，指定显卡进行转码"><a href="#8，指定显卡进行转码" class="headerlink" title="8，指定显卡进行转码"></a>8，指定显卡进行转码</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ffmpeg -hwaccel cuvid -hwaccel_device 0 -c:v h264_cuvid -i &lt;input&gt; -c:v h264_nvenc -b:v 2048k -vf scale_npp&#x3D;1280:-1 -y &lt;output&gt;</span><br><span class="line"></span><br><span class="line">ffmpeg -hwaccel cuvid -hwaccel_device 1 -c:v h264_cuvid -i &lt;input&gt; -c:v h264_nvenc -b:v 2048k -vf scale_npp&#x3D;1280:-1 -y &lt;output&gt;</span><br><span class="line"></span><br><span class="line">ffmpeg -hwaccel cuvid -hwaccel_device 0 -c:v h264_cuvid -i &#x2F;root&#x2F;source_media&#x2F;flv.flv -c:v h264_nvenc -b:v 2048k -vf scale_npp&#x3D;1280:-1  -y &#x2F;root&#x2F;flv.mp4</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Media</category>
        <category>video</category>
      </categories>
      <tags>
        <tag>ffmpeg</tag>
        <tag>GPU</tag>
      </tags>
  </entry>
  <entry>
    <title>ffmpeg-编码的步骤</title>
    <url>/article/3394448682.html</url>
    <content><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;总结一下编码的大致过程，方便自己下一次的处理，分为音频编码和视频</p>
<h3 id="音频编码的过程"><a href="#音频编码的过程" class="headerlink" title="音频编码的过程"></a>音频编码的过程</h3><h4 id="1，打开输出的文件流"><a href="#1，打开输出的文件流" class="headerlink" title="1，打开输出的文件流"></a>1，打开输出的文件流</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AVFormatContext *ofmt_ctx;</span><br><span class="line">avformat_alloc_output_context2(&amp;ofmt_ctx, NULL, NULL, filename);</span><br></pre></td></tr></table></figure>
<h4 id="2，创建输出的音频流"><a href="#2，创建输出的音频流" class="headerlink" title="2，创建输出的音频流"></a>2，创建输出的音频流</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AVStream *audioStream;</span><br><span class="line">AVCodec *encoder;</span><br><span class="line">AVCodecContext *enc_ctx;</span><br><span class="line">audioStream &#x3D; avformat_new_stream(ofmt_ctx, NULL);</span><br><span class="line">if (!audioStream)&#123;</span><br><span class="line">	av_log();</span><br><span class="line">&#125;</span><br><span class="line">encoder &#x3D; avcodec_find_encoder(AV_CODEC_ID_AAC);</span><br><span class="line">if(!encoder)&#123;</span><br><span class="line">	av_log();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="3，设置编码的上下文"><a href="#3，设置编码的上下文" class="headerlink" title="3，设置编码的上下文"></a>3，设置编码的上下文</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">enc_ctx &#x3D; avcodec_alloc_context3(encoder);</span><br><span class="line">if (!enc_ctx)&#123;</span><br><span class="line">	av_log();</span><br><span class="line">&#125;</span><br><span class="line">enc_ctx -&gt; bit_rate &#x3D; 64000;</span><br><span class="line">enc_ctx -&gt; sample_rate &#x3D; 44100;</span><br><span class="line">enc_ctx -&gt; channel_layout &#x3D; 2;&#x2F;&#x2F;这个可以根据输入来设置</span><br><span class="line">enc_ctx -&gt; channels &#x3D; av_get_channel_layout_nb_channels(enc_ctx -&gt; channel_layout);</span><br><span class="line">enc_ctx -&gt; sample_fmt &#x3D; encoder -&gt; sample_fmts[0];</span><br><span class="line">AVRational time_base &#x3D; &#123;1, enc_ctx -&gt; sample_rate&#125;;</span><br><span class="line">enc_ctx -&gt; time_base &#x3D; time_base;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="4，设置flag"><a href="#4，设置flag" class="headerlink" title="4，设置flag"></a>4，设置flag</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (ofmt_ctx -&gt; oformat -&gt; flags &amp; AVFMT_GLOBALHEADER)</span><br><span class="line">	enc_ctx -&gt; flags |&#x3D; AV_CODEC_FLAG_GLOBAL_HEADER;</span><br></pre></td></tr></table></figure>
<h4 id="5，打开编码器"><a href="#5，打开编码器" class="headerlink" title="5，打开编码器"></a>5，打开编码器</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ret &#x3D; avcodec_open2(enc_ctx, encoder, NULL);</span><br><span class="line">if (ret &lt; 0)&#123;</span><br><span class="line">	av_log();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="6，设置codec-tag"><a href="#6，设置codec-tag" class="headerlink" title="6，设置codec_tag"></a>6，设置codec_tag</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">audioStream -&gt; codecpar -&gt; codec_tag &#x3D; 0;</span><br></pre></td></tr></table></figure>
<h4 id="7，copy-code-to-stream"><a href="#7，copy-code-to-stream" class="headerlink" title="7，copy code to stream"></a>7，copy code to stream</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ret &#x3D; avcodec_parameters_from_context(audioStream -&gt; codecpar, enc_ctx);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Media</category>
        <category>video</category>
      </categories>
      <tags>
        <tag>ffmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title>ffmpeg-转码后丢帧的问题</title>
    <url>/article/3032443121.html</url>
    <content><![CDATA[<p>在生产环境的使用中，我们转码有时候会出现缺帧的情况，比如一个10s的视频，经过转码后只有了7s，这就是因为转码逻辑没有处理好，导致丢失了大量的帧。</p>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h5 id="ffmpeg提供了两组函数，分别用于编码和解码："><a href="#ffmpeg提供了两组函数，分别用于编码和解码：" class="headerlink" title="ffmpeg提供了两组函数，分别用于编码和解码："></a>ffmpeg提供了两组函数，分别用于编码和解码：</h5><ul>
<li>解码：<code>avcodec_send_packet()</code>、<code>avcodec_receive_frame()</code></li>
<li>编码：<code>avcodec_send_frame()</code>、<code>avcodec_receive_packet()</code></li>
</ul>
<h5 id="在一个循环体内去接收codec的输出"><a href="#在一个循环体内去接收codec的输出" class="headerlink" title="在一个循环体内去接收codec的输出"></a>在一个循环体内去接收codec的输出</h5><p>即周期性地调用<code>avcodec_receive_()</code>来接收codec输出的数据：</p>
<ul>
<li><p><strong>解码</strong>：调用<code>avcodec_receive_frame()</code>，如果成功会返回一个包含未压缩数据的<code>AVFrame</code>。</p>
</li>
<li><p><strong>编码</strong>：调用<code>avcodec_receive_packet()</code>，如果成功会返回一个包含压缩数据的<code>AVPacket</code>。</p>
</li>
<li><p><strong>反复</strong>地调用<code>avcodec_receive_packet()</code>直到返回 <code>AVERROR(EAGAIN)</code>或其他错误。返回<code>AVERROR(EAGAIN)</code>错误表示codec需要新的输入来输出更多的数据。对于每个输入的packet或frame，codec一般会输出一个frame或packet，<strong>但是也有可能输出0个或者多于1个</strong>。部分代码实例：</p>
</li>
<li><p>~~~cpp<br>1514     while(true){<br>  1515         //对于每个输入的packet或者frame，codec一般会输出一个frame或者packet，但是也有可能输出0个或者多于1个<br>  1516         //对于多于1个的情况，我们使用while来解决<br>  1517         error = avcodec_receive_packet(encCtx, &amp;outputPacket);<br>  1518         if (error == AVERROR(EAGAIN)) {<br>  1519             error = 0;<br>  1520             // cout &lt;&lt; “EAGAIN” &lt;&lt; endl;<br>  1521             goto cleanup;<br>  1522         } else if (error == AVERROR_EOF) {<br>  1523             error = 0;<br>  1524             goto cleanup;<br>  1525         } else if (error &lt; 0) {<br>  1526             av_log(NULL, AV_LOG_ERROR, “Could not encode frame\n”);<br>  1527             goto cleanup;<br>  1528         } else {<br>  1529             <em>dataPresent = 1;<br>  1530         }<br>  1531<br>  1532         outputPacket.stream_index = streamIndex;<br>  1533<br>  1534         //转换pts<br>  1535         av_packet_rescale_ts(&amp;outputPacket, encCtx-&gt;time_base,<br>  1536                              ofmtCtx-&gt;streams[streamIndex]-&gt;time_base);<br>  1537<br>  1538         // if (AVMEDIA_TYPE_AUDIO == encCtx -&gt; codec_type){<br>  1539         //  _pts2ms = outputPacket.pts </em>av_q2d(ofmtCtx -&gt; streams[streamIndex] -&gt;<br>  1540         // time_base) <em> 1000 ;//单位ms(微妙)<br>  1541         //}<br>  1542         //_pts2ms = outputPacket.pts </em>av_q2d(ofmtCtx -&gt; streams[streamIndex] -&gt;<br>  1543         // time_base) <em> 1000 ;//单位ms(微妙)<br>  1544         pts2ms = outputPacket.pts </em><br>  1545                  av_q2d(ofmtCtx-&gt;streams[streamIndex]-&gt;time_base) <em><br>  1546                  1000;  //单位ms(微妙)<br>  1547                         //编码视频和音频的时候，两者的时间是不一样的，为了保证进度一直向前，所以取最大值<br>  1548         if (pts2ms &gt; _pts2ms) _pts2ms = pts2ms;<br>  1549         av_log(NULL, AV_LOG_INFO, “progress: %s\n”, printProgress().c_str());<br>  1550         sendProgress();<br>  1551         if (!_ip.empty()) printProgress(_ip, _port);<br>  1552<br>  1553         if (</em>dataPresent &amp;&amp;<br>  1554             (error = av_interleaved_write_frame(ofmtCtx, &amp;outputPacket)) &lt; 0) {<br>  1555             av_log(NULL, AV_LOG_ERROR, “Could not write frame,%s,%s:%d\n”,<br>  1556                    av_err2str(error), <strong>FILE</strong>, <strong>LINE</strong>);<br>  1557             goto cleanup;<br>  1558         }<br>  1559     }   </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 流处理结束的时候需要flush（洗刷） codec。因为codec可能在内部缓冲多个frame或packet，出于性能或其他必要的情况（如考虑B帧的情况）。 处理流程如下：</span><br><span class="line"></span><br><span class="line">  1. 调用&#96;avcodec_send_()&#96;传入的AVFrame或AVPacket指针设置为NULL。 这将开启draining mode（排水模式）</span><br><span class="line"></span><br><span class="line">     ~~~cpp</span><br><span class="line">       1653     int dataWritten;</span><br><span class="line">       1654     int ret;       </span><br><span class="line">       1655     if (NULL !&#x3D; output-&gt;videoStream) &#123;</span><br><span class="line">       1656         do &#123;       </span><br><span class="line">       1657             dataWritten &#x3D; 0;</span><br><span class="line">       1658             ret &#x3D; encodeMediaFrame(NULL, output-&gt;formatContext,</span><br><span class="line">       1659                                    output-&gt;videoCodecCtx, &amp;dataWritten,</span><br><span class="line">       1660                                    output-&gt;videoStream-&gt;index);</span><br><span class="line">       1661             if (0 &gt; ret) &#123;</span><br><span class="line">       1662                 av_log(NULL, AV_LOG_ERROR,</span><br><span class="line">       1663                        &quot;Failed whileflush video encode, %s:%d\n&quot;, __FILE__,</span><br><span class="line">       1664                        __LINE__);</span><br><span class="line">       1665                 return ret;</span><br><span class="line">       1666             &#125;      </span><br><span class="line">       1667             av_log(NULL, AV_LOG_INFO, &quot;flush video encoder data\n&quot;);</span><br><span class="line">       1668         &#125; while (dataWritten);</span><br><span class="line">       1669     &#125;  </span><br></pre></td></tr></table></figure>
<ol start="2">
<li><p>反复地调用<code>avcodec_receive_()</code>直到返回<code>AVERROR_EOF</code>的错误，这个方法这个时候不会返回<code>AVERROR(EAGAIN)</code>的错误，除非你忘记了开启draining mode</p>
</li>
<li><p>codec可以重新开启，但是需要先调用 <code>avcodec_flush_buffers()</code>来重置codec</p>
</li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>Media</category>
        <category>video</category>
      </categories>
      <tags>
        <tag>ffmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title>gcc-5.1.0源码安装</title>
    <url>/article/2230395924.html</url>
    <content><![CDATA[<p>对于一些源码的编译如poco库，需要的GCC的版本要求比较高，所以需要源码编译GCC、</p>
<h3 id="一，源码下载"><a href="#一，源码下载" class="headerlink" title="一，源码下载"></a>一，源码下载</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">地址：</span><br><span class="line">https:&#x2F;&#x2F;ftp.gnu.org&#x2F;gnu&#x2F;gcc&#x2F;</span><br><span class="line">gcc-5.1.0 可以支持C++14</span><br></pre></td></tr></table></figure>
<h3 id="二，依赖环境安装"><a href="#二，依赖环境安装" class="headerlink" title="二，依赖环境安装"></a>二，依赖环境安装</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd gcc-5.1.0</span><br><span class="line">.&#x2F;contrib&#x2F;download_prerequisites</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Building GCC requires GMP 4.2+, MPFR 2.4.0+ and MPC 0.8.0+</span><br><span class="line">地址：</span><br><span class="line">ftp:&#x2F;&#x2F;gcc.gnu.org&#x2F;pub&#x2F;gcc&#x2F;infrastructure&#x2F;</span><br><span class="line"></span><br><span class="line">wget ftp:&#x2F;&#x2F;gcc.gnu.org&#x2F;pub&#x2F;gcc&#x2F;infrastructure&#x2F;gmp-6.1.0.tar.bz2</span><br><span class="line">wget ftp:&#x2F;&#x2F;gcc.gnu.org&#x2F;pub&#x2F;gcc&#x2F;infrastructure&#x2F;mpfr-3.1.4.tar.bz2</span><br><span class="line">wget ftp:&#x2F;&#x2F;gcc.gnu.org&#x2F;pub&#x2F;gcc&#x2F;infrastructure&#x2F;mpc-1.0.3.tar.gz</span><br></pre></td></tr></table></figure>
<h3 id="三，依赖解压安装"><a href="#三，依赖解压安装" class="headerlink" title="三，依赖解压安装"></a>三，依赖解压安装</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1，安装gmp</span><br><span class="line">tar -jxvf gmp-6.1.0.tar.bz2</span><br><span class="line">cd gmp-6.1.0</span><br><span class="line">.&#x2F;configure</span><br><span class="line">make &amp;&amp; make install</span><br><span class="line"></span><br><span class="line">error:No usable m4 in $PATH or &#x2F;usr&#x2F;5bin</span><br><span class="line">yum install m4</span><br><span class="line"></span><br><span class="line">2,安装mpfr</span><br><span class="line">tar -jxvf mpfr-3.1.4.tar.bz2</span><br><span class="line">cd mpfr-3.1.4</span><br><span class="line">.&#x2F;configure</span><br><span class="line">make &amp;&amp; make install</span><br><span class="line"></span><br><span class="line">3,安装mpc</span><br><span class="line">tar -zxvf mpc-1.0.3.tar.gz</span><br><span class="line">cd mpc-1.0.3</span><br><span class="line">.&#x2F;configure</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>
<h3 id="四，源码安装"><a href="#四，源码安装" class="headerlink" title="四，源码安装"></a>四，源码安装</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;configure  --enable-checking&#x3D;release --enable-languages&#x3D;c,c++ --disable-multilib</span><br><span class="line">make </span><br><span class="line">make install</span><br><span class="line"></span><br><span class="line">#将链接复制</span><br><span class="line">cp -vf &#x2F;usr&#x2F;local&#x2F;lib64&#x2F;libstdc++.*  &#x2F;usr&#x2F;lib64&#x2F;</span><br><span class="line">gcc -v</span><br><span class="line">gcc version 5.1.0 (GCC)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Cpp</category>
        <category>gcc</category>
      </categories>
      <tags>
        <tag>gcc</tag>
      </tags>
  </entry>
  <entry>
    <title>git-大文件上传管理</title>
    <url>/article/3538252460.html</url>
    <content><![CDATA[<h3 id="git-lfs安装和配置"><a href="#git-lfs安装和配置" class="headerlink" title="git lfs安装和配置"></a>git lfs安装和配置</h3><p>git lfs 需要客户端支持, 请根据自己的操作系统下载对应的客户端</p>
<p><a href="https://git-lfs.github.com/">git lfs客户端下载</a></p>
<p><code>以Centos7为例，下载客户端后运行rpm安装</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpm -i git-lfs-2.2.1-1.el7.x86_64.rpm</span><br><span class="line">git lfs install（完成初始化）</span><br></pre></td></tr></table></figure>
<h3 id="设置管理的文件类型"><a href="#设置管理的文件类型" class="headerlink" title="设置管理的文件类型"></a>设置管理的文件类型</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#压缩包</span><br><span class="line">git lfs track *.tar *.tar.gz *.tgz *.zip *.7z</span><br><span class="line">#图片</span><br><span class="line">git lfs track *.jpg *.png *.jpeg *.bmp *.gif *.tiff</span><br><span class="line">#库</span><br><span class="line">git lfs track *.jar *.war *.so *.so.*</span><br><span class="line">#非文本文档</span><br><span class="line">git  lfs  track *.doc *.docx *.ppt *.pptx *.pdf *.xls *.xlsx</span><br><span class="line">#安装包</span><br><span class="line">git  lfs  track *.rpm *.deb *.img *.iso</span><br></pre></td></tr></table></figure>
<p><code>设置完之后会在项目根目录下出现.gitattributes文件</code></p>
]]></content>
      <categories>
        <category>Tool</category>
        <category>git</category>
      </categories>
      <tags>
        <tag>lfs</tag>
      </tags>
  </entry>
  <entry>
    <title>git-常用的命令</title>
    <url>/article/2063445917.html</url>
    <content><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;记录一些git常用的命令，便于在长时间不用时能够有个地方查阅，下面的几个是经常用到的。在windows下使用git，许多朋友都说无法使用一些状态（修改，保存，提交）图标，是因为图标显示不是git本身的功能呢，我们需要下载TortoiseGit才能使用图标。</p>
<h3 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h3><h5 id="重命名文件夹"><a href="#重命名文件夹" class="headerlink" title="重命名文件夹"></a>重命名文件夹</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git  mv -f oldfolder newfolder</span><br></pre></td></tr></table></figure>
<h5 id="删除新增的多个文件"><a href="#删除新增的多个文件" class="headerlink" title="删除新增的多个文件"></a>删除新增的多个文件</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clean -xdf</span><br></pre></td></tr></table></figure>
<h3 id="提交管理"><a href="#提交管理" class="headerlink" title="提交管理"></a>提交管理</h3><h5 id="删除中间的某次提交"><a href="#删除中间的某次提交" class="headerlink" title="删除中间的某次提交"></a>删除中间的某次提交</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git revert commit id</span><br></pre></td></tr></table></figure>
<h5 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git reset --hard commitid</span><br><span class="line">这个不会保留之前的记录</span><br></pre></td></tr></table></figure>
<h5 id="撤销本地提交"><a href="#撤销本地提交" class="headerlink" title="撤销本地提交"></a>撤销本地提交</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git reset --soft commitid</span><br><span class="line">git reset --mixed commitid</span><br><span class="line">两者的区别，--soft会将改动放在缓存区 --mixed不会讲改动放在缓存区</span><br></pre></td></tr></table></figure>
<h5 id="撤销远程的提交"><a href="#撤销远程的提交" class="headerlink" title="撤销远程的提交"></a>撤销远程的提交</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git log</span><br><span class="line">git reset --hard commitid</span><br><span class="line">git push origin HEAD:master --force</span><br></pre></td></tr></table></figure>
<h5 id="强制提交"><a href="#强制提交" class="headerlink" title="强制提交"></a>强制提交</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push -u origin master -f</span><br></pre></td></tr></table></figure>
<h3 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h3><h5 id="将某个分支的提交copy到另一个分支上"><a href="#将某个分支的提交copy到另一个分支上" class="headerlink" title="将某个分支的提交copy到另一个分支上"></a>将某个分支的提交copy到另一个分支上</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例如，有两个分支，a,b,想要将a的某次提交，copy到b分支上</span><br><span class="line">1,在a分支上 git log 查询commitid</span><br><span class="line">2,git checkout b  切换分支</span><br><span class="line">3,git cherry-pick commitid</span><br></pre></td></tr></table></figure>
<h5 id="统计当前分支的提交数目"><a href="#统计当前分支的提交数目" class="headerlink" title="统计当前分支的提交数目"></a>统计当前分支的提交数目</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git rev-list HEAD | wc -l</span><br></pre></td></tr></table></figure>
<h5 id="删除缓存的远程分支列表"><a href="#删除缓存的远程分支列表" class="headerlink" title="删除缓存的远程分支列表"></a>删除缓存的远程分支列表</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote prune origin</span><br><span class="line">or</span><br><span class="line">git fetch -p</span><br></pre></td></tr></table></figure>
<h3 id="stash管理"><a href="#stash管理" class="headerlink" title="stash管理"></a>stash管理</h3><h5 id="冻结当前的分支修改"><a href="#冻结当前的分支修改" class="headerlink" title="冻结当前的分支修改"></a>冻结当前的分支修改</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git stash save &quot;说明信息选填&quot;</span><br></pre></td></tr></table></figure>
<h5 id="列出所有的工作现场存储"><a href="#列出所有的工作现场存储" class="headerlink" title="列出所有的工作现场存储"></a>列出所有的工作现场存储</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git stash list</span><br></pre></td></tr></table></figure>
<h5 id="恢复某个工作现场"><a href="#恢复某个工作现场" class="headerlink" title="恢复某个工作现场"></a>恢复某个工作现场</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git stash apply stash@&#123;n&#125;</span><br></pre></td></tr></table></figure>
<h5 id="删除存储的某个工作现场"><a href="#删除存储的某个工作现场" class="headerlink" title="删除存储的某个工作现场"></a>删除存储的某个工作现场</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git stash drop stash@&#123;n&#125;</span><br></pre></td></tr></table></figure>
<h5 id="恢复的同时把stash内容也删除了"><a href="#恢复的同时把stash内容也删除了" class="headerlink" title="恢复的同时把stash内容也删除了"></a>恢复的同时把stash内容也删除了</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git stash pop stash@&#123;n&#125; </span><br></pre></td></tr></table></figure>
<h3 id="config"><a href="#config" class="headerlink" title="config"></a>config</h3><h5 id="解决git-clone-项目中某个文件都需要输入密码"><a href="#解决git-clone-项目中某个文件都需要输入密码" class="headerlink" title="解决git clone 项目中某个文件都需要输入密码"></a>解决git clone 项目中某个文件都需要输入密码</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global credential.helper store</span><br></pre></td></tr></table></figure>
<h5 id="配置邮件和用户名"><a href="#配置邮件和用户名" class="headerlink" title="配置邮件和用户名"></a>配置邮件和用户名</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global user.email &quot;xxx&quot;</span><br><span class="line">git config --global user.name &quot;xxx&quot;</span><br></pre></td></tr></table></figure>
<h3 id="tag管理"><a href="#tag管理" class="headerlink" title="tag管理"></a>tag管理</h3><h5 id="列出本地标签"><a href="#列出本地标签" class="headerlink" title="列出本地标签"></a>列出本地标签</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git tag</span><br></pre></td></tr></table></figure>
<h5 id="切换到某个tag"><a href="#切换到某个tag" class="headerlink" title="切换到某个tag"></a>切换到某个tag</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout tagName</span><br></pre></td></tr></table></figure>
<h5 id="本地打标签-a-指定标签名，-m-指定说明文字"><a href="#本地打标签-a-指定标签名，-m-指定说明文字" class="headerlink" title="本地打标签 -a 指定标签名， -m 指定说明文字"></a>本地打标签 -a 指定标签名， -m 指定说明文字</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git  tag -a v4.1.1 -m &quot;删除临时文件&quot;</span><br></pre></td></tr></table></figure>
<h5 id="本地tag推送到远程"><a href="#本地tag推送到远程" class="headerlink" title="本地tag推送到远程"></a>本地tag推送到远程</h5><h6 id="单一"><a href="#单一" class="headerlink" title="单一"></a>单一</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push origin tagName</span><br><span class="line">#</span><br><span class="line">git push origin v4.1.1</span><br></pre></td></tr></table></figure>
<h6 id="多个"><a href="#多个" class="headerlink" title="多个"></a>多个</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push --tags</span><br></pre></td></tr></table></figure>
<h5 id="删除远程tag"><a href="#删除远程tag" class="headerlink" title="删除远程tag"></a>删除远程tag</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push origin --delete tag tagName</span><br></pre></td></tr></table></figure>
<h5 id="删除本地tag"><a href="#删除本地tag" class="headerlink" title="删除本地tag"></a>删除本地tag</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git tag -d tagName</span><br></pre></td></tr></table></figure>
<h5 id="拉取tag到本地"><a href="#拉取tag到本地" class="headerlink" title="拉取tag到本地"></a>拉取tag到本地</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git fetch origin tag tagName</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Tool</category>
        <category>git</category>
      </categories>
      <tags>
        <tag>cmd</tag>
      </tags>
  </entry>
  <entry>
    <title>github-解决GitHub clone慢的问题</title>
    <url>/article/814027255.html</url>
    <content><![CDATA[<p>哎，有时候自己在GitHub上下载东西的时候总是很慢，这里记载一下几个加快的方法</p>
<h3 id="使用gitee码云来进行clone"><a href="#使用gitee码云来进行clone" class="headerlink" title="使用gitee码云来进行clone"></a>使用gitee码云来进行clone</h3><p>将需要clone的项目，先转移到码云上，然后通过码云来下载本地，速度很快；</p>
<h3 id="修改hosts"><a href="#修改hosts" class="headerlink" title="修改hosts"></a>修改hosts</h3><p>通过<a href="https://www.ipaddress.com/">查询IP地址网站</a>查询下面两个域名的IP地址</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">github.global.ssl.fastly.net</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">github.com</span><br></pre></td></tr></table></figure>
<h5 id="在linux上-vim-etc-hosts"><a href="#在linux上-vim-etc-hosts" class="headerlink" title="在linux上  vim /etc/hosts"></a>在linux上  vim /etc/hosts</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">199.232.69.194 github.global.ssl.fastly.net</span><br><span class="line">140.82.113.3 github.com</span><br></pre></td></tr></table></figure>
<h5 id="在Windows上-修改-C-Windows-System32-drivers-etc-hosts"><a href="#在Windows上-修改-C-Windows-System32-drivers-etc-hosts" class="headerlink" title="在Windows上 修改 C:\Windows\System32\drivers\etc\hosts"></a>在Windows上 修改 C:\Windows\System32\drivers\etc\hosts</h5><ol>
<li><p>对于Windows下的hosts执行需要权限，我们可以将其先拷贝到桌面，修改后再copy回去</p>
</li>
<li><p>打开cmd命令行，执行下面的命令</p>
</li>
<li><p>~~~<br>ipconfig/flushdns</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">### 设置代理</span><br><span class="line"></span><br><span class="line">​	推荐有代理的使用，作为一名开发，经常需要Google，要不自己搭建一个梯子，要不就是买一个。我们在github上clone的时候可以设置代理。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>git config –global https.proxy <a href="http://127.0.0.1:1080">http://127.0.0.1:1080</a></p>
<p>git config –global https.proxy <a href="https://127.0.0.1:1080">https://127.0.0.1:1080</a></p>
<p>git config –global –unset http.proxy</p>
<p>git config –global –unset https.proxy</p>
<p>~~~</p>
]]></content>
      <categories>
        <category>Tool</category>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>grpc编译</title>
    <url>/article/1473358207.html</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">环境 centos7</span><br></pre></td></tr></table></figure>
<h2 id="一，安装编译依赖的环境"><a href="#一，安装编译依赖的环境" class="headerlink" title="一，安装编译依赖的环境"></a>一，安装编译依赖的环境</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install -y pkgconfig autoconf automake libtool make gcc-c++ unzip</span><br><span class="line">yum install -y gflags-devel gtest-devel clang libcxx-devel</span><br><span class="line">yum install -y openssl  openssl-devel</span><br><span class="line">yum install -y  libunwind libunwind-devel</span><br><span class="line">yum install -y epel-release</span><br><span class="line">yum install -y golang</span><br></pre></td></tr></table></figure>
<h2 id="二，源码下载"><a href="#二，源码下载" class="headerlink" title="二，源码下载"></a>二，源码下载</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;grpc&#x2F;grpc.git</span><br><span class="line">cd grpc</span><br><span class="line">git submodule update --init</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="三，编译"><a href="#三，编译" class="headerlink" title="三，编译"></a>三，编译</h2><h4 id="1，编译cmake"><a href="#1，编译cmake" class="headerlink" title="1，编译cmake"></a>1，编译cmake</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">需要下载cmake高级版本，yum安装的版本太低</span><br><span class="line">https:&#x2F;&#x2F;cmake.org&#x2F;download&#x2F;</span><br><span class="line">源码安装cmake，</span><br><span class="line">（1）删除原来版本的cmake</span><br><span class="line">（2）.&#x2F;configure</span><br><span class="line">（3）make &amp;&amp; make install</span><br><span class="line">如果找不到，则创建软链接</span><br><span class="line">ln -s &#x2F;usr&#x2F;local&#x2F;bin&#x2F;cmake &#x2F;usr&#x2F;bin&#x2F;cmake</span><br></pre></td></tr></table></figure>
<h4 id="2，先编译protobuf"><a href="#2，先编译protobuf" class="headerlink" title="2，先编译protobuf"></a>2，先编译protobuf</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd third_party&#x2F;protobuf</span><br><span class="line">git submodule update --init --recursive</span><br><span class="line">.&#x2F;autogen.sh</span><br><span class="line">.&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;helios&#x2F;protobuf</span><br><span class="line">make </span><br><span class="line">make check</span><br><span class="line">make install</span><br><span class="line">2,建立软链接</span><br><span class="line">ln -s &#x2F;usr&#x2F;local&#x2F;helios&#x2F;protobuf&#x2F;bin&#x2F;protoc &#x2F;usr&#x2F;local&#x2F;bin&#x2F;protoc</span><br><span class="line">检测是否安装成功</span><br><span class="line">protoc --version</span><br></pre></td></tr></table></figure>
<h4 id="3，编译grpc（cmake"><a href="#3，编译grpc（cmake" class="headerlink" title="3，编译grpc（cmake)"></a>3，编译grpc（cmake)</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd grpc</span><br><span class="line">mkdir -p  cmake&#x2F;build</span><br><span class="line">cmake -DBUILD_SHARED_LIBS&#x3D;on -DCMAKE_INSTALL_PREFIX&#x3D;&#x2F;usr&#x2F;local&#x2F;helios&#x2F;grpc -DCMAKE_BUILD_TYPE&#x3D;DEBUG -Wno-dev ..&#x2F;..&#x2F;</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<h4 id="4，编译（make-不建议使用）"><a href="#4，编译（make-不建议使用）" class="headerlink" title="4，编译（make,不建议使用）"></a>4，编译（make,不建议使用）</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2,编译grpc</span><br><span class="line">cd grpc根目录</span><br><span class="line">make -j 4</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<h4 id="5，问题"><a href="#5，问题" class="headerlink" title="5，问题"></a>5，问题</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">对于cpp的使用，当编译好了之后，运行helloworld程序，没有响应，有很大的问题</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;grpc&#x2F;grpc&#x2F;issues&#x2F;21280#issuecomment-558164977</span><br><span class="line"></span><br><span class="line">解决方法：修改源码（不使用）</span><br><span class="line">vim &#x2F; src &#x2F; core &#x2F; lib &#x2F; surface &#x2F; init.cc</span><br><span class="line"></span><br><span class="line">diff --git a&#x2F;src&#x2F;core&#x2F;lib&#x2F;surface&#x2F;init.cc b&#x2F;src&#x2F;core&#x2F;lib&#x2F;surface&#x2F;init.cc</span><br><span class="line">index 2812427f7a..3c6a547b20 100644</span><br><span class="line">--- a&#x2F;src&#x2F;core&#x2F;lib&#x2F;surface&#x2F;init.cc</span><br><span class="line">+++ b&#x2F;src&#x2F;core&#x2F;lib&#x2F;surface&#x2F;init.cc</span><br><span class="line">@@ -156,7 +156,7 @@ void grpc_init(void) &#123;</span><br><span class="line">      * at the appropriate time *&#x2F;</span><br><span class="line">     grpc_register_security_filters();</span><br><span class="line">     register_builtin_channel_init();</span><br><span class="line">-    grpc_tracer_init();将源码中的这个给注销</span><br><span class="line">+    &#x2F;&#x2F; grpc_tracer_init();</span><br><span class="line">     &#x2F;* no more changes to channel init pipelines *&#x2F;</span><br><span class="line">     grpc_channel_init_finalize();</span><br><span class="line">     grpc_iomgr_start();</span><br><span class="line">     </span><br><span class="line">修改源码：</span><br><span class="line">vim src&#x2F;core&#x2F;lib&#x2F;debug&#x2F;trace.cc</span><br><span class="line"> void TraceFlagList::Add(TraceFlag* flag) &#123;</span><br><span class="line">+  TraceFlag* t;</span><br><span class="line">+  for (t &#x3D; root_tracer_; t; t &#x3D; t -&gt; next_tracer_) &#123;</span><br><span class="line">+       if (t &#x3D;&#x3D; flag ) return;</span><br><span class="line">+  &#125;</span><br><span class="line">   flag-&gt;next_tracer_ &#x3D; root_tracer_;</span><br><span class="line">   root_tracer_ &#x3D; flag;</span><br><span class="line">遍历链表，如果存在则不加入</span><br></pre></td></tr></table></figure>
<h4 id="6，运行helloworld程序"><a href="#6，运行helloworld程序" class="headerlink" title="6，运行helloworld程序"></a>6，运行helloworld程序</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd examples&#x2F;cpp&#x2F;helloworld</span><br><span class="line">make</span><br><span class="line"></span><br><span class="line">出现问题：</span><br><span class="line">which: no grpc_cpp_plugin in (&#x2F;usr&#x2F;local&#x2F;sbin:&#x2F;usr&#x2F;local&#x2F;bin:&#x2F;usr&#x2F;sbin:&#x2F;usr&#x2F;bin:&#x2F;root&#x2F;bin)</span><br><span class="line">因为自己配置的路径，所以先给grpc_cpp_plugin  建立软连接</span><br><span class="line">ln -s &#x2F;usr&#x2F;local&#x2F;helios&#x2F;grpc&#x2F;bin&#x2F;grpc_cpp_plugin   &#x2F;usr&#x2F;local&#x2F;bin&#x2F;grpc_cpp_plugin</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">helloworld.pb.h:10:40: fatal error: google&#x2F;protobuf&#x2F;port_def.inc: No such file or directory</span><br><span class="line">配置cpp头文件路径</span><br><span class="line">export CPLUS_INCLUDE_PATH&#x3D;$CPLUS_INCLUDE_PATH:&#x2F;usr&#x2F;local&#x2F;helios&#x2F;grpc&#x2F;include</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Package protobuf was not found in the pkg-config search path.</span><br><span class="line">Perhaps you should add the directory containing &#96;protobuf.pc&#39;</span><br><span class="line">to the PKG_CONFIG_PATH environment variable</span><br><span class="line">No package &#39;protobuf&#39; found</span><br><span class="line">Package grpc was not found in the pkg-config search path.</span><br><span class="line">Perhaps you should add the directory containing &#96;grpc.pc&#39;</span><br><span class="line">to the PKG_CONFIG_PATH environment variable</span><br><span class="line">No package &#39;grpc&#39; found</span><br><span class="line">配置pkgconfig搜索路径</span><br><span class="line">export PKG_CONFIG_PATH&#x3D;$PKG_CONFIG_PATH:&#x2F;usr&#x2F;local&#x2F;helios&#x2F;protobuf&#x2F;lib&#x2F;pkgconfig&#x2F;:&#x2F;usr&#x2F;local&#x2F;helios&#x2F;grpc&#x2F;lib&#x2F;pkgconfig&#x2F;</span><br><span class="line"></span><br><span class="line">error while loading shared libraries: libgrpc_plugin_support.so.1: cannot open shared object file</span><br><span class="line">配置cpp动态库搜索路径</span><br><span class="line">export LD_LIBRARY_PATH&#x3D;$LD_LIBRARY_PATH:&#x2F;usr&#x2F;local&#x2F;helios&#x2F;grpc&#x2F;lib&#x2F;:&#x2F;usr&#x2F;local&#x2F;helios&#x2F;grpc&#x2F;lib64&#x2F;:&#x2F;usr&#x2F;local&#x2F;helios&#x2F;protobuf&#x2F;lib</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Cpp</category>
        <category>protocol</category>
      </categories>
      <tags>
        <tag>grpc</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/article/1243066710.html</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>hexo-gulp压缩</title>
    <url>/article/2127593710.html</url>
    <content><![CDATA[<h3 id="插件安装"><a href="#插件安装" class="headerlink" title="插件安装"></a>插件安装</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#全局安装</span><br><span class="line">npm install gulp -g</span><br><span class="line">#站点目录安装</span><br><span class="line">npm install gulp-htmlclean gulp-htmlmin gulp-minify-css gulp-uglify --save</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在这里说明一下，使用该工具可以压缩 HTML、CSS、JavaScript 文件，但我并没有压缩 JavaScript 文件，因为有很大的概率会报错，实际也并不需要压缩，因为大部分 JavaScript 都已压缩过。</p>
<p>如果你也考虑不压缩 JavaScript 文件，可以选择不安装 <code>gulp-uglify</code>。</p>
<h3 id="gulpfile-js"><a href="#gulpfile-js" class="headerlink" title="gulpfile.js"></a>gulpfile.js</h3><p>在站点文件夹的根目录下，新建一个文件。命名为gulpfile.js</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var gulp &#x3D; require(&#39;gulp&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Plugins 模块获取</span><br><span class="line">var minifycss &#x3D; require(&#39;gulp-minify-css&#39;);</span><br><span class="line">var uglify &#x3D; require(&#39;gulp-uglify&#39;);</span><br><span class="line">var htmlmin &#x3D; require(&#39;gulp-htmlmin&#39;);</span><br><span class="line">var htmlclean &#x3D; require(&#39;gulp-htmlclean&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 压缩 css</span><br><span class="line">gulp.task(&#39;minify-css&#39;, function () &#123;</span><br><span class="line">	return gulp.src(&#39;.&#x2F;public&#x2F;**&#x2F;*.css&#39;)</span><br><span class="line">		.pipe(minifycss())</span><br><span class="line">		.pipe(gulp.dest(&#39;.&#x2F;public&#39;));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 压缩 html</span><br><span class="line">gulp.task(&#39;minify-html&#39;, function () &#123;</span><br><span class="line">	return gulp.src(&#39;.&#x2F;public&#x2F;**&#x2F;*.html&#39;)</span><br><span class="line">		.pipe(htmlclean())</span><br><span class="line">		.pipe(htmlmin(&#123;</span><br><span class="line">			removeComments: true,</span><br><span class="line">			minifyJS: true,</span><br><span class="line">			minifyCSS: true,</span><br><span class="line">			minifyURLs: true,</span><br><span class="line">		&#125;))</span><br><span class="line">		.pipe(gulp.dest(&#39;.&#x2F;public&#39;))</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 压缩 js 不压缩 min.js</span><br><span class="line">gulp.task(&#39;minify-js&#39;, function () &#123;</span><br><span class="line">	return gulp.src([&#39;.&#x2F;public&#x2F;**&#x2F;*.js&#39;, &#39;!.&#x2F;public&#x2F;**&#x2F;*.min.js&#39;])</span><br><span class="line">		.pipe(uglify())</span><br><span class="line">		.pipe(gulp.dest(&#39;.&#x2F;public&#39;));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 4.0 以前的写法 </span><br><span class="line">&#x2F;&#x2F; gulp.task(&#39;default&#39;, [</span><br><span class="line">  &#x2F;&#x2F;   &#39;minify-html&#39;, &#39;minify-css&#39;, &#39;minify-js&#39;</span><br><span class="line">&#x2F;&#x2F; ]);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 4.0 以后的写法</span><br><span class="line">&#x2F;&#x2F; 执行 gulp 命令时执行的任务</span><br><span class="line">gulp.task(&#39;default&#39;, gulp.parallel(&#39;minify-html&#39;, &#39;minify-css&#39;, &#39;minify-js&#39;));</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>如果不压缩 JavaScript 文件，则将上述代码中有关</code>minify-js<code>的代码删除即可</code></p>
<h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[10:24:57] Starting &#39;default&#39;...</span><br><span class="line">[10:24:57] Starting &#39;minify-html&#39;...</span><br><span class="line">[10:24:57] Starting &#39;minify-css&#39;...</span><br><span class="line">[10:24:57] Starting &#39;minify-js&#39;...</span><br><span class="line">[10:25:05] Finished &#39;minify-css&#39; after 8.3 s</span><br><span class="line">[10:25:05] Finished &#39;minify-js&#39; after 8.49 s</span><br><span class="line">[10:25:09] Finished &#39;minify-html&#39; after 12 s</span><br><span class="line">[10:25:09] Finished &#39;default&#39; after 12 s</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Tool</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>gulp</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo-next主题配置</title>
    <url>/article/1968653668.html</url>
    <content><![CDATA[<p>主要记录一下自己在搭建个人博客的时候，一些配置，基本上是查阅别人的文章，这里记录一下</p>
<h3 id="hexo安装"><a href="#hexo安装" class="headerlink" title="hexo安装"></a>hexo安装</h3><p><a href="https://www.jianshu.com/p/eded1dd2d794">hexo安装</a></p>
<p><a href="https://www.jianshu.com/p/b20fc983005f">next主题设置</a></p>
<h3 id="next主题设置"><a href="#next主题设置" class="headerlink" title="next主题设置"></a>next主题设置</h3><p>​    next主题的设置都是在<code>next/_config.yml</code>中设置。</p>
<h4 id="添加LocalSearch搜索"><a href="#添加LocalSearch搜索" class="headerlink" title="添加LocalSearch搜索"></a>添加LocalSearch搜索</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> npm install hexo-generator-searchdb --save</span><br><span class="line"> 编辑主题配置文件，启用本地搜素</span><br><span class="line"> # Local search</span><br><span class="line">local_search:</span><br><span class="line">  enable: true</span><br></pre></td></tr></table></figure>
<h4 id="网站访问量统计"><a href="#网站访问量统计" class="headerlink" title="网站访问量统计"></a>网站访问量统计</h4><p><img src="/images/blog/baidu.png" alt="baidu.png"></p>
<h4 id="阅读次数统计"><a href="#阅读次数统计" class="headerlink" title="阅读次数统计"></a>阅读次数统计</h4><p><a href="https://www.cnblogs.com/lijianming180/p/12433189.html">LeanCloud添加阅读次数</a></p>
<h4 id="添加评论"><a href="#添加评论" class="headerlink" title="添加评论"></a>添加评论</h4><p><a href="https://blog.csdn.net/jiunian_2761/article/details/97388997">valine</a></p>
<h4 id="域名申请"><a href="#域名申请" class="headerlink" title="域名申请"></a>域名申请</h4><p><a href="https://blog.csdn.net/linshuhe1/article/details/73013730">域名申请</a></p>
<h4 id="谷歌检索"><a href="#谷歌检索" class="headerlink" title="谷歌检索"></a>谷歌检索</h4><p><a href="https://www.itrhx.com/2019/09/17/A48-submit-search-engine-inclusion/">谷歌检索</a></p>
<h4 id="永久文章链接"><a href="#永久文章链接" class="headerlink" title="永久文章链接"></a>永久文章链接</h4><p><a href="https://www.jianshu.com/p/c7de2ae59975">abbrlink</a></p>
<h4 id="404"><a href="#404" class="headerlink" title="404"></a>404</h4><p><a href="https://www.jianshu.com/p/2349c763cc02">404错误</a></p>
<h4 id="码云-GitHub部署"><a href="#码云-GitHub部署" class="headerlink" title="码云+GitHub部署"></a>码云+GitHub部署</h4><p><img src="/images/blog/gitee.png" alt="gitee.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">需要在站点配置文件中配置gitee和GitHub的仓库地址</span><br><span class="line">然后就可以部署了，不过我们在gitee上部署后，每次都需要手动的去更新gitee page，才能生效</span><br></pre></td></tr></table></figure>
<h4 id="图片浏览放大功能fancybox"><a href="#图片浏览放大功能fancybox" class="headerlink" title="图片浏览放大功能fancybox"></a>图片浏览放大功能fancybox</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd next&#x2F;source&#x2F;lib</span><br><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;theme-next-fancybox3 fancybox</span><br><span class="line">#ps:注意fancybox和next&#x2F;_config.uml里面的名字保持一致</span><br><span class="line">更改next&#x2F;_config.uml文件；</span><br><span class="line">fancybox： true</span><br></pre></td></tr></table></figure>
<h4 id="文字数量和阅读时长"><a href="#文字数量和阅读时长" class="headerlink" title="文字数量和阅读时长"></a>文字数量和阅读时长</h4><ol>
<li><p>在博客目录下安装下面插件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-symbols-count-time --save</span><br></pre></td></tr></table></figure>
</li>
<li><p>在博客站点配置文件中添加</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#估算一篇文章需要阅读的时间       </span><br><span class="line">symbols_count_time:</span><br><span class="line">  symbols: true</span><br><span class="line">  time: true</span><br><span class="line">  total_symbols: true</span><br><span class="line">  total_time: true</span><br><span class="line">  exclude_codeblock: false</span><br><span class="line">  awl: 4</span><br><span class="line">  wpm: 275</span><br><span class="line">  suffix: &quot;mins.&quot;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="next7之后阅读全文设置"><a href="#next7之后阅读全文设置" class="headerlink" title="next7之后阅读全文设置"></a>next7之后阅读全文设置</h4><p>在博客目录下执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-excerpt --save</span><br></pre></td></tr></table></figure>
<p>在站点配置文件中添加</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#阅读全文</span><br><span class="line">excerpt:</span><br><span class="line">  depth: 1</span><br><span class="line">  excerpt_excludes: []</span><br><span class="line">  more_excludes: []</span><br><span class="line">  hideWholePostExcerpts: true</span><br></pre></td></tr></table></figure>
<p>在主题配置文件中将<code>excerpt_description</code>改为<code>true</code></p>
<h4 id="添加本站运行时间"><a href="#添加本站运行时间" class="headerlink" title="添加本站运行时间"></a>添加本站运行时间</h4><p>​    修改<strong>/blog/themes/next/layout/_partials/footer.swig</strong>文件，在末尾加入如下代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;br &#x2F;&gt; </span><br><span class="line">&lt;!-- 网站运行时间的设置 --&gt;</span><br><span class="line">&lt;span id&#x3D;&quot;timeDate&quot;&gt;载入天数...&lt;&#x2F;span&gt;</span><br><span class="line">&lt;span id&#x3D;&quot;times&quot;&gt;载入时分秒...&lt;&#x2F;span&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var now &#x3D; new Date();</span><br><span class="line">    function createtime() &#123;</span><br><span class="line">        var grt&#x3D; new Date(&quot;04&#x2F;21&#x2F;2019 15:54:40&quot;);&#x2F;&#x2F;此处修改你的建站时间或者网站上线时间</span><br><span class="line">        now.setTime(now.getTime()+250);</span><br><span class="line">        days &#x3D; (now - grt ) &#x2F; 1000 &#x2F; 60 &#x2F; 60 &#x2F; 24; dnum &#x3D; Math.floor(days);</span><br><span class="line">        hours &#x3D; (now - grt ) &#x2F; 1000 &#x2F; 60 &#x2F; 60 - (24 * dnum); hnum &#x3D; Math.floor(hours);</span><br><span class="line">        if(String(hnum).length &#x3D;&#x3D;1 )&#123;hnum &#x3D; &quot;0&quot; + hnum;&#125; minutes &#x3D; (now - grt ) &#x2F; 1000 &#x2F;60 - (24 * 60 * dnum) - (60 * hnum);</span><br><span class="line">        mnum &#x3D; Math.floor(minutes); if(String(mnum).length &#x3D;&#x3D;1 )&#123;mnum &#x3D; &quot;0&quot; + mnum;&#125;</span><br><span class="line">        seconds &#x3D; (now - grt ) &#x2F; 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);</span><br><span class="line">        snum &#x3D; Math.round(seconds); if(String(snum).length &#x3D;&#x3D;1 )&#123;snum &#x3D; &quot;0&quot; + snum;&#125;</span><br><span class="line">        document.getElementById(&quot;timeDate&quot;).innerHTML &#x3D; &quot;本站已安全运行 &quot;+dnum+&quot; 天 &quot;;</span><br><span class="line">        document.getElementById(&quot;times&quot;).innerHTML &#x3D; hnum + &quot; 小时 &quot; + mnum + &quot; 分 &quot; + snum + &quot; 秒&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">setInterval(&quot;createtime()&quot;,250);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<h4 id="添加字数统计和阅读时长"><a href="#添加字数统计和阅读时长" class="headerlink" title="添加字数统计和阅读时长"></a>添加字数统计和阅读时长</h4><p>在站点目录下安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-symbols-count-time --save</span><br></pre></td></tr></table></figure>
<p>在站点配置文件中添加配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#估算一篇文章需要阅读的时间       </span><br><span class="line">symbols_count_time:</span><br><span class="line">  #文章内是否显示</span><br><span class="line">  symbols: true</span><br><span class="line">  time: true</span><br><span class="line">   # 网页底部是否显示</span><br><span class="line">  total_symbols: false</span><br><span class="line">  total_time: true</span><br><span class="line">  exclude_codeblock: false</span><br><span class="line">  awl: 4</span><br><span class="line">  wpm: 275</span><br><span class="line">  suffix: &quot;mins.&quot;</span><br></pre></td></tr></table></figure>
<h4 id="文章加密功能"><a href="#文章加密功能" class="headerlink" title="文章加密功能"></a>文章加密功能</h4><p>​    <a href="https://github.com/D0n9X1n/hexo-blog-encrypt/blob/master/ReadMe.zh.md">详细内容参考</a></p>
<p>​    在站点目录下安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --save hexo-blog-encrypt</span><br></pre></td></tr></table></figure>
<p>​    在站点配置文件中添加</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">encrypt:</span><br><span class="line">  enable: true</span><br><span class="line">  abstract: 这是一篇加密文章，内容可能是个人情感宣泄或者收费技术。如果你确实想看，请与我联系。</span><br><span class="line">  message: 您好, 这里需要密码。</span><br><span class="line">  theme: Flip</span><br><span class="line">  wrong_pass_message: 抱歉, 这个密码看着不太对, 请再试试.</span><br><span class="line">  wrong_hash_message: 抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.</span><br></pre></td></tr></table></figure>
<p>​    然后在你的文章的头部添加上对应的字段，如 password, abstract, message</p>
<ul>
<li>password: 是该博客加密使用的密码</li>
<li>abstract: 是该博客的摘要，会显示在博客的列表页</li>
<li>message: 这个是博客查看时，密码输入框上面的描述性文字</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 文章加密</span><br><span class="line">date: 2019-01-04T22:20:13.000Z</span><br><span class="line">category: 教程</span><br><span class="line">tags:</span><br><span class="line">  - 博客</span><br><span class="line">  - Hexo</span><br><span class="line">password: 123456</span><br><span class="line">abstract: 密码：123456</span><br><span class="line">message:  输入密码，查看文章</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<h4 id="动态背景"><a href="#动态背景" class="headerlink" title="动态背景"></a>动态背景</h4><ul>
<li><a href="https://github.com/theme-next/theme-next-canvas-nest">Canvas-nest</a></li>
<li><a href="https://github.com/theme-next/theme-next-three">JavaScript 3D library</a></li>
<li><a href="https://github.com/theme-next/theme-next-canvas-ribbon">Canvas-ribbon</a></li>
</ul>
<p>按需选择，我选择的是canvas-ribbon，需要安装模块到<strong>theme/next/source/lib</strong>文件夹下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd themes&#x2F;next</span><br><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;theme-next-canvas-ribbon source&#x2F;lib&#x2F;canvas-ribbon</span><br></pre></td></tr></table></figure>
<p>Enable module in <strong>NexT</strong> <code>_config.yml</code> file:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">canvas_ribbon:</span><br><span class="line">  enable: true</span><br></pre></td></tr></table></figure>
<p><strong>And, if you wants to use the CDN, then need to set:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vendors:</span><br><span class="line">  ...</span><br><span class="line">  canvas_ribbon: &#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;theme-next&#x2F;theme-next-canvas-ribbon@1&#x2F;canvas-ribbon.js</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Tool</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo-代码块添加复制功能</title>
    <url>/article/853195356.html</url>
    <content><![CDATA[<h3 id="一，添加copy-code-swig"><a href="#一，添加copy-code-swig" class="headerlink" title="一，添加copy-code.swig"></a>一，添加copy-code.swig</h3><p>在博客根目录下，输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd themes&#x2F;next&#x2F;layout&#x2F;_third-party&#x2F;</span><br></pre></td></tr></table></figure>
<p>然后在次文件夹下创建copy-code.swig的文件，内容如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% if theme.codeblock.copy_button.enable %&#125;</span><br><span class="line">  &lt;style&gt;</span><br><span class="line">    .copy-btn &#123;</span><br><span class="line">      display: inline-block;</span><br><span class="line">      padding: 6px 12px;</span><br><span class="line">      font-size: 13px;</span><br><span class="line">      font-weight: 700;</span><br><span class="line">      line-height: 20px;</span><br><span class="line">      color: #333;</span><br><span class="line">      white-space: nowrap;</span><br><span class="line">      vertical-align: middle;</span><br><span class="line">      cursor: pointer;</span><br><span class="line">      background-color: #eee;</span><br><span class="line">      background-image: linear-gradient(#fcfcfc, #eee);</span><br><span class="line">      border: 1px solid #d5d5d5;</span><br><span class="line">      border-radius: 3px;</span><br><span class="line">      user-select: none;</span><br><span class="line">      outline: 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .highlight-wrap .copy-btn &#123;</span><br><span class="line">      transition: opacity .3s ease-in-out;</span><br><span class="line">      opacity: 0;</span><br><span class="line">      padding: 2px 6px;</span><br><span class="line">      position: absolute;</span><br><span class="line">      right: 4px;</span><br><span class="line">      top: 8px;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .highlight-wrap:hover .copy-btn,</span><br><span class="line">    .highlight-wrap .copy-btn:focus &#123;</span><br><span class="line">      opacity: 1</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .highlight-wrap &#123;</span><br><span class="line">      position: relative;</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;&#x2F;style&gt;</span><br><span class="line">  </span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    $(&#39;.highlight&#39;).each(function (i, e) &#123;</span><br><span class="line">      var $wrap &#x3D; $(&#39;&lt;div&gt;&#39;).addClass(&#39;highlight-wrap&#39;)</span><br><span class="line">      $(e).after($wrap)</span><br><span class="line">      $wrap.append($(&#39;&lt;button&gt;&#39;).addClass(&#39;copy-btn&#39;).append(&#39;&#123;&#123;__(&quot;post.copy_button&quot;)&#125;&#125;&#39;).on(&#39;click&#39;, function (e) &#123;</span><br><span class="line">        var code &#x3D; $(this).parent().find(&#39;.code&#39;).find(&#39;.line&#39;).map(function (i, e) &#123;</span><br><span class="line">          return $(e).text()</span><br><span class="line">        &#125;).toArray().join(&#39;\n&#39;)</span><br><span class="line">        var ta &#x3D; document.createElement(&#39;textarea&#39;)</span><br><span class="line">        document.body.appendChild(ta)</span><br><span class="line">        ta.style.position &#x3D; &#39;absolute&#39;</span><br><span class="line">        ta.style.top &#x3D; &#39;0px&#39;</span><br><span class="line">        ta.style.left &#x3D; &#39;0px&#39;</span><br><span class="line">        ta.value &#x3D; code</span><br><span class="line">        ta.select()</span><br><span class="line">        ta.focus()</span><br><span class="line">        var result &#x3D; document.execCommand(&#39;copy&#39;)</span><br><span class="line">        document.body.removeChild(ta)</span><br><span class="line">        &#123;% if theme.codeblock.copy_button.show_result %&#125;</span><br><span class="line">          if(result)$(this).text(&#39;&#123;&#123;__(&quot;post.copy_success&quot;)&#125;&#125;&#39;)</span><br><span class="line">          else $(this).text(&#39;&#123;&#123;__(&quot;post.copy_failure&quot;)&#125;&#125;&#39;)</span><br><span class="line">        &#123;% endif %&#125;</span><br><span class="line">        $(this).blur()</span><br><span class="line">      &#125;)).on(&#39;mouseleave&#39;, function (e) &#123;</span><br><span class="line">        var $b &#x3D; $(this).find(&#39;.copy-btn&#39;)</span><br><span class="line">        setTimeout(function () &#123;</span><br><span class="line">          $b.text(&#39;&#123;&#123;__(&quot;post.copy_button&quot;)&#125;&#125;&#39;)</span><br><span class="line">        &#125;, 300)</span><br><span class="line">      &#125;).append(e)</span><br><span class="line">    &#125;)</span><br><span class="line">  &lt;&#x2F;script&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>
<p>然后返回上一层目录，即<code>layout</code>文件夹下，编辑_layout.swig,如下图</p>
<p><img src="/images/codecopy.png" alt="codecopy.png"></p>
<p>在图中位置添加：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% include &#39;_third-party&#x2F;copy-code.swig&#39; %&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://qiming.info/Hexo%E5%8D%9A%E5%AE%A2%E4%B8%AD%E5%8A%A0%E5%85%A5%E4%BB%A3%E7%A0%81%E5%9D%97%E5%A4%8D%E5%88%B6%E5%8A%9F%E8%83%BD/">参考这位作者的文章</a></p>
]]></content>
      <categories>
        <category>Tool</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo-常用命令</title>
    <url>/article/3973852728.html</url>
    <content><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;记录一下hexo经常使用的命令，发现自己好久没有hexo，命令都不记得了。</p>
<h3 id="新建文章"><a href="#新建文章" class="headerlink" title="新建文章"></a>新建文章</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new &quot;postname&quot; (hexo n postname)</span><br></pre></td></tr></table></figure>
<h3 id="新建页面"><a href="#新建页面" class="headerlink" title="新建页面"></a>新建页面</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new page &quot;pagename&quot;</span><br></pre></td></tr></table></figure>
<h3 id="启动本地web服务"><a href="#启动本地web服务" class="headerlink" title="启动本地web服务"></a>启动本地web服务</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo server (hexo s)</span><br><span class="line">本地网址：localhost:4000</span><br></pre></td></tr></table></figure>
<h3 id="生成静态文件"><a href="#生成静态文件" class="headerlink" title="生成静态文件"></a>生成静态文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo generate (hexo g)</span><br></pre></td></tr></table></figure>
<h3 id="生成部署"><a href="#生成部署" class="headerlink" title="生成部署"></a>生成部署</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo d -g</span><br></pre></td></tr></table></figure>
<h3 id="生成预览"><a href="#生成预览" class="headerlink" title="生成预览"></a>生成预览</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo s -g</span><br></pre></td></tr></table></figure>
<h3 id="清理public文件夹"><a href="#清理public文件夹" class="headerlink" title="清理public文件夹"></a>清理public文件夹</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean </span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Tool</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>cmd</tag>
      </tags>
  </entry>
  <entry>
    <title>image-libraw相机图片库源码编译</title>
    <url>/article/1731984249.html</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LibRaw is a library for reading RAW files from digital photo cameras (CRW&#x2F;CR2, NEF, RAF, DNG, MOS, KDC, DCR, etc, virtually all RAW formats are supported).</span><br></pre></td></tr></table></figure>
<h3 id="一，源码下载"><a href="#一，源码下载" class="headerlink" title="一，源码下载"></a>一，源码下载</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;LibRaw&#x2F;LibRaw.git</span><br></pre></td></tr></table></figure>
<h3 id="二，编译环境准备"><a href="#二，编译环境准备" class="headerlink" title="二，编译环境准备"></a>二，编译环境准备</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1，查看文件DEVELOPER-NOTES，提示我们,执行mkdist.sh脚本来生成编译的东西</span><br><span class="line">2， 安装需要的软件</span><br><span class="line">	 yum install autoconf automake freetype-devel gcc gcc-c++ libtool make pkgconfig -y</span><br><span class="line">	 yum install wget -y</span><br><span class="line">	 yum install lcms2 lcms2-devel -y</span><br><span class="line">	 yum install jasper jasper-devel</span><br></pre></td></tr></table></figure>
<h3 id="三，准备编译遇到的错误"><a href="#三，准备编译遇到的错误" class="headerlink" title="三，准备编译遇到的错误"></a>三，准备编译遇到的错误</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">下载dcraw.c失败，我们需要手动的下载</span><br><span class="line">修改mkdist.sh脚本文件</span><br><span class="line">wget https:&#x2F;&#x2F;www.dechifro.org&#x2F;dcraw&#x2F;dcraw.c</span><br><span class="line">然后在执行 mkdist.sh脚本</span><br></pre></td></tr></table></figure>
<h3 id="四，编译"><a href="#四，编译" class="headerlink" title="四，编译"></a>四，编译</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;helios CXX&#x3D;&#x2F;usr&#x2F;local&#x2F;bin&#x2F;g++</span><br><span class="line">make</span><br><span class="line">make install</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="五，执行遇到的问题"><a href="#五，执行遇到的问题" class="headerlink" title="五，执行遇到的问题"></a>五，执行遇到的问题</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在程序中执行 open_file CR2的时候程序崩溃，因为自己的g++编译是4.8.5的，但是更新到4.9.2后就成功了</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Media</category>
        <category>image</category>
      </categories>
      <tags>
        <tag>libraw</tag>
      </tags>
  </entry>
  <entry>
    <title>image-libvips图片处理库源码编译</title>
    <url>/article/3448999942.html</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">目前主要是用于苹果平台图片heic图片的转码处理</span><br></pre></td></tr></table></figure>
<h3 id="1，从GitHub上下载源码"><a href="#1，从GitHub上下载源码" class="headerlink" title="1，从GitHub上下载源码"></a>1，从GitHub上下载源码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git  clone  https:&#x2F;&#x2F;github.com&#x2F;libvips&#x2F;libvips.git</span><br></pre></td></tr></table></figure>
<h3 id="2，下载需要的依赖"><a href="#2，下载需要的依赖" class="headerlink" title="2，下载需要的依赖"></a>2，下载需要的依赖</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install gtk-doc</span><br><span class="line">yum install gobject-introspection</span><br><span class="line">yum install gobject-introspection-devel</span><br><span class="line">yum install expat-devel</span><br><span class="line">yum install glib glib-devel</span><br><span class="line">yum install gcc gcc-c++</span><br><span class="line">yum install make pkgconfig autoconf automake</span><br></pre></td></tr></table></figure>
<h3 id="3，编译出现的问题"><a href="#3，编译出现的问题" class="headerlink" title="3，编译出现的问题"></a>3，编译出现的问题</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">libpango-1.0.so: undefined reference to &#96;fribidi_get_par_embedding_levels_ex&#39;</span><br><span class="line"></span><br><span class="line">检查ldd &#x2F;usr&#x2F;lib64&#x2F;libpango-1.0.so发现，有一个ibfribidi.so.0 &#x3D;&gt; &#x2F;lib64&#x2F;libfribidi.so.0链接开始链接的是我自己的，有问题，改回来就好了，可能是版本冲突的原因，需要保证链接库的版本一致</span><br></pre></td></tr></table></figure>
<h3 id="3，安装我们需要支持的图片格式依赖"><a href="#3，安装我们需要支持的图片格式依赖" class="headerlink" title="3，安装我们需要支持的图片格式依赖"></a>3，安装我们需要支持的图片格式依赖</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install -y libjpeg-turbo libjpeg-turbo-devel</span><br><span class="line">yum install -y libexif libexif-devel</span><br><span class="line">yum install -y giflib giflib-devel</span><br><span class="line">yum install -y librsvg2 librsvg2-devel</span><br><span class="line">yum install -y libtiff libtiff-devel </span><br><span class="line">yum install -y libwebp libwebp-devel</span><br><span class="line">yum install -y libpng libpng-devel</span><br><span class="line">yum install -y  libgsf libgsf-devel</span><br><span class="line">yum install -y poppler-glib poppler-glib-devel</span><br><span class="line">yum install -y openslide openslide-devel</span><br><span class="line">yum install -y orc orc-devel</span><br><span class="line">yum install -y libimagequant libimagequant-devel</span><br><span class="line">yum install -y cfitsio cfitsio-devel</span><br><span class="line">yum install -y matio matio-devel</span><br><span class="line">yum install -y fftw fftw-devel</span><br></pre></td></tr></table></figure>
<h3 id="4，安装libheif"><a href="#4，安装libheif" class="headerlink" title="4，安装libheif"></a>4，安装libheif</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1,git 源码安装libde265,## 注意这个必须安装，不然在编译libvips时，虽然configure表示支持，但是在真正使用的时候会报错</span><br><span class="line"></span><br><span class="line">2，git源码安装libheif，需要注意 配置libde265支持</span><br></pre></td></tr></table></figure>
<h4 id="5，编译"><a href="#5，编译" class="headerlink" title="5，编译"></a>5，编译</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1，.&#x2F;configure</span><br><span class="line">2,make &amp;&amp; make install</span><br><span class="line">自己写的myconfig.sh文件</span><br><span class="line"></span><br><span class="line">  1 #!&#x2F;bin&#x2F;sh                                                                                                                          </span><br><span class="line">  2 commoninclude&#x3D;&#x2F;usr&#x2F;include</span><br><span class="line">  3 commonlib&#x3D;&#x2F;usr&#x2F;lib64</span><br><span class="line">  4  </span><br><span class="line">  5 CPPFLAGS&#x3D;&quot;-g -Wall -I$&#123;commoninclude&#125;  -L$&#123;commonlib&#125;&quot;    \</span><br><span class="line">  6 CXXFLAGS&#x3D;&quot;-g -Wall -I$&#123;commoninclude&#125;  -L$&#123;commonlib&#125;&quot;    \</span><br><span class="line">  7 PKG_CONFIG_PATH&#x3D;&quot;&#x2F;usr&#x2F;local&#x2F;lib&#x2F;pkgconfig:&#x2F;usr&#x2F;local&#x2F;heif&#x2F;lib&#x2F;pkgconfig&quot;         \</span><br><span class="line">  8 .&#x2F;configure  --enable-gtk-doc-pdf&#x3D;yes --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;vips    \</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Media</category>
        <category>image</category>
      </categories>
      <tags>
        <tag>libvips</tag>
      </tags>
  </entry>
  <entry>
    <title>image-图片处理库总结</title>
    <url>/article/3226112650.html</url>
    <content><![CDATA[<h3 id="一，提取exif信息的库"><a href="#一，提取exif信息的库" class="headerlink" title="一，提取exif信息的库"></a>一，提取exif信息的库</h3><p><a href="https://www.exiv2.org/">Exif</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Exiv2 是一个用来提取图片中的EXIF、LPTC 和 XMP 元数据信息的C++类库。同时还提供了命令行工具。示例代码： Exiv2::Image::AutoPtr image &#x3D;Exiv2::ImageFactory::open(argv[1]);assert(image.get() !&#x3D; 0);image-&gt;readMetadata(); Exi... 更多Exiv2信息 </span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/libvips/libvips">libvips</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">libvips是一个需求驱动的水平线程 图像处理库。与类似的库相比，libvips运行迅速且几乎不占用内存。libvips是根据LGPL 2.1+许可的。</span><br><span class="line"></span><br><span class="line">它具有约300种运算， 涵盖算术，直方图，卷积，形态运算，频率滤波，颜色，重采样，统计等。它支持多种数字类型，从8位int到128位复数。图像可以具有任意数量的波段。它支持各种图像格式，包括JPEG，TIFF，PNG，WebP，HEIC，FITS，Matlab，OpenEXR，PDF，SVG，HDR，PPM &#x2F; PGM &#x2F; PFM，CSV，GIF，分析，NIfTI，DeepZoom和OpenSlide 。它还可以通过ImageMagick或GraphicsMagick加载图像，使其与DICOM等格式一起使用。</span><br><span class="line"></span><br><span class="line">主要用这个处理苹果平台heic图片格式的转码</span><br></pre></td></tr></table></figure>
<p><a href="http://cimg.eu/">CImg</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">就一个.h文件所以用起来很简明，但感觉功能上不如CxImage。可以与CxImage配合使用，因为CImg提供了基于</span><br><span class="line">lapack的矩阵运算函数和完善的线性滤波卷积函数，同时CImg做像素运算还是很方便的。另外，独有Display类可以方便的</span><br><span class="line">实现各种显示，包括显示图像、打字、画线等等。还有，该库有个基于光流的多尺度图像配准例子，很好.</span><br><span class="line"></span><br><span class="line">使用很方便，但是对于特殊的格式如heic，相机原生格式不支持</span><br></pre></td></tr></table></figure>
<p><a href="https://www.libraw.org/docs">libraw</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LibRaw是一个用于从数码相机读取RAW文件的库（CRW &#x2F; CR2，NEF，RAF，DNG，MOS，KDC，DCR等，实际上支持所有RAW格式）。</span><br><span class="line"></span><br><span class="line">它特别注意正确检索后续RAW转换所需的数据。</span><br><span class="line"></span><br><span class="line">该库旨在使用RAW文件作为初始数据嵌入RAW转换器，数据分析器和其他程序中。</span><br></pre></td></tr></table></figure>
<p><a href="https://www.codeproject.com/Articles/1300/CxImage">CxImage</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">对CxImage考察的印象：该开发包完全开放源代码，图像封装为一个类，功能极为强大，与Windows、MFC支持极好，支</span><br><span class="line">持图像的多种操作（线性滤波、中值滤波、直方图操作、旋转缩放、区域选取、阈值处理、膨胀腐蚀、alpha混合等等），支</span><br><span class="line">持从文件、内存或者win32api定义的位图图像格式中读取图像，支持将图像显示在任意窗口，功能可谓很强大了，而且对像</span><br><span class="line">素的操作很方便，另外还有一个界面很强的demo，可以直接在上面进行二次开发，推荐使用！</span><br><span class="line">缺点：里面的子库很多，用起来可能较麻烦；而且感觉速度稍慢，不如后面提到的freeimage</span><br><span class="line">但功能真的十分强大啊！</span><br><span class="line"></span><br><span class="line">主要使用这个处理相机原生图片，可以linux下自己不会编译</span><br></pre></td></tr></table></figure>
<p><a href="https://opencv.org/">OpenCV</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">对OpenCV的印象：功能十分的强大，而且支持目前先进的图像处理技术，体系十分完善，操作手册很详细，手册首先给大</span><br><span class="line">家补计算机视觉的知识，几乎涵盖了近10年内的主流算法；然后将图像格式和矩阵运算，然后将各个算法的实现函数。我用</span><br><span class="line">它来做了一个Harris角点检测器和Canny边缘检测器，总共就花了一个小时（第一次用OpenCV）。而且该库显示图像极其</span><br><span class="line">方便，两句话就可以。但该库似乎不大稳定，对32F和16S、8U的图像数据支持上bug重重。我用cvFilter2D函数进行线性</span><br><span class="line">滤波，屡屡出错，后来一查原来是大bug。后来用cvmGet来取矩阵元素也是频繁出错，仔细检查了N遍确保程序没问题之后</span><br><span class="line">在yahoogroup上找到答案：仍然是bug。。。但好歹该库是开放的，所以自己可以修改；而且支持CVS。另外该库用的是</span><br><span class="line">IPL矩阵库，速度奇快～～</span><br><span class="line"></span><br><span class="line">目前没有使用</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Media</category>
        <category>image</category>
      </categories>
  </entry>
  <entry>
    <title>json-cpp处理json</title>
    <url>/article/3190039070.html</url>
    <content><![CDATA[<p>cpp处理json常用的库</p>
<h3 id="poco-json"><a href="#poco-json" class="headerlink" title="poco-json"></a>poco-json</h3><p>poco库中处理json的模块，将其转换为json字符串时键名会按照字母的顺序排列</p>
<h3 id="jsoncpp"><a href="#jsoncpp" class="headerlink" title="jsoncpp"></a>jsoncpp</h3><p>jsoncpp这个库，将其转换为json字符串时键名也会按照字母的顺序排序</p>
<h4 id="1，下载"><a href="#1，下载" class="headerlink" title="1，下载"></a>1，下载</h4><p><a href="https://sourceforge.net/projects/jsoncpp/">jsonspp下载</a></p>
<h4 id="2，安装"><a href="#2，安装" class="headerlink" title="2，安装"></a>2，安装</h4><h5 id="scons下载"><a href="#scons下载" class="headerlink" title="scons下载"></a>scons下载</h5><p>使用scons来安装，如果yum没有找到，则需要<a href="http://www.helioswei.top/article/3859923575.html">更新yum库</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install scons -y</span><br></pre></td></tr></table></figure>
<h5 id="编译jsoncpp"><a href="#编译jsoncpp" class="headerlink" title="编译jsoncpp"></a>编译jsoncpp</h5><p>编译好的链接库，存放在jsoncpp源目录下的libs中<code>libjson_linux-gcc-4.8.5_libmt.so</code>，头文件放在include目录下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd jsoncpp的源目录</span><br><span class="line"></span><br><span class="line">scons platform&#x3D;linux-gcc</span><br></pre></td></tr></table></figure>
<h3 id="protobuf"><a href="#protobuf" class="headerlink" title="protobuf"></a>protobuf</h3><p>序列化，这个将其转换为json字符串时会按照message的顺序，比较的好。</p>
<h4 id="1，使用步骤"><a href="#1，使用步骤" class="headerlink" title="1，使用步骤"></a>1，使用步骤</h4><h5 id="先写proto的文件-status-proto"><a href="#先写proto的文件-status-proto" class="headerlink" title="先写proto的文件 status.proto"></a>先写proto的文件 status.proto</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">syntax &#x3D; &quot;proto3&quot;;                                                                                                                    </span><br><span class="line">package biyi;</span><br><span class="line"> </span><br><span class="line">message UnifiedLog&#123;</span><br><span class="line">    Cont content &#x3D; 1;</span><br><span class="line">    string sign &#x3D; 2;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">message Cont&#123;</span><br><span class="line">    string time_iso8601 &#x3D; 1;</span><br><span class="line">    string companyId &#x3D; 2;</span><br><span class="line">    string company &#x3D; 3;</span><br><span class="line">    string projectNameCN &#x3D; 4;</span><br><span class="line">    string projectName &#x3D; 5;</span><br><span class="line">    string componentName &#x3D; 6;</span><br><span class="line">    string componentMethodName &#x3D; 7;</span><br><span class="line">    string componentType &#x3D; 8;</span><br><span class="line">    string componentVer &#x3D; 9;</span><br><span class="line">    string componentLang &#x3D; 10; </span><br><span class="line">    string userName &#x3D; 11; </span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="cpp调用"><a href="#cpp调用" class="headerlink" title="cpp调用"></a>cpp调用</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &quot;..&#x2F;build&#x2F;proto&#x2F;status.pb.h&quot;</span><br><span class="line">#include &lt;google&#x2F;protobuf&#x2F;util&#x2F;json_util.h&gt;</span><br><span class="line"> </span><br><span class="line">namespace proto &#x3D; google::protobuf::util;</span><br><span class="line"> </span><br><span class="line">using namespace biyi;</span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">int main() &#123;</span><br><span class="line">    UnifiedLog uniLog;</span><br><span class="line">    uniLog.set_sign(</span><br><span class="line">        &quot;68f3ea8baebbaddc5a47d6d955ecf53892edb4d3d8a3afe08cf4518204d30af5&quot;);</span><br><span class="line">    uniLog.mutable_content()-&gt;set_time_iso8601(&quot;2020-03-09T11:11:14+08:00&quot;);</span><br><span class="line">    uniLog.mutable_content()-&gt;set_companyid(&quot;000&quot;);</span><br><span class="line">    uniLog.mutable_content()-&gt;set_company(&quot;ctsi&quot;);</span><br><span class="line">    uniLog.mutable_content()-&gt;set_projectnamecn(&quot;001&quot;);</span><br><span class="line">    uniLog.mutable_content()-&gt;set_projectname(&quot;biyi&quot;);</span><br><span class="line">    uniLog.mutable_content()-&gt;set_componentname(&quot;micro-service-statics&quot;);</span><br><span class="line">    uniLog.mutable_content()-&gt;set_componentmethodname(&quot;DemoBean.echo&quot;);</span><br><span class="line">    uniLog.mutable_content()-&gt;set_componenttype(&quot;微服务组件&quot;);</span><br><span class="line">    uniLog.mutable_content()-&gt;set_componentver(&quot;v1.0.0&quot;);</span><br><span class="line">    uniLog.mutable_content()-&gt;set_componentlang(&quot;java&quot;);</span><br><span class="line">    uniLog.mutable_content()-&gt;set_username(&quot;admin&quot;);</span><br><span class="line"> </span><br><span class="line">    cout &lt;&lt; uniLog.sign() &lt;&lt; endl;</span><br><span class="line">    &#x2F;&#x2F; message to json string</span><br><span class="line">    string str;</span><br><span class="line">    proto::Status status &#x3D; proto::MessageToJsonString(uniLog, &amp;str);</span><br><span class="line">    if (!status.ok()) &#123;</span><br><span class="line">        cout &lt;&lt; status.ToString() &lt;&lt; endl;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        cout &lt;&lt; &quot;str: &quot; &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    return 0;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Cpp</category>
        <category>protocol</category>
      </categories>
      <tags>
        <tag>json</tag>
      </tags>
  </entry>
  <entry>
    <title>linux-生成ssh key</title>
    <url>/article/2022323734.html</url>
    <content><![CDATA[<p>​    我们在使用git的时候经常需要用到ssh的连接，本文记录一下自己在使用的时候怎么生成的ssh key的过程。</p>
<h3 id="平台"><a href="#平台" class="headerlink" title="平台"></a>平台</h3><p>​    我使用的平台是Ubuntu16，查看的命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /etc/lsb-release</span><br></pre></td></tr></table></figure>
<h3 id="ssh-key的生成"><a href="#ssh-key的生成" class="headerlink" title="ssh key的生成"></a>ssh key的生成</h3><h4 id="检测本地是否有SSH-Key的存在"><a href="#检测本地是否有SSH-Key的存在" class="headerlink" title="检测本地是否有SSH Key的存在"></a>检测本地是否有SSH Key的存在</h4><p>​    使用下面的命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls -la ~/.ssh</span><br></pre></td></tr></table></figure>
<p>​    如果输出的是下面的内容，则表示没有，我们需要生成。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls: cannot access &#39;&#x2F;home&#x2F;weiyang&#x2F;.ssh&#39;: No such file or directory</span><br></pre></td></tr></table></figure>
<p>​    如果存在则就会显示下面的内容，我们直接使用就好了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">total 8</span><br><span class="line">drwx------ 2 weiyang weiyang   38 Mar  4 13:43 .</span><br><span class="line">drwxr-xr-x 4 weiyang weiyang  123 Mar  4 13:42 ..</span><br><span class="line">-rw------- 1 weiyang weiyang 1766 Mar  4 13:43 id_rsa</span><br><span class="line">-rw-r--r-- 1 weiyang weiyang  405 Mar  4 13:43 id_rsa.pub</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="生成"><a href="#生成" class="headerlink" title="生成"></a>生成</h4><p>​    使用下面的命令生成，按照操作来就行。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh-keygen</span><br></pre></td></tr></table></figure>
<p>​    提示设置 passphrase，每次与 Git 通信都会要求输入 passphrase，以避免某些错误的操作所导致的问题，建议设置一下。成功后在终端输入下面命令，此时会要求输入上面步骤里所填的 passphrase。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh-add ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure>
<p>​    使用下面命令获取公钥，然后拷贝到自己的git上就行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat .ssh&#x2F;id_rsa.pub</span><br></pre></td></tr></table></figure>
<p>​    如果你在使用时不想用passphrase,则使用下面的命令删除</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen -p [-P old_passphrase] [-N new_passphrase] [-f keyfile]</span><br><span class="line"></span><br><span class="line">ssh-keygen -p -P 123456 -N &#39;&#39; -f ~&#x2F;.ssh&#x2F;id_rsa</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title>mupdf-源码安装</title>
    <url>/article/3549577056.html</url>
    <content><![CDATA[<h3 id="一，源码下载"><a href="#一，源码下载" class="headerlink" title="一，源码下载"></a>一，源码下载</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">直接到官网上下载源码包</span><br><span class="line">https:&#x2F;&#x2F;www.mupdf.com&#x2F;downloads&#x2F;index.html</span><br><span class="line">mupdf-1.16.1-source.tar.gz</span><br></pre></td></tr></table></figure>
<h3 id="二，相关依赖下载"><a href="#二，相关依赖下载" class="headerlink" title="二，相关依赖下载"></a>二，相关依赖下载</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.</span><br><span class="line">You should have received a copy of the GNU Affero General Public License along with this program. If not, see http:&#x2F;&#x2F;www.gnu.org&#x2F;licenses</span><br><span class="line"></span><br><span class="line">yum install freeglut-devel</span><br></pre></td></tr></table></figure>
<h3 id="三，编译安装"><a href="#三，编译安装" class="headerlink" title="三，编译安装"></a>三，编译安装</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make prefix&#x3D;&#x2F;usr&#x2F;local install</span><br></pre></td></tr></table></figure>
<h3 id="四，使用注意"><a href="#四，使用注意" class="headerlink" title="四，使用注意"></a>四，使用注意</h3><p>在cmake的项目中使用静态库的时候，你只能生成静态链接库，在生成应用的时候，链接静态库和动态库都是一样的用法</p>
]]></content>
      <categories>
        <category>Media</category>
        <category>doc</category>
      </categories>
      <tags>
        <tag>mupdf</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql-centos7源码安装mysql8.0</title>
    <url>/article/1044847951.html</url>
    <content><![CDATA[<pre><code>因为直接通过yum安装的是mariadb，所以我们需要通过另外的方法来进行安装
</code></pre><h3 id="一，下载mysql"><a href="#一，下载mysql" class="headerlink" title="一，下载mysql"></a>一，下载mysql</h3><p>地址：<a href="https://dev.mysql.com/downloads/repo/yum/">https://dev.mysql.com/downloads/repo/yum/</a>。选择对应版本下载</p>
<h3 id="二，使用wget下载"><a href="#二，使用wget下载" class="headerlink" title="二，使用wget下载"></a>二，使用wget下载</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在网站上看对应的版本号就好了</span><br><span class="line">wget https:&#x2F;&#x2F;repo.mysql.com&#x2F;&#x2F;mysql80-community-release-el7-3.noarch.rpm</span><br></pre></td></tr></table></figure>
<h3 id="三，安装mysql的源"><a href="#三，安装mysql的源" class="headerlink" title="三，安装mysql的源"></a>三，安装mysql的源</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum -y localinstall mysql80-community-release-el7-1.noarch.rpm（对应版本）</span><br></pre></td></tr></table></figure>
<h3 id="四，在线安装mysql"><a href="#四，在线安装mysql" class="headerlink" title="四，在线安装mysql"></a>四，在线安装mysql</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum -y install mysql-community-server</span><br></pre></td></tr></table></figure>
<h3 id="五，linux下设置不区分大小写"><a href="#五，linux下设置不区分大小写" class="headerlink" title="五，linux下设置不区分大小写"></a>五，linux下设置不区分大小写</h3><ol>
<li>使用root账号登录，修改/etc/my.cnf；</li>
<li>在[mysqld]下加入一行：lower_case_table_names=1</li>
<li>mysqld –user=mysql –lower-case-table-names=1 –initialize-insecure datadir=/var/lib/mysql</li>
</ol>
<h3 id="六，设置开机自启"><a href="#六，设置开机自启" class="headerlink" title="六，设置开机自启"></a>六，设置开机自启</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl enable mysqld</span><br><span class="line">systemctl daemon-reload</span><br></pre></td></tr></table></figure>
<h3 id="七，修改本地root的密码"><a href="#七，修改本地root的密码" class="headerlink" title="七，修改本地root的密码"></a>七，修改本地root的密码</h3><ol>
<li>查看root账户的临时密码，vim  /var/log/mysqld.log</li>
<li>登录mysql，mysql -u root -p，输入1，中的临时密码</li>
<li>ALTER USER ‘root‘@’localhost’ IDENTIFIED BY ‘你的密码’;<br>修改密码为 你的密码 (备注：默认密码策略要求密码必须是大小写字母数字特殊字母的组合，至少8位)</li>
</ol>
<h3 id="八，-修改密码策略要求"><a href="#八，-修改密码策略要求" class="headerlink" title="八， 修改密码策略要求"></a>八， 修改密码策略要求</h3><p>~默认密码策略要求密码是大小写字母+数字+特殊字母的组合而且最少8位,不需要修改策略的可以跳过这步~</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1，查看密码的策略</span><br><span class="line">SHOW VARIABLES LIKE &#39;validate_password%&#39;;</span><br><span class="line">2，修改密码的策略</span><br><span class="line">set global validate_password.check_user_name&#x3D;OFF;</span><br><span class="line">set global validate_password.policy&#x3D;LOW;</span><br><span class="line">set global validate_password.length&#x3D;4;</span><br><span class="line">flush privileges;</span><br><span class="line">3，修改密码</span><br><span class="line">ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;root&#39;;</span><br></pre></td></tr></table></figure>
<h3 id="九，设置允许远程连接"><a href="#九，设置允许远程连接" class="headerlink" title="九，设置允许远程连接"></a>九，设置允许远程连接</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1，重新登录mysql；</span><br><span class="line">2，选择mysql表； use mysql;</span><br><span class="line">3,更新表的内容；</span><br><span class="line">update user set Host&#x3D;&#39;%&#39; where User&#x3D;&#39;root&#39;;</span><br><span class="line">GRANT ALL PRIVILEGES ON *.* TO &#39;root&#39;@&#39;%&#39; WITH GRANT OPTION;&#x2F;&#x2F;可能会报错，执行两次即可（不成功就再flush privileges;一次）</span><br></pre></td></tr></table></figure>
<h3 id="十，查看加密方式"><a href="#十，查看加密方式" class="headerlink" title="十，查看加密方式"></a>十，查看加密方式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select user, host, plugin, authentication_string from user\G;查看加密方式</span><br><span class="line">8.0加密方式（caching_sha2_password）有些客户端还不支持 ，导致客户端连接失败，所以使用mysql_native_password加密</span><br><span class="line">alter user &#39;root&#39;@&#39;%&#39; identified with mysql_native_password by &#39;helios2020&#39;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="九，卸载mysql"><a href="#九，卸载mysql" class="headerlink" title="九，卸载mysql"></a>九，卸载mysql</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">删除Mysql</span><br><span class="line">yum remove mysql mysql-server mysql-libs mysql-server;</span><br><span class="line">find &#x2F; -name mysql 将找到的相关东西delete掉</span><br><span class="line">(rm -rf &#x2F;var&#x2F;lib&#x2F;mysql)；</span><br><span class="line">rpm -qa|grep mysql(查询出来的东东yum remove掉)</span><br><span class="line">rm &#x2F;etc&#x2F;my.cnf （可能不存在）</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Database</category>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql-mysql常用命令</title>
    <url>/article/4107582643.html</url>
    <content><![CDATA[<p>记录一下常用的mysql数据库的命令</p>
<h3 id="数据库导入"><a href="#数据库导入" class="headerlink" title="数据库导入"></a>数据库导入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql -uroot -phelios2020 &lt;&#x2F;opt&#x2F;vidFactory&#x2F;database&#x2F;sql&#x2F;initDatatbase.sql</span><br></pre></td></tr></table></figure>
<h3 id="数据库导出"><a href="#数据库导出" class="headerlink" title="数据库导出"></a>数据库导出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysqldump -uroot -p 数据库名 &gt; initDatatbase.sql</span><br></pre></td></tr></table></figure>
<h3 id="database"><a href="#database" class="headerlink" title="database"></a>database</h3><h5 id="展示数据库"><a href="#展示数据库" class="headerlink" title="展示数据库"></a>展示数据库</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show databases;</span><br></pre></td></tr></table></figure>
<h5 id="使用数据库"><a href="#使用数据库" class="headerlink" title="使用数据库"></a>使用数据库</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">use vidfactory;</span><br></pre></td></tr></table></figure>
<h3 id="table"><a href="#table" class="headerlink" title="table"></a>table</h3><h5 id="展示表"><a href="#展示表" class="headerlink" title="展示表"></a>展示表</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show tables;</span><br></pre></td></tr></table></figure>
<h5 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h5><h6 id="插入所有字段"><a href="#插入所有字段" class="headerlink" title="插入所有字段"></a>插入所有字段</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">inset into tableName values(值1，值2，值3....)</span><br></pre></td></tr></table></figure>
<h6 id="插入某些字段"><a href="#插入某些字段" class="headerlink" title="插入某些字段"></a>插入某些字段</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">inset into tableName(列名a,列名b,列名c) values(值1，值2，值3);</span><br></pre></td></tr></table></figure>
<h5 id="查看某个表的结构"><a href="#查看某个表的结构" class="headerlink" title="查看某个表的结构"></a>查看某个表的结构</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">desc tableName \G;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Database</category>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>cmd</tag>
      </tags>
  </entry>
  <entry>
    <title>opencv-源码安装</title>
    <url>/article/3084764285.html</url>
    <content><![CDATA[<h3 id="一，源码下载"><a href="#一，源码下载" class="headerlink" title="一，源码下载"></a>一，源码下载</h3><p>​        通过git源码下载OpenCV，直接在GitHub上下载的速度特别慢，所以我们需要先将其fork，然后同步到gitee上面，通过自己的gitee账号来进行下载，这个速度比较快。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;gitee.com&#x2F;helioswei&#x2F;opencv.git</span><br></pre></td></tr></table></figure>
<h3 id="二，源码编译"><a href="#二，源码编译" class="headerlink" title="二，源码编译"></a>二，源码编译</h3><h5 id="1，cmake版本需求"><a href="#1，cmake版本需求" class="headerlink" title="1，cmake版本需求"></a>1，cmake版本需求</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CMake 3.5.1 or higher is required.  You are running version 2.8.12.2</span><br><span class="line">我们需要先源码编译cmake</span><br></pre></td></tr></table></figure>
<h5 id="2，安装相关的依赖"><a href="#2，安装相关的依赖" class="headerlink" title="2，安装相关的依赖"></a>2，安装相关的依赖</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1，需要Python的依赖包</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="2，编译"><a href="#2，编译" class="headerlink" title="2，编译"></a>2，编译</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在OpenCV目录中，创建build目录，然后直接cmake</span><br><span class="line">cd opencv</span><br><span class="line">mkdir build</span><br><span class="line">cd build</span><br><span class="line">cmake ..</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Media</category>
        <category>image</category>
      </categories>
      <tags>
        <tag>opencv</tag>
      </tags>
  </entry>
  <entry>
    <title>poco-源码编译包含mysql</title>
    <url>/article/3587508548.html</url>
    <content><![CDATA[<h3 id="一，源码下载库"><a href="#一，源码下载库" class="headerlink" title="一，源码下载库"></a>一，源码下载库</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">先在git上fork，然后同步到码云上，在clone可以加快下载的速度</span><br><span class="line">git clone https:&#x2F;&#x2F;gitee.com&#x2F;helioswei&#x2F;poco.git</span><br></pre></td></tr></table></figure>
<h3 id="二，编译环境准备"><a href="#二，编译环境准备" class="headerlink" title="二，编译环境准备"></a>二，编译环境准备</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install gcc-c++ make openssl-devel</span><br></pre></td></tr></table></figure>
<h3 id="三，安装mysql"><a href="#三，安装mysql" class="headerlink" title="三，安装mysql"></a>三，安装mysql</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">见mysql的源码安装，安装时没有头文件，所以我们需要安装头文件</span><br><span class="line">yum install mysql-devel</span><br></pre></td></tr></table></figure>
<h3 id="四，编译"><a href="#四，编译" class="headerlink" title="四，编译"></a>四，编译</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">需要提前安装GCC5.1.0来支持c++14</span><br><span class="line">.&#x2F;configure --shared --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;poco  --cflags&#x3D;-std&#x3D;c++14 --include-path&#x3D;&#x2F;usr&#x2F;include&#x2F;mysql&#x2F; --library-path&#x3D;&#x2F;usr&#x2F;lib64&#x2F;mysql&#x2F; --omit&#x3D;Data&#x2F;ODBC,MongoDB,PDF</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Cpp</category>
      </categories>
      <tags>
        <tag>poco</tag>
      </tags>
  </entry>
  <entry>
    <title>rabbitmq-AMQPCPP使用问题记录</title>
    <url>/article/3077642244.html</url>
    <content><![CDATA[<p>​        记录<a href="https://github.com/CopernicaMarketingSoftware/AMQP-CPP">AMQP_CPP</a>的使用过程中出现的问题，我是用的主要是<code>LibEvHandler</code>这个类来进行处理的,以下所有的问题都是在这个基础上面,仔细的查看头文件可以了解更多的使用方法。</p>
<h3 id="任务执行长时间后导致连接丢失的问题"><a href="#任务执行长时间后导致连接丢失的问题" class="headerlink" title="任务执行长时间后导致连接丢失的问题"></a>任务执行长时间后导致连接丢失的问题</h3><p><code>LibEvHandler</code>中对于rabbitmq的默认心跳是60s，如果当前队列没有任务处理，则其会自动的发送心跳，保持client和server之间的连接，如果你执行某个任务的时间过长，大于60s，则在执行任务期间，其不会自动的发送心跳导致两者之间的连接断开，导致下次获取数据时提示链接错误，获取数据失败。解决办法：</p>
<ol>
<li><p>重写LibEvHandler中的<code>onNegotiate</code>以及<code>onHeartbeat</code>这两个方法，前者用于设置心跳的时间，后者用于心跳发送时的函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&gt;&gt; <span class="number">23</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHandler</span> :</span> <span class="keyword">public</span> AMQP::LibEvHandler &#123;</span><br><span class="line">   <span class="number">24</span>  </span><br><span class="line">   <span class="number">25</span>    <span class="keyword">public</span>:</span><br><span class="line">&gt;&gt; <span class="number">26</span>     MyHandler(struct ev_loop* loop) : AMQP::LibEvHandler(loop) &#123;&#125;</span><br><span class="line">   <span class="number">27</span>     <span class="comment">//解决consume在处理任务时的连接超时的问题</span></span><br><span class="line">&gt;&gt; <span class="number">28</span>     <span class="function"><span class="keyword">uint16_t</span> <span class="title">onNegotiate</span><span class="params">(AMQP::TcpConnection* connection, <span class="keyword">uint16_t</span> timeout)</span> </span>&#123;</span><br><span class="line">   <span class="number">29</span>         <span class="keyword">return</span> <span class="number">70</span>;<span class="comment">//必须设置一个值</span></span><br><span class="line">   <span class="number">30</span>     &#125;</span><br><span class="line">&gt;&gt; <span class="number">31</span>     <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onHeartbeat</span><span class="params">(AMQP::TcpConnection* connection)</span> </span>&#123;</span><br><span class="line">   <span class="number">32</span>         connection-&gt;heartbeat();</span><br><span class="line">   <span class="number">33</span>     &#125;</span><br><span class="line">   <span class="number">34</span> &#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>另外开一个线程，定时手动的发送心跳给rabbitmq</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">   <span class="number">46</span>     <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&gt;&gt; <span class="number">47</span>         <span class="class"><span class="keyword">struct</span> <span class="title">ev_loop</span>* <span class="title">loop</span> =</span> ev_loop_new();</span><br><span class="line">   <span class="number">48</span>         <span class="comment">// AMQP::LibEvHandler handler(loop);</span></span><br><span class="line">   <span class="number">49</span>         <span class="function">MyHandler <span class="title">handler</span><span class="params">(loop)</span></span>;</span><br><span class="line">   <span class="number">50</span>         <span class="function">AMQP::TcpConnection <span class="title">connection</span><span class="params">(&amp;handler, *_address)</span></span>;</span><br><span class="line">   <span class="number">51</span>         _connection = &amp;connection;</span><br><span class="line">   <span class="number">52</span>         <span class="function">AMQP::TcpChannel <span class="title">channel</span><span class="params">(&amp;connection)</span></span>;</span><br><span class="line">   <span class="number">53</span>         <span class="comment">//// channel.setQos(1);</span></span><br><span class="line">   <span class="number">54</span>         _channel = &amp;channel;</span><br><span class="line">              <span class="comment">//另外开一个线程，用于检测rabbitmq的链接，以及定时的发送心跳</span></span><br><span class="line">   <span class="number">55</span>         <span class="function"><span class="built_in">std</span>::thread <span class="title">check</span><span class="params">(&amp;Consume::checkConnect, <span class="keyword">this</span>)</span></span>;</span><br><span class="line">   <span class="number">56</span>         <span class="comment">// 1s后执行一次回调，之后每10s执行一次</span></span><br><span class="line">   <span class="number">57</span>         ev_timer_init(&amp;_timer, TClass::callback, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">   <span class="number">58</span>         _timer.data = <span class="keyword">this</span>;</span><br><span class="line">   <span class="number">59</span>         ev_timer_start(loop, &amp;_timer);</span><br><span class="line">   <span class="number">60</span>         ev_run(loop, <span class="number">0</span>);</span><br><span class="line">   <span class="number">61</span>         check.join();</span><br><span class="line">   <span class="number">62</span>     &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">165</span>     <span class="function"><span class="keyword">void</span> <span class="title">checkConnect</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="number">166</span>         <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="comment">//判读链接是否可用，可用即发送心跳</span></span><br><span class="line"><span class="number">167</span>             <span class="keyword">if</span> (_connection-&gt;usable()) _connection-&gt;heartbeat();</span><br><span class="line">                <span class="comment">//判读当前通道是否可用，如果失败则杀死当前程序</span></span><br><span class="line"><span class="number">168</span>             _channel-&gt;onError([&amp;](<span class="keyword">const</span> <span class="keyword">char</span>* message) &#123;</span><br><span class="line"><span class="number">169</span>                 LOG(ERROR) &lt;&lt; <span class="string">&quot;The channel is error, exit: &quot;</span> &lt;&lt; message;</span><br><span class="line"><span class="number">170</span>                 killAll();</span><br><span class="line"><span class="number">171</span>             &#125;);</span><br><span class="line">                <span class="comment">//判读当前连接是否关闭，如果关闭则杀死当前程序</span></span><br><span class="line"><span class="number">172</span>             <span class="keyword">if</span> (_connection-&gt;closed()) &#123;</span><br><span class="line"><span class="number">173</span>                 <span class="keyword">if</span> (_connection != <span class="literal">NULL</span>) _connection-&gt;close();</span><br><span class="line"><span class="number">174</span>                 LOG(ERROR) &lt;&lt; <span class="string">&quot;The connection is closed,exit&quot;</span>;</span><br><span class="line"><span class="number">175</span>                 killAll();</span><br><span class="line"><span class="number">176</span>             &#125;</span><br><span class="line">                <span class="comment">//sleep 5s</span></span><br><span class="line"><span class="number">177</span>             Poco::Thread::sleep(<span class="number">5000</span>);</span><br><span class="line"><span class="number">178</span>         &#125;</span><br><span class="line"><span class="number">179</span>     &#125;</span><br><span class="line"><span class="number">180</span>     <span class="function"><span class="keyword">void</span> <span class="title">killAll</span><span class="params">()</span> </span>&#123; kill(<span class="number">0</span>, SIGABRT); &#125;</span><br><span class="line">   </span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="每次仅仅处理一个任务的问题"><a href="#每次仅仅处理一个任务的问题" class="headerlink" title="每次仅仅处理一个任务的问题"></a>每次仅仅处理一个任务的问题</h3><p>​        对于消息者来说，监听一个队列，如果队列里面有多条的数据，其会一下子都消费掉（有个最大值可查文档），比如你的队列里面有100条数据，其会都拿到放到内存中，如果过程中你的服务挂掉，则数据会丢失，为了解决这个问题，我们需要设置消费者每次拿到的数据量。AMQP_CPP中使用<code>setQos()</code>来进行设置</p>
<font color="red"><code>注意：仅对手动ack有效</code></font>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">AMQP::TcpChannel <span class="title">channel</span><span class="params">(&amp;connection)</span></span>;</span><br><span class="line">channel.setQos(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<h3 id="无法重新连接的问题"><a href="#无法重新连接的问题" class="headerlink" title="无法重新连接的问题"></a>无法重新连接的问题</h3><p>如果我们的rabbitmq挂了我们的服务应该怎么办了，一般对于这种有两种方法来处理</p>
<ol>
<li>实现rabbitmq的重试机制，rabbitmq连接断开后，我们能够自动的恢复；</li>
<li>服务中断机制，rabbitmq连接断开，我们的服务也中断，再通过某个服务能够拉起（守护进程）</li>
</ol>
<p>再AMQP_CPP中重连的机制不好处理，所以我们选择第二种方法</p>
]]></content>
      <categories>
        <category>Database</category>
        <category>rabbitmq</category>
      </categories>
      <tags>
        <tag>rabbitmq</tag>
      </tags>
  </entry>
  <entry>
    <title>rabbitmq-AMQPCPP的编译</title>
    <url>/article/3142310907.html</url>
    <content><![CDATA[<h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;CopernicaMarketingSoftware&#x2F;AMQP-CPP.git</span><br></pre></td></tr></table></figure>
<h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd AMQP-CPP</span><br><span class="line">mkdir build</span><br><span class="line">cd build</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cmake -DAMQP-CPP_BUILD_SHARED&#x3D;true -DAMQP-CPP_LINUX_TCP&#x3D;true -DCMAKE_INSTALL_PREFIX&#x3D;&#x2F;usr&#x2F;local&#x2F;amqpcpp ..</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Database</category>
        <category>rabbitmq</category>
      </categories>
      <tags>
        <tag>rabbitmq</tag>
      </tags>
  </entry>
  <entry>
    <title>s3-libs3源码编译</title>
    <url>/article/3714481837.html</url>
    <content><![CDATA[<h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install libxml2-devel</span><br><span class="line"></span><br><span class="line">yum install libxml2</span><br><span class="line"></span><br><span class="line">yum install libcurl-devel</span><br></pre></td></tr></table></figure>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make</span><br><span class="line">cd build&#x2F;lib</span><br></pre></td></tr></table></figure>
<p><code>有两个文件libs3.so.4</code></p>
]]></content>
      <categories>
        <category>Database</category>
        <category>s3</category>
      </categories>
      <tags>
        <tag>s3</tag>
      </tags>
  </entry>
  <entry>
    <title>s3-关于s3cmd的下载</title>
    <url>/article/3778876136.html</url>
    <content><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;很多人都用过对象存储，比如亚马逊的s3平台，我想大家都比较熟悉，今天来介绍一款工具，用来在centos7平台上方便的操作对象存储的东西，比如查看自己的桶，创建桶等。</p>
<h2 id="s3cmd的下载"><a href="#s3cmd的下载" class="headerlink" title="s3cmd的下载"></a>s3cmd的下载</h2><h3 id="第一步下载get-pip-py"><a href="#第一步下载get-pip-py" class="headerlink" title="第一步下载get-pip.py"></a>第一步下载get-pip.py</h3><blockquote>
<p>wget  <a href="https://bootstrap.pypa.io/get-pip.py">https://bootstrap.pypa.io/get-pip.py</a></p>
</blockquote>
<h3 id="第二步安装get-pip-py"><a href="#第二步安装get-pip-py" class="headerlink" title="第二步安装get-pip.py"></a>第二步安装get-pip.py</h3><blockquote>
<p>python get-pip.py</p>
</blockquote>
<h3 id="第三步安装s3cmd"><a href="#第三步安装s3cmd" class="headerlink" title="第三步安装s3cmd"></a>第三步安装s3cmd</h3><blockquote>
<p>pip install s3cmd</p>
</blockquote>
<h3 id="第四步设置-s3cfg"><a href="#第四步设置-s3cfg" class="headerlink" title="第四步设置.s3cfg"></a>第四步设置.s3cfg</h3><blockquote>
<p>设置三个比较主要的<br><img src="/images/access_key.png" alt="设置access_key"><br><img src="/images/host_bucket.png" alt="设置host_bucket"><br><img src="/images/secret_key.png" alt="设置secret_key">  </p>
</blockquote>
]]></content>
      <categories>
        <category>Database</category>
        <category>s3</category>
      </categories>
      <tags>
        <tag>cmd</tag>
        <tag>s3</tag>
      </tags>
  </entry>
  <entry>
    <title>spider-centos7安装selenium模拟浏览器请求</title>
    <url>/article/933612194.html</url>
    <content><![CDATA[<h3 id="安装selenium"><a href="#安装selenium" class="headerlink" title="安装selenium"></a>安装selenium</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install selenium</span><br></pre></td></tr></table></figure>
<h3 id="安装chrome浏览器"><a href="#安装chrome浏览器" class="headerlink" title="安装chrome浏览器"></a>安装chrome浏览器</h3><h5 id="1，配置yum源"><a href="#1，配置yum源" class="headerlink" title="1，配置yum源"></a>1，配置yum源</h5><p>在目录/etc/yum.repos.d/ 下新建文件 google-chrome.repo</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;etc&#x2F;yum.repos.d&#x2F;</span><br><span class="line">vim google-chrome.repo</span><br></pre></td></tr></table></figure>
<p>写入以下内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[google-chrome]</span><br><span class="line">name&#x3D;google-chrome</span><br><span class="line">baseurl&#x3D;http:&#x2F;&#x2F;dl.google.com&#x2F;linux&#x2F;chrome&#x2F;rpm&#x2F;stable&#x2F;$basearch</span><br><span class="line">enabled&#x3D;1</span><br><span class="line">gpgcheck&#x3D;1</span><br><span class="line">gpgkey&#x3D;https:&#x2F;&#x2F;dl-ssl.google.com&#x2F;linux&#x2F;linux_signing_key.pub</span><br></pre></td></tr></table></figure>
<p>安装google chrome浏览器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum -y install google-chrome-stable</span><br></pre></td></tr></table></figure>
<p>google官方源可能在中国无法使用，导致安装失败或者在国内无法更新，可以添加以下参数来安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum -y install google-chrome-stable --nogpgcheck</span><br></pre></td></tr></table></figure>
<h5 id="运行chrome"><a href="#运行chrome" class="headerlink" title="运行chrome"></a>运行chrome</h5><p>找到chrome路径，并做个软连接，方便使用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">which google-chrome-stable</span><br><span class="line">ln -s xxx &#x2F;bin&#x2F;chrome</span><br></pre></td></tr></table></figure>
<p>使用root用户启动chrome示例时会提示添加参数–no-sandbox flag</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chrome --no-sandbox flag</span><br></pre></td></tr></table></figure>
<h3 id="安装chromedriver"><a href="#安装chromedriver" class="headerlink" title="安装chromedriver"></a>安装chromedriver</h3><p>查看google-chrome的版本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">google-chrome --version</span><br></pre></td></tr></table></figure>
<p>chromedriver版本支持的Chrome版本</p>
<p><a href="https://sites.google.com/a/chromium.org/chromedriver/downloads">chromeDriver官网</a>官网一般比较慢</p>
<p><a href="http://npm.taobao.org/mirrors/chromedriver/">淘宝镜像</a></p>
<p>移动chromedriver到/usr/bin</p>
<h3 id="selenium-python验证"><a href="#selenium-python验证" class="headerlink" title="selenium+python验证"></a>selenium+python验证</h3><p>运行一段test.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver                                                                                                       </span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.chrome.options <span class="keyword">import</span> Options</span><br><span class="line"> </span><br><span class="line">chrome_options = Options()</span><br><span class="line">chrome_options.add_argument(<span class="string">&quot;--headless&quot;</span>)</span><br><span class="line">chrome_options.add_argument(<span class="string">&#x27;--disable-gpu&#x27;</span>)</span><br><span class="line">chrome_options.add_argument(<span class="string">&#x27;--no-sandbox&#x27;</span>)    <span class="comment"># 禁止沙箱模式，否则肯能会报错遇到chrome异常</span></span><br><span class="line">url=<span class="string">&quot;https://www.west.cn/login.asp&quot;</span></span><br><span class="line">brower=webdriver.Chrome(executable_path=<span class="string">&quot;/usr/bin/chromedriver&quot;</span>, chrome_options=chrome_options)</span><br><span class="line">brower.get(url)</span><br><span class="line">print(brower.current_url)</span><br><span class="line">brower.get(<span class="string">&quot;https://www.west.cn/Manager/&quot;</span>)</span><br><span class="line">print(brower.current_url)</span><br><span class="line">brower.quit()</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python3.6 test.py</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;www.west.cn&#x2F;login.asp</span><br><span class="line">https:&#x2F;&#x2F;www.west.cn&#x2F;login.asp?pageStr&#x3D;&#x2F;Manager&#x2F;Default.asp</span><br></pre></td></tr></table></figure>
<h3 id="使用pyautogui"><a href="#使用pyautogui" class="headerlink" title="使用pyautogui"></a>使用pyautogui</h3><p>对于一些元素虽然页面可以点击，但是获取的元素无法点击，我们可以使用pyautogui来模拟鼠标的点击更加的方便</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install pyautogui</span><br></pre></td></tr></table></figure>
<h3 id="远程调用"><a href="#远程调用" class="headerlink" title="远程调用"></a>远程调用</h3><p>使用selenium-server-standalone进行远程调用，<a href="https://www.xiehai.win/java/2019/05/24/selenium-server-standalone.html">详解可以看这篇连接</a></p>
<p><a href="http://selenium-release.storage.googleapis.com/index.html">selenium-server-standalone下载</a></p>
<h5 id="jar8环境的安装"><a href="#jar8环境的安装" class="headerlink" title="jar8环境的安装"></a>jar8环境的安装</h5><p><a href="https://www.yaosansi.com/post/install-java-jdk-on-centos/">jar环境的安装</a></p>
<h5 id="参数配置"><a href="#参数配置" class="headerlink" title="参数配置"></a>参数配置</h5><p>参数配置方式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 启动hub</span><br><span class="line">java -jar selenium-server-standalone-3.141.59.jar -role hub -maxSession 10 -port 4444</span><br><span class="line"># 启动node</span><br><span class="line">java -jar  -&quot;Dwebdriver.chrome.driver&#x3D;C:\\tools\\driver\\chromedriver.exe&quot; selenium-server-standalone-3.141.59.jar -role node  -hub http:&#x2F;&#x2F;localhost:4444&#x2F;grid&#x2F;register -port 4445</span><br></pre></td></tr></table></figure>
<p>配置文件方式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 启动hub</span><br><span class="line">java -jar selenium-server-standalone-3.141.59.jar -role hub -hubConfig hub.json</span><br><span class="line"># 启动node</span><br><span class="line">java -jar selenium-server-standalone-3.141.59.jar -role node -hub http:&#x2F;&#x2F;localhost:4444&#x2F;grid&#x2F;register -nodeConfig node.json</span><br></pre></td></tr></table></figure>
<p><code>hub.json</code></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;port&quot;</span>: <span class="number">4444</span>,</span><br><span class="line">  <span class="attr">&quot;newSessionWaitTimeout&quot;</span>: <span class="number">-1</span>,</span><br><span class="line">  <span class="attr">&quot;servlets&quot;</span>: [],</span><br><span class="line">  <span class="attr">&quot;capabilityMatcher&quot;</span>: <span class="string">&quot;org.openqa.grid.internal.utils.DefaultCapabilityMatcher&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;throwOnCapabilityNotPresent&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">&quot;nodePolling&quot;</span>: <span class="number">5000</span>,</span><br><span class="line">  <span class="attr">&quot;cleanUpCycle&quot;</span>: <span class="number">5000</span>,</span><br><span class="line">  <span class="attr">&quot;timeout&quot;</span>: <span class="number">60</span>,</span><br><span class="line">  <span class="attr">&quot;browserTimeout&quot;</span>: <span class="number">60</span>,</span><br><span class="line">  <span class="attr">&quot;maxSession&quot;</span>: <span class="number">10</span>,</span><br><span class="line">  <span class="attr">&quot;jettyMaxThreads&quot;</span>: <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>node.json</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;capabilities&quot;: [</span><br><span class="line">	&#123;</span><br><span class="line">	  &quot;browserName&quot;: &quot;firefox&quot;,</span><br><span class="line">	  &quot;marionette&quot;: true,</span><br><span class="line">	  &quot;maxInstances&quot;: 1,</span><br><span class="line">	  &quot;seleniumProtocol&quot;: &quot;WebDriver&quot;</span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;</span><br><span class="line">	  &quot;browserName&quot;: &quot;chrome&quot;,</span><br><span class="line">	  &quot;maxInstances&quot;: 3,</span><br><span class="line">	  &quot;platform&quot;: &quot;WINDOWS&quot;,</span><br><span class="line">	  &quot;webdriver.chrome.driver&quot;: &quot;D:\\javaproject\\oATFWeb\\External\\chromedriver2.4.1.exe&quot;,</span><br><span class="line">	  &quot;seleniumProtocol&quot;: &quot;WebDriver&quot;</span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;</span><br><span class="line">	  &quot;browserName&quot;: &quot;internet explorer&quot;,</span><br><span class="line">	  &quot;platform&quot;: &quot;WINDOWS&quot;,</span><br><span class="line">	  &quot;maxInstances&quot;: 1,</span><br><span class="line">	  &quot;seleniumProtocol&quot;: &quot;WebDriver&quot;</span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;</span><br><span class="line">	  &quot;browserName&quot;: &quot;safari&quot;,</span><br><span class="line">	  &quot;technologyPreview&quot;: false,</span><br><span class="line">	  &quot;platform&quot;: &quot;MAC&quot;,</span><br><span class="line">	  &quot;maxInstances&quot;: 1,</span><br><span class="line">	  &quot;seleniumProtocol&quot;: &quot;WebDriver&quot;</span><br><span class="line">	&#125;</span><br><span class="line">  ],</span><br><span class="line">  &quot;proxy&quot;: &quot;org.openqa.grid.selenium.proxy.DefaultRemoteProxy&quot;,</span><br><span class="line">  &quot;maxSession&quot;: 5,</span><br><span class="line">  &quot;port&quot;: 5555,</span><br><span class="line">  &quot;register&quot;: true,</span><br><span class="line">  &quot;registerCycle&quot;: 5000,</span><br><span class="line">  &quot;hub&quot;: &quot;http:&#x2F;&#x2F;10.12.1.140:4444&quot;,</span><br><span class="line">  &quot;nodeStatusCheckTimeout&quot;: 5000,</span><br><span class="line">  &quot;nodePolling&quot;: 5000,</span><br><span class="line">  &quot;role&quot;: &quot;node&quot;,</span><br><span class="line">  &quot;unregisterIfStillDownAfter&quot;: 60000,</span><br><span class="line">  &quot;downPollingLimit&quot;: 2,</span><br><span class="line">  &quot;debug&quot;: false,</span><br><span class="line">  &quot;servlets&quot;: [],</span><br><span class="line">  &quot;withoutServlets&quot;: [],</span><br><span class="line">  &quot;custom&quot;: &#123;&#125;,</span><br><span class="line">  &quot;browserTimeout&quot;: 60,</span><br><span class="line">  &quot;timeout&quot;: 60</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>访问http://hub.ip:port/grid/console可以看到node的详细配置</code></p>
<h5 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.remote.webdriver <span class="keyword">import</span> WebDriver <span class="keyword">as</span> RemoteWebDriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.chrome.options <span class="keyword">import</span> Options</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">chrome_options = Options()</span><br><span class="line"> </span><br><span class="line">proxy=<span class="string">&#x27;58.254.220.116:53579&#x27;</span></span><br><span class="line"><span class="comment">#chrome_options.add_experimental_option(&#x27;excludeSwitches&#x27;, [&#x27;enable-automation&#x27;])</span></span><br><span class="line"><span class="comment">#chrome_options.add_argument(&quot;--proxy-server=http://&quot; + proxy)</span></span><br><span class="line">chrome_options.add_argument(<span class="string">&quot;start-maximized&quot;</span>)</span><br><span class="line">chrome_options.add_argument(<span class="string">&quot;enable-automation&quot;</span>)</span><br><span class="line">chrome_options.add_argument(<span class="string">&quot;--headless&quot;</span>)</span><br><span class="line"><span class="comment">#chrome_options.add_argument(&quot;blink-settings=imagesEnabled=false&quot;)</span></span><br><span class="line">chrome_options.add_argument(<span class="string">&#x27;--disable-gpu&#x27;</span>)</span><br><span class="line"><span class="comment">#chrome_options.add_argument(&quot;--dns-prefetch-disable&quot;)</span></span><br><span class="line"><span class="comment">#chrome_options.add_argument(&quot;--no-proxy-server&quot;)</span></span><br><span class="line">chrome_options.add_argument(<span class="string">&#x27;--no-sandbox&#x27;</span>)    <span class="comment"># 禁止沙箱模式，否则肯能会报错遇到chrome异常</span></span><br><span class="line"><span class="comment">#url=&quot;https://www.365365918.com/#/AC/B1/C1/D8/E91032124/F3/I1/&quot;</span></span><br><span class="line"><span class="comment">#url=&quot;https://www.365365918.com/&quot;</span></span><br><span class="line">url=<span class="string">&quot;https://www.betvictor68.mobi/&quot;</span></span><br><span class="line"><span class="comment">#url=&quot;https://blog.csdn.net/tiantiantdx/article/details/79434550?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-8.edu_weight&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-8.edu_weight&quot;</span></span><br><span class="line"><span class="comment">#url=&quot;https://juejin.im/entry/5b2ca6316fb9a00e7747561a&quot;</span></span><br><span class="line"><span class="comment">#url=&quot;https://stackoverflow.com/questions/48450594/selenium-timed-out-receiving-message-from-renderer&quot;</span></span><br><span class="line"><span class="comment">#url=&quot;https://zhuanlan.zhihu.com/p/111859925&quot;</span></span><br><span class="line"><span class="comment">#打开google浏览器</span></span><br><span class="line"><span class="comment">#brower=webdriver.Chrome(executable_path=&quot;/usr/bin/chromedriver&quot;, chrome_options=chrome_options)</span></span><br><span class="line">brower=RemoteWebDriver(command_executor=<span class="string">&quot;http://192.168.50.74:4444/wd/hub&quot;</span>, desired_capabilities=chrome_options.to_capabilities())</span><br><span class="line"><span class="comment">#访问地址</span></span><br><span class="line">brower.get(url)</span><br><span class="line"><span class="comment">#设置请求的时间，等待js执行完毕</span></span><br><span class="line"><span class="comment">#time.sleep(5)</span></span><br><span class="line">brower.implicitly_wait(<span class="number">30</span>);</span><br><span class="line">pageSource=brower.find_element_by_xpath(<span class="string">&quot;//*&quot;</span>).get_attribute(<span class="string">&quot;outerHTML&quot;</span>)</span><br><span class="line"><span class="comment">#pageSource=brower.execute_script(&quot;return document.documentElement.outerHTML&quot;)</span></span><br><span class="line">fo = <span class="built_in">open</span>(<span class="string">&quot;/root/bet365.html&quot;</span>, <span class="string">&quot;w&quot;</span>)</span><br><span class="line">fo.write(pageSource)</span><br><span class="line">fo.close()</span><br><span class="line"><span class="comment">#print(pageSource)</span></span><br><span class="line"><span class="comment">#退出Google浏览器</span></span><br><span class="line">brower.quit()</span><br></pre></td></tr></table></figure>
<h3 id="windows搭建python的环境"><a href="#windows搭建python的环境" class="headerlink" title="windows搭建python的环境"></a>windows搭建python的环境</h3><p><a href="https://www.python.org/downloads/windows/">直接到官网</a>下载对应版本的</p>
<p>submit text3执行python</p>
<h5 id="设置build"><a href="#设置build" class="headerlink" title="设置build"></a>设置build</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">打开sublime，依次点击菜单Tools--&gt;Build System--&gt;New Build System</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;cmd&quot;: [&quot;D:\helios\software\python\python.exe&quot;, &quot;-u&quot;, &quot;$file&quot;],</span><br><span class="line">	&quot;file_regex&quot;: &quot;[ ]File \&quot;(…?)\&quot;, line ([0-9]*)&quot;,</span><br><span class="line">	&quot;selector&quot;: &quot;source.python&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ctrl + b来执行python</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Tool</category>
        <category>spider</category>
      </categories>
      <tags>
        <tag>selenium</tag>
      </tags>
  </entry>
  <entry>
    <title>博客的分类</title>
    <url>/article/2992991387.html</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">
  <script id="hbeData" type="hbeData" data-hmacdigest="9c6d4558b2764049217fd8f0af560cae3ca790ee7dab0a3ce3210a004071e6c3">fb9f6fbb8fc1d993240686705025b43532348148d53fb91ba5b377f724fe5b62290d080b1fcf999e1ed49c1afe465ff98e01c6e53c9483c7737641457feb35c33eb6b85fffeaca79b42470e68905ee3b89c18e94c8af44842b77ec4efa2d30b010f716e514e0804bf02f00c8fc60db83d842ee4d1277bbd526a5576fe56c2edd80e257d2e581dda4a2ff4c90761c88d26a3c06c981cd48e3116dbb60b65e6bbccb3580ed5d8e68f1bf06496ea918920c02d084f0b8b139575a7d43b981887169a3ceca6893f74e59e786ebd093f01abc46e977cb50b469895ab5f6f5516d9f3f21d4c422312a1170c6f74ffd913b52a32d137a4a10b6b9db86a346d53f866e3b9f0b45655430a7b18c17062c2ef525640120010b24a74284ca2763d229eed5ce7e23e8cf790efcb626beab1f00e42dc897c9546cb133f36969fb18a81cfd7dabf889ef660c3c6045e8614823c17a9740a735ad4a42278facdd693b5146a369cbe76fa3e953cc512df56ef275f9699a499f8555a846135389781682dc70eeefc22ad66ecd389718cae8d0a2d913a086e1792033b717e1f36d7242e6f2d1619022062153c4c1f161cb2c0cfe06cb63d9eb5c7488e239f82cbca61c354f1ef1396b774d4b1a4f97e08007e7abd204926e92a1b95a5562b2c303e873a086d113578a622db42e3ebf1683e20c84d00e22c9f00f0903799083705eb95e6befe04e7f7bde09dc7ed3b250eb380dc0ba5a4a0d718010a1afb0807ee8ba92abfcf4b68726940f4de6afb11a7b82279f84aee7bea851eea8b79c8cef69c56aae7c6680e7e369a2585f767c0711bcb6f2cb594ee30c3da5c446b55547bbfbc702b945cd565e24cee873da22c1167a7386b0520803b14e523dca542b3f36457a11552ce8448cb6ae4df3d33fc4d164d2b1b271fe66aa25f5ba8081e6fb7881e25afa97567ab16beac9dcd2278492db067d99f64380c1a90047e08dd245fba07691ceed15edcf504b0bc47fe554698dbe5abed3acbd5a6bdee7e9a352d2af370331cc956c152c24a9d0272475679b44d4815682632f02a0a5e8e146815a37abfec59b5d3da26f8b4e8bdc8f6ffc993132facd600f51b460b5221cf31d29e551727d6b61bed2eed77aed9cf1571bdc52cdbe779e0af29da412e410642e36a2adb3a984d9ef8e47e1dda27992e1794f8abe31fa9b8492c4558e2ef565a2e507bfc57754bff82ed42e03804d99b98613645e70974f411a0a74a1ab725fef3370cb97359ece0b9d2e89ea4873a4f3e85824f1b79b62bd19f6d88f55a5a3789b5d9b23c8a7d9461bdbf2871038ad51ce3cd0e90fd9233344a200b4de317e832dabc88624cb1a20b663f2540464d0aaae092d290aa32e3ff6b024112c6c4f2ca820180b491f4df672687cfe2e1f5e37c3f08452e1b4c7366e6a4a947b7ea151e69b1797bd8b53742865adb57a65dcbf4971c26346fa211a395f96e3ac584cff32d4047ed9209593760b79fa4d9ad663d7d883dd59940c42fc661512abed1ff151c96a3bef1596ad3f5638e5fb83b96511c3b363d91f0a1b8464046b71aa66d0824855d84a104429897eb67db459ce92e260ade3af56d8af74262fdc25734bf88aa4439b278eabde1a7a2d54a4ff45bba0f39d2a557e232ee3404dee50231527eede69abc6af2b424f69561c044c977a4b5d0eaa96faab895cca2635a1a2a9bf382e2ddf6d627557e5f9ee5f4317b57d503bec4334869a343e8749b79035983d6f3c5b196e2b36ee9b2b30ca01437dfcea1dddb2cd6442b639eb0b8fc4ccbe98a98ba3dff2e51d87f580532c566fa4f9f1f446e1f01e10ecb0439a1fbcfc37b6ada5a0e32f549384b2f40d62fed6c774fc631fb6a8ec8a26db4e264b8c1db92ae501aa301dc19154cadb1f65f52da653b65248f12b2e0b22763ec74bb6b5ce2bfb8b41b41d19013f6abcb99a33d6d9ba31b78e631507bec712afafc3cd0a4e211373713efa6aac193db428d64677299015a65702c71c407d54e760af27cc8db15fbb7d4bf5e8b1da8c6340dfb836115b700c73ef13c67335bfd2e6931ba21555bb1d181a5decbb067176d4e8f26b35fa872cb4950f8d638a2cc1019f0e942a9f25a0d518833ec0ccf6b23c4c937719bda83c26f7bc47d5f35adcc9d2b4909318a1f1b3a78695aa0e6167456cec4ac5a0432d4cbce3fd699f7189e1dfa2a83c32cca4cf67d2f8fd03e86f1f3c0326e0ee7be57d65f2ee7d7f973d596c5e91e0e93cbe96d39d853adbc88d5f2d7a91792aaaa86a7e3e61aa08d12f</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-flip">
      <input class="hbe hbe-input-field hbe-input-field-flip" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-flip" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-flip" data-content="您好, 这里需要密码。">您好, 这里需要密码。</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title>相机底片的解析</title>
    <url>/article/4054922039.html</url>
    <content><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;公司要求对相机原生格式如后缀为dng,CR2等的图片进行转码，然后预览，自己查找了一下资料，目前仅仅是用命令行来进行处理的，因为我们是linux端的服务，所以直接封装命令行比较的简单。</p>
<h3 id="DNG数据格式的介绍"><a href="#DNG数据格式的介绍" class="headerlink" title="DNG数据格式的介绍"></a>DNG数据格式的介绍</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;www.cnblogs.com&#x2F;adong7639&#x2F;p&#x2F;4446828.html</span><br><span class="line">https:&#x2F;&#x2F;blog.csdn.net&#x2F;wgx571859177&#x2F;article&#x2F;details&#x2F;80755793?utm_source&#x3D;blogxgwz1</span><br></pre></td></tr></table></figure>
<h3 id="DNG格式基本的概念"><a href="#DNG格式基本的概念" class="headerlink" title="DNG格式基本的概念"></a>DNG格式基本的概念</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  DNG格式是在TIFF的基础上扩展出来的，要了解DNG，需要清楚TIFF,</span><br><span class="line">TIFF&#x2F;EP,DNG,RAW之间的关系。</span><br><span class="line">  DNG（Digital Negative）是Adobe开发的一种开发的raw image file format ,</span><br><span class="line">主要是为了统一不同厂商的raw格式。里面使用的tag基本上都定义在TIFF或者TIFF&#x2F;EP 中，</span><br><span class="line">在DNG Sepcification中只是定义或者建议了数据的组织方式，颜色空间的转换等等。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="TIFF-EP"><a href="#TIFF-EP" class="headerlink" title="TIFF/EP"></a>TIFF/EP</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TIFF是一个灵活适应性强的文件格式。通过在文件标头中使用&quot;标签&quot;，它能够在一个</span><br><span class="line">文件中处理多幅图像和数据。标签能够标明图像的如图像大小这样的基本几何尺寸，</span><br><span class="line">或者定义图像数据是如何排列的，或者是否使用了各种各样的图像压缩选项。</span><br><span class="line"></span><br><span class="line">TIFF&#x2F;EP的全称是&quot;Tag Image File Format &#x2F; Electronic Photography&quot;。 </span><br><span class="line">它是一个名为&quot;Electronic still-picture imaging – Removable </span><br><span class="line">memory – Part 2: TIFF&#x2F;EP image data format&quot;ISO标准， 标准号为</span><br><span class="line">ISO12234-2。TIFF&#x2F;EP对TIFF文件扩展部分标记属性。</span><br></pre></td></tr></table></figure>
<h3 id="RAW"><a href="#RAW" class="headerlink" title="RAW"></a>RAW</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RAW文件包含创建一个可视图像所必须的相机传感器数据信息。RAW文件的结构，包括ISO标准的RAW图像格式ISO 12234-2 ，TIFF &#x2F; EP，往往遵循一个共同的模式，那就是：</span><br><span class="line"></span><br><span class="line">一个短的文件头，它通常包含文件的字节顺序，文件标识符和主数据的文件偏移量摄像传感器元数据，用来描述图像传感器的数据，包括传感器的尺寸， 颜色滤波矩阵(color filter array)的属性和它的颜色配置文件</span><br><span class="line"></span><br><span class="line">列入任何CMS环境或数据库中需要的图像元数据。这些措施包括曝光设定，相机&#x2F;扫描仪&#x2F;镜头模型，拍摄&#x2F;扫描日期（和可选的位置信息），创作信息和其他。一些原始文件包含可交换图像格式的标准化元数据节；</span><br><span class="line"></span><br><span class="line">图像缩略图；</span><br><span class="line"></span><br><span class="line">可选的JPEG格式缩小尺寸的图像，可用于快速预览；</span><br><span class="line"></span><br><span class="line">在电影胶片扫描中，无论是文件序列的时间码，序列码或帧编号都代表在扫描卷轴中的帧顺序。这个项目允许文件被被按帧顺序排列（不依赖于它的文件名​）；</span><br><span class="line"></span><br><span class="line">传感器图像数据；</span><br></pre></td></tr></table></figure>
<h3 id="常见的RAW格式"><a href="#常见的RAW格式" class="headerlink" title="常见的RAW格式"></a>常见的RAW格式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">许多RAW格式, 包括 3FR (Hasselblad), DCR, K25, KDC (Kodak), IIQ (Phase One), CR2 (Canon), </span><br><span class="line">ERF (Epson), MEF (Mamiya), MOS (Leaf), NEF (Nikon), ORF (Olympus), PEF (Pentax), </span><br><span class="line">RW2 (Panasonic) and ARW, SRF, SR2 (Sony), 都是基于TIFF格式。 这些文件可能在许多方面偏离TIFF标准，</span><br><span class="line">包括使用一个非标准的文件头，列入额外的图像标记和一些标签的数据加密。</span><br></pre></td></tr></table></figure>
<h3 id="TIFF-TIFF-EP-DNG-RAW之间的关系"><a href="#TIFF-TIFF-EP-DNG-RAW之间的关系" class="headerlink" title="TIFF, TIFF/EP, DNG, RAW之间的关系"></a>TIFF, TIFF/EP, DNG, RAW之间的关系</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TIFF和DNG同为Specification，分别定义了后缀名为.tif&#x2F;.tiff和.dng的文件格式同时在TIFF Specification也定义个baseline及部分扩展的tag。</span><br><span class="line"></span><br><span class="line">TIFF&#x2F;EP则定义并规范了在电子影像中所使用的TAG。</span><br><span class="line"></span><br><span class="line">DNG同时与TIFF和TIFF&#x2F;EP兼容，并包含了EXIF和XMP信息。DNG实际上就是扩张的TIFF， 把DNG的扩展名改成TIF就可以直接预览图片。</span><br><span class="line"></span><br><span class="line">在DNG出现以前，各个数码相机制造商都有自己的格式，比如Canon(cr2&#x2F;crw), Nikon(nef), Olympus(orf), Pentex(pef)等等。之所以出现这么多格式，一方面的原因是在这之前没有统一的raw格式， 但更重要的是，各个厂商希望用这个只对自己公开的数据格式来保护自己的私密信息。Adobe推出DNG希望能一统raw的天下。</span><br></pre></td></tr></table></figure>
<h3 id="处理不同格式RAW或者DNG底片的方法"><a href="#处理不同格式RAW或者DNG底片的方法" class="headerlink" title="处理不同格式RAW或者DNG底片的方法"></a>处理不同格式RAW或者DNG底片的方法</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;为了能够得到RAW格式或者DNG格式的jpg图片供我们预览，可以使用DCRAW和ffmpeg来结合使用</p>
<h4 id="dcraw介绍"><a href="#dcraw介绍" class="headerlink" title="dcraw介绍"></a>dcraw介绍</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;blog.csdn.net&#x2F;bi_diu1368&#x2F;article&#x2F;details&#x2F;80411304</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1,dcraw 下载   yum  install dcraw</span><br><span class="line">2.1,如果相机底片有缩略图，则直接可以通过  dcraw  -e   test.dng  获得其缩略图（注意，缩略图也有不存在的时候）</span><br><span class="line"></span><br><span class="line">2.2,如果没有缩略图，则可以先将RAW格式的转化为ppm   dcraw  -v  test.dng  获取其ppm的图片；</span><br><span class="line">然后在通过ffmpeg可以将 ppm格式的图片转码jpg  ffmpeg  -i  test.ppm out.jpg </span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Media</category>
      </categories>
      <tags>
        <tag>image</tag>
        <tag>RAW</tag>
      </tags>
  </entry>
  <entry>
    <title>系统io状态排查</title>
    <url>/article/4148759935.html</url>
    <content><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;这几天在排查自己写的转码服务性能上不去，转码特别慢，正常情况下，转码时CPU可以飙到很高，但是在问题机器上CPU只要50%左右，排查了好久，最终确定是某个其它服务io资源占用了太多，导致了我的转码服务io占用几乎没有，所以出现了问题，介绍几个io的工具，帮助以后查看系统的情况。</p>
<h3 id="iostat"><a href="#iostat" class="headerlink" title="iostat"></a>iostat</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;iostat主要是用来查看系统的io使用情况，<br>只记录自己使用的命令</p>
<h4 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install sysstat</span><br></pre></td></tr></table></figure>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iostat [-c ] [ -d ] [ -k ] [ -m ] [ -x ]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
        <category>centos7</category>
      </categories>
      <tags>
        <tag>io</tag>
      </tags>
  </entry>
</search>

<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[hexo-next主题配置]]></title>
    <url>%2F2020%2F05%2F07%2Fhexo-next%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[主要记录一下自己在搭建个人博客的时候，一些配置，基本上是查阅别人的文章，这里记录一下 一，hexo安装hexo安装 next主题设置 二，添加LocalSearch搜索123456 npm install hexo-generator-searchdb --save 编辑主题配置文件，启用本地搜素 # Local searchlocal_search: enable: true 三，网站访问量统计 四，阅读次数统计LeanCloud添加阅读次数 五，添加评论valine]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cuda-cuda10.0安装]]></title>
    <url>%2F2020%2F05%2F07%2Fcuda-cuda10-0%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[​ 在转码的过程中，我们可以使用硬件来进行转码的加速，今天记录一下在Centos7环境下安装驱动以及cuda模块。 下载驱动如果打算安装CUDA10.0及以上的版本则不需要单独安装驱动，cuda10.0自带驱动驱动忽略该驱动的安装 驱动下载地址 例如我们下载Quadro P2000 linux64的驱动 之所以安装这个驱动是因为要安装的cuda10.0也是410的，之后运行安装驱动程序就好了。 安装cuda10.01，下载安装包​ 安装包下载 在该网站上下载安装包 2，版本选择1通过以下按钮选择历史版本的cuda，找到10.0下载，然后选择对应的系统 3，运行.run文件1234下载完安装包放在linux上直接运行.run文件chmod +x cuda_10.0.130_410.48_linux.run ./cuda_10.0.130_410.48_linux.run 4，然后一直按回车键直到： 1回答：accept 5，是否安装驱动 1是否安装驱动，这里选择安装：y,因为我们自己没有提前安装驱动，如果提前安装过驱动，这里就不选择安装：n 6，是否安装OpenGL 1选择;n 7，是否安装x-config 1选择：n 8，是否安装Toolkit 1选择：y 9，cuda目录 1直接回车，选择默认安装路径 10，是否创建软连接 1选择：y 11，是否安装示例 12为了节约空间，这个不安装选择：n 12，然后开始安装 1表示安装成功 13，添加配置文件123456vim /etc/profile写入：export PATH=/usr/local/cuda-10.0/bin:$PATHexport LD_LIBRARY_PATH=/usr/local/cuda/lib64:$LD_LIBRARY_PATH保存：source /etc/profile 14，卸载驱动及cuda 注意 1,千万不要重复安装显卡驱动，会导致系统损坏 2.升级cuda的时候，一定要将旧版本的cuda卸载干净，否则会出现意想不到的错误 15，查看命令1231，检查显卡类型yum install pciutils（如果没有这个命令，则下载）lspci | grep VGA 122，检查安装是否成功nvidia-smi 错误处理1， /usr/bin/perl: bad interpreter: No such file or directory12yum install gccyum install perl 2，kernel源安装1234检查系统版本uname -ayum install kernel-devel-$(uname -r) kernel-headers-$(uname -r)先查看源是否相同，如果没有则需要下载 3，禁用nouveau（对某些版本需要）1，修改文件123456781，修改文件cd /etc/modprobe.dvim nvidia-installer-disable-nouveau.conf（如果没有这个文件，则手动生成） 内容： # generated by nvidia-installer blacklist nouveau options nouveau modeset=0 2，备份 initramfs1mv /boot/initramfs-$(uname -r).img /boot/initramfs-$(uname -r).img.bak 3，重建 initramfs1dracut -v /boot/initramfs-$(uname -r).img $(uname -r) 4，重启机器1reboot 5，检查nouveau driver确保没有被加载12lsmod | grep nouveau没有加载则为空，有加载则如图，说明设置没有生效，需要重新设置]]></content>
      <categories>
        <category>cuda</category>
      </categories>
      <tags>
        <tag>nvidia</tag>
        <tag>驱动</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[centos7-常用的命令]]></title>
    <url>%2F2020%2F05%2F06%2Fcentos7-%E5%B8%B8%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[记录一下自己常用的centos7上的命令行 mount挂载1234567891011虚拟机和主机共享目录mount -t cifs //192.168.30.97/code /mnt -o username=Administrator,password=Helios/code 是主机上的目录，需要设置为共享的username 为主机的用户名password 是主机的密码/mnt 是虚拟机上的目录卸载：umount /mnt卸载失败可以重启服务器]]></content>
      <categories>
        <category>centos7</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[centos7-epel源下载]]></title>
    <url>%2F2020%2F05%2F06%2Fcentos7-epel%E6%BA%90%E4%B8%8B%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[一，什么是epelEPEL的全称叫 Extra Packages for Enterprise Linux 。EPEL是由 Fedora 社区打造，为 RHEL 及衍生发行版如 CentOS、Scientific Linux 等提供高质量软件包的项目。装上了 EPEL之后，就相当于添加了一个第三方源。 如果你知道rpmfusion.org的话，拿 rpmfusion 做比较还是很恰当的，rpmfusion 主要为桌面发行版提供大量rpm包，而EPEL则为服务器版本提供大量的rpm包，而且大多数rpm包在官方 repository 中是找不到的\ 另外一个特点是绝大多数rpm包要比官方repository 的rpm包版本要来得新。所以，我们有时候在yum下载的时候如果没有找到某个包或者版本过低，可以使用这个方式来尝试。 二，yum下载1yum install -y epel-release]]></content>
      <categories>
        <category>centos7</category>
      </categories>
      <tags>
        <tag>yum源</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[centos7-163yum源下载]]></title>
    <url>%2F2020%2F05%2F06%2Fcentos7-163yum%E6%BA%90%E4%B8%8B%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[我们在centos7上下载东西的时候，有时候自带的源里面没有我们需要的软件，所有我们需要更换源来进行下载 一，下载repo文件1wget http://mirrors.163.com/.help/CentOS7-Base-163.repo 二，备份并且替代系统的repo文件1234567cp CentOS7-Base-163.repo /etc/yum.repos.d/ cd /etc/yum.repos.d/ mv CentOS-Base.repo CentOS-Base.repo.bak mv CentOS7-Base-163.repo CentOS-Base.repo 三，执行yum源更新命令12345yum clean all yum makecache yum update]]></content>
      <categories>
        <category>centos7</category>
      </categories>
      <tags>
        <tag>yum</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2020%2F05%2F06%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[mupdf-源码安装]]></title>
    <url>%2F2020%2F04%2F29%2Fmupdf-%E6%BA%90%E7%A0%81%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[一，源码下载123直接到官网上下载源码包https://www.mupdf.com/downloads/index.htmlmupdf-1.16.1-source.tar.gz 二，相关依赖下载1234This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.You should have received a copy of the GNU Affero General Public License along with this program. If not, see http://www.gnu.org/licensesyum install freeglut-devel 三，编译安装1make prefix=/usr/local install 四，使用注意在cmake的项目中使用静态库的时候，你只能生成静态链接库，在生成应用的时候，链接静态库和动态库都是一样的用法]]></content>
      <categories>
        <category>doc</category>
      </categories>
      <tags>
        <tag>pdf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[opencv-源码安装]]></title>
    <url>%2F2020%2F04%2F29%2Fopencv-%E6%BA%90%E7%A0%81%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[一，源码下载​ 通过git源码下载OpenCV，直接在GitHub上下载的速度特别慢，所以我们需要先将其fork，然后同步到gitee上面，通过自己的gitee账号来进行下载，这个速度比较快。 1git clone https://gitee.com/helioswei/opencv.git 二，源码编译1，cmake版本需求12CMake 3.5.1 or higher is required. You are running version 2.8.12.2我们需要先源码编译cmake 2，安装相关的依赖11，需要Python的依赖包 2，编译12345在OpenCV目录中，创建build目录，然后直接cmakecd opencvmkdir buildcd buildcmake ..]]></content>
      <categories>
        <category>opencv</category>
      </categories>
      <tags>
        <tag>centos7</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql-centos7源码安装mysql8.0]]></title>
    <url>%2F2020%2F04%2F17%2Fmysql-centos7%E6%BA%90%E7%A0%81%E5%AE%89%E8%A3%85mysql8-0%2F</url>
    <content type="text"><![CDATA[因为直接通过yum安装的是mariadb，所以我们需要通过另外的方法来进行安装 一，下载mysql地址：https://dev.mysql.com/downloads/repo/yum/。选择对应版本下载 二，使用wget下载12在网站上看对应的版本号就好了wget https://repo.mysql.com//mysql80-community-release-el7-3.noarch.rpm 三，安装mysql的源1yum -y localinstall mysql80-community-release-el7-1.noarch.rpm（对应版本） 四，在线安装mysql1yum -y install mysql-community-server 五，linux下设置不区分大小写 使用root账号登录，修改/etc/my.cnf； 在[mysqld]下加入一行：lower_case_table_names=1 mysqld –user=mysql –lower-case-table-names=1 –initialize-insecure datadir=/var/lib/mysql 六，设置开机自启12systemctl enable mysqldsystemctl daemon-reload 七，修改本地root的密码 查看root账户的临时密码，vim /var/log/mysqld.log 登录mysql，mysql -u root -p，输入1，中的临时密码 ALTER USER ‘root‘@’localhost’ IDENTIFIED BY ‘你的密码’;修改密码为 你的密码 (备注：默认密码策略要求密码必须是大小写字母数字特殊字母的组合，至少8位) 八， 修改密码策略要求~默认密码策略要求密码是大小写字母+数字+特殊字母的组合而且最少8位,不需要修改策略的可以跳过这步~ 1234567891，查看密码的策略SHOW VARIABLES LIKE &apos;validate_password%&apos;;2，修改密码的策略set global validate_password.check_user_name=OFF;set global validate_password.policy=LOW;set global validate_password.length=4;flush privileges;3，修改密码ALTER USER &apos;root&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;root&apos;; 九，设置允许远程连接123451，重新登录mysql；2，选择mysql表； use mysql;3,更新表的内容；update user set Host=&apos;%&apos; where User=&apos;root&apos;;GRANT ALL PRIVILEGES ON *.* TO &apos;root&apos;@&apos;%&apos; WITH GRANT OPTION;//可能会报错，执行两次即可（不成功就再flush privileges;一次） 十，查看加密方式123select user, host, plugin, authentication_string from user\G;查看加密方式8.0加密方式（caching_sha2_password）有些客户端还不支持 ，导致客户端连接失败，所以使用mysql_native_password加密alter user &apos;root&apos;@&apos;%&apos; identified with mysql_native_password by &apos;helios2020&apos;; 九，卸载mysql123456删除Mysqlyum remove mysql mysql-server mysql-libs mysql-server;find / -name mysql 将找到的相关东西delete掉(rm -rf /var/lib/mysql)；rpm -qa|grep mysql(查询出来的东东yum remove掉)rm /etc/my.cnf （可能不存在）]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>tools</tag>
        <tag>centos7</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gcc-5.1.0源码安装]]></title>
    <url>%2F2020%2F04%2F17%2Fgcc-5-1-0%E6%BA%90%E7%A0%81%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[对于一些源码的编译如poco库，需要的GCC的版本要求比较高，所以需要源码编译GCC、 一，源码下载123地址：https://ftp.gnu.org/gnu/gcc/gcc-5.1.0 可以支持C++14 二，依赖环境安装12cd gcc-5.1.0./contrib/download_prerequisites 1234567Building GCC requires GMP 4.2+, MPFR 2.4.0+ and MPC 0.8.0+地址：ftp://gcc.gnu.org/pub/gcc/infrastructure/wget ftp://gcc.gnu.org/pub/gcc/infrastructure/gmp-6.1.0.tar.bz2wget ftp://gcc.gnu.org/pub/gcc/infrastructure/mpfr-3.1.4.tar.bz2wget ftp://gcc.gnu.org/pub/gcc/infrastructure/mpc-1.0.3.tar.gz 三，依赖解压安装12345678910111213141516171819201，安装gmptar -jxvf gmp-6.1.0.tar.bz2cd gmp-6.1.0./configuremake &amp;&amp; make installerror:No usable m4 in $PATH or /usr/5binyum install m42,安装mpfrtar -jxvf mpfr-3.1.4.tar.bz2cd mpfr-3.1.4./configuremake &amp;&amp; make install3,安装mpctar -zxvf mpc-1.0.3.tar.gzcd mpc-1.0.3./configuremake &amp;&amp; make install 四，源码安装12345678./configure --enable-checking=release --enable-languages=c,c++ --disable-multilibmake make install#将链接复制cp -vf /usr/local/lib64/libstdc++.* /usr/lib64/gcc -vgcc version 5.1.0 (GCC)]]></content>
      <categories>
        <category>gcc</category>
      </categories>
      <tags>
        <tag>cpp</tag>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poco-源码编译包含mysql]]></title>
    <url>%2F2020%2F04%2F17%2Fpoco-%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%E5%8C%85%E5%90%ABmysql%2F</url>
    <content type="text"><![CDATA[一，源码下载库12先在git上fork，然后同步到码云上，在clone可以加快下载的速度git clone https://gitee.com/helioswei/poco.git 二，编译环境准备1yum install gcc-c++ make openssl-devel 三，安装mysql12见mysql的源码安装，安装时没有头文件，所以我们需要安装头文件yum install mysql-devel 四，编译12需要提前安装GCC5.1.0来支持c++14./configure --shared --prefix=/usr/local/poco --cflags=-std=c++14 --include-path=/usr/include/mysql/ --library-path=/usr/lib64/mysql/ --omit=Data/ODBC,MongoDB,PDF]]></content>
      <categories>
        <category>poco</category>
      </categories>
      <tags>
        <tag>cpp</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[image-libraw相机图片库源码编译]]></title>
    <url>%2F2020%2F01%2F17%2Fimage-libraw%E7%9B%B8%E6%9C%BA%E5%9B%BE%E7%89%87%E5%BA%93%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%2F</url>
    <content type="text"><![CDATA[1LibRaw is a library for reading RAW files from digital photo cameras (CRW/CR2, NEF, RAF, DNG, MOS, KDC, DCR, etc, virtually all RAW formats are supported). 一，源码下载1git clone https://github.com/LibRaw/LibRaw.git 二，编译环境准备1234561，查看文件DEVELOPER-NOTES，提示我们,执行mkdist.sh脚本来生成编译的东西2， 安装需要的软件 yum install autoconf automake freetype-devel gcc gcc-c++ libtool make pkgconfig -y yum install wget -y yum install lcms2 lcms2-devel -y yum install jasper jasper-devel 三，准备编译遇到的错误1234下载dcraw.c失败，我们需要手动的下载修改mkdist.sh脚本文件wget https://www.dechifro.org/dcraw/dcraw.c然后在执行 mkdist.sh脚本 四，编译123./configure --prefix=/usr/local/helios CXX=/usr/local/bin/g++makemake install 五，执行遇到的问题1在程序中执行 open_file CR2的时候程序崩溃，因为自己的g++编译是4.8.5的，但是更新到4.9.2后就成功了]]></content>
      <categories>
        <category>图片处理</category>
      </categories>
      <tags>
        <tag>centos7</tag>
        <tag>image</tag>
        <tag>lib.so</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[image-图片处理库总结]]></title>
    <url>%2F2020%2F01%2F15%2Fimage-%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%86%E5%BA%93%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[一，提取exif信息的库Exif 1Exiv2 是一个用来提取图片中的EXIF、LPTC 和 XMP 元数据信息的C++类库。同时还提供了命令行工具。示例代码： Exiv2::Image::AutoPtr image =Exiv2::ImageFactory::open(argv[1]);assert(image.get() != 0);image-&gt;readMetadata(); Exi... 更多Exiv2信息 libvips 12345libvips是一个需求驱动的水平线程 图像处理库。与类似的库相比，libvips运行迅速且几乎不占用内存。libvips是根据LGPL 2.1+许可的。它具有约300种运算， 涵盖算术，直方图，卷积，形态运算，频率滤波，颜色，重采样，统计等。它支持多种数字类型，从8位int到128位复数。图像可以具有任意数量的波段。它支持各种图像格式，包括JPEG，TIFF，PNG，WebP，HEIC，FITS，Matlab，OpenEXR，PDF，SVG，HDR，PPM / PGM / PFM，CSV，GIF，分析，NIfTI，DeepZoom和OpenSlide 。它还可以通过ImageMagick或GraphicsMagick加载图像，使其与DICOM等格式一起使用。主要用这个处理苹果平台heic图片格式的转码 CImg 12345就一个.h文件所以用起来很简明，但感觉功能上不如CxImage。可以与CxImage配合使用，因为CImg提供了基于lapack的矩阵运算函数和完善的线性滤波卷积函数，同时CImg做像素运算还是很方便的。另外，独有Display类可以方便的实现各种显示，包括显示图像、打字、画线等等。还有，该库有个基于光流的多尺度图像配准例子，很好.使用很方便，但是对于特殊的格式如heic，相机原生格式不支持 libraw 12345LibRaw是一个用于从数码相机读取RAW文件的库（CRW / CR2，NEF，RAF，DNG，MOS，KDC，DCR等，实际上支持所有RAW格式）。它特别注意正确检索后续RAW转换所需的数据。该库旨在使用RAW文件作为初始数据嵌入RAW转换器，数据分析器和其他程序中。 CxImage 12345678对CxImage考察的印象：该开发包完全开放源代码，图像封装为一个类，功能极为强大，与Windows、MFC支持极好，支持图像的多种操作（线性滤波、中值滤波、直方图操作、旋转缩放、区域选取、阈值处理、膨胀腐蚀、alpha混合等等），支持从文件、内存或者win32api定义的位图图像格式中读取图像，支持将图像显示在任意窗口，功能可谓很强大了，而且对像素的操作很方便，另外还有一个界面很强的demo，可以直接在上面进行二次开发，推荐使用！缺点：里面的子库很多，用起来可能较麻烦；而且感觉速度稍慢，不如后面提到的freeimage但功能真的十分强大啊！主要使用这个处理相机原生图片，可以linux下自己不会编译 OpenCV 123456789对OpenCV的印象：功能十分的强大，而且支持目前先进的图像处理技术，体系十分完善，操作手册很详细，手册首先给大家补计算机视觉的知识，几乎涵盖了近10年内的主流算法；然后将图像格式和矩阵运算，然后将各个算法的实现函数。我用它来做了一个Harris角点检测器和Canny边缘检测器，总共就花了一个小时（第一次用OpenCV）。而且该库显示图像极其方便，两句话就可以。但该库似乎不大稳定，对32F和16S、8U的图像数据支持上bug重重。我用cvFilter2D函数进行线性滤波，屡屡出错，后来一查原来是大bug。后来用cvmGet来取矩阵元素也是频繁出错，仔细检查了N遍确保程序没问题之后在yahoogroup上找到答案：仍然是bug。。。但好歹该库是开放的，所以自己可以修改；而且支持CVS。另外该库用的是IPL矩阵库，速度奇快～～目前没有使用]]></content>
      <categories>
        <category>图片处理</category>
      </categories>
      <tags>
        <tag>centos7</tag>
        <tag>image</tag>
        <tag>lib.so</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[image-libvips图片处理库源码编译]]></title>
    <url>%2F2020%2F01%2F15%2Fimage-libvips%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%86%E5%BA%93%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%2F</url>
    <content type="text"><![CDATA[1目前主要是用于苹果平台图片heic图片的转码处理 1，从GitHub上下载源码1git clone https://github.com/libvips/libvips.git 2，下载需要的依赖1234567yum install gtk-docyum install gobject-introspectionyum install gobject-introspection-develyum install expat-develyum install glib glib-develyum install gcc gcc-c++yum install make pkgconfig autoconf automake 3，编译出现的问题123libpango-1.0.so: undefined reference to `fribidi_get_par_embedding_levels_ex&apos;检查ldd /usr/lib64/libpango-1.0.so发现，有一个ibfribidi.so.0 =&gt; /lib64/libfribidi.so.0链接开始链接的是我自己的，有问题，改回来就好了，可能是版本冲突的原因，需要保证链接库的版本一致 3，安装我们需要支持的图片格式依赖123456789101112131415yum install -y libjpeg-turbo libjpeg-turbo-develyum install -y libexif libexif-develyum install -y giflib giflib-develyum install -y librsvg2 librsvg2-develyum install -y libtiff libtiff-devel yum install -y libwebp libwebp-develyum install -y libpng libpng-develyum install -y libgsf libgsf-develyum install -y poppler-glib poppler-glib-develyum install -y openslide openslide-develyum install -y orc orc-develyum install -y libimagequant libimagequant-develyum install -y cfitsio cfitsio-develyum install -y matio matio-develyum install -y fftw fftw-devel 4，安装libheif1231,git 源码安装libde265,## 注意这个必须安装，不然在编译libvips时，虽然configure表示支持，但是在真正使用的时候会报错2，git源码安装libheif，需要注意 配置libde265支持 5，编译1234567891011121，./configure2,make &amp;&amp; make install自己写的myconfig.sh文件 1 #!/bin/sh 2 commoninclude=/usr/include 3 commonlib=/usr/lib64 4 5 CPPFLAGS=&quot;-g -Wall -I$&#123;commoninclude&#125; -L$&#123;commonlib&#125;&quot; \ 6 CXXFLAGS=&quot;-g -Wall -I$&#123;commoninclude&#125; -L$&#123;commonlib&#125;&quot; \ 7 PKG_CONFIG_PATH=&quot;/usr/local/lib/pkgconfig:/usr/local/heif/lib/pkgconfig&quot; \ 8 ./configure --enable-gtk-doc-pdf=yes --prefix=/usr/local/vips \]]></content>
      <categories>
        <category>图片处理</category>
      </categories>
      <tags>
        <tag>centos7</tag>
        <tag>image</tag>
        <tag>lib.so</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ffmpeg-源码编译支持GPU]]></title>
    <url>%2F2020%2F01%2F14%2Fffmpeg-%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%E6%94%AF%E6%8C%81GPU%2F</url>
    <content type="text"><![CDATA[​ 源码编译需要很多的库的支持，一种是基础的库，一种是你需要的编解码信息的库 一，ffmpeg源码的下载1234567在git上找个你需要的版本的库，直接通过git下载git clone https://github.com/FFmpeg/FFmpeg.gitffmpeg 版本 ffmpeg version n4.1.1-3-g53f3f52cuda 版本 CUDA Version 10.0.130（这个版本自带驱动，可以不用安装驱动）drive 驱动版本 Driver Version: 410.48 nv-codec-headers 版本 sdk/8.1 二，基础环境的准备1yum -y install autoconf automake freetype-devel gcc gcc-c++ git libtool make nasm pkgconfig zlib-devel bzip2 bzip2-devel 三，编码过程1，设置环境路径 ​ 在 /etc/profile 文件中，设置 PKG_CONFIG_PATH 路径 12vim /etc/profileexport PKG_CONFIG_PATH=/usr/local/lib64/pkgconfig:/usr/lib64/pkgconfig:/usr/local/lib/pkgconfig:/usr/lib/pkgconfig 2，编码 ​ 配置好configure之后，通过make可以一步步试探你缺少的库是什么，然后在下载，编译 下载完之后，通过命令来配置你需要的东西./configure –help 123456make 编译的常用命令./configuremake -j 10 (编译，并行10个核来一起编译，可以取消)make install (安装)make disclean (卸载)make clean (清除编译) 3，解决gnutls的问题 我们需要手动的安装gnutls，gnutls3.5.19版本的可以，大于这个版本的有问题, http://www.linuxfromscratch.org/blfs/view/svn/postlfs/gnutls.html 有安装的方法 12345678910111213141,安装gnutls需要先安装gnutls，所有先手动下载这个wget https://ftp.gnu.org/gnu/nettle/nettle-3.1.1.tar.gztar zxf nettle-3.1.1.tar.gz ./configure --enable-sharedmakemake install2,安装gnutlswget https://www.gnupg.org/ftp/gcrypt/gnutls/v3.5/gnutls-3.5.19.tar.xzxz -d gnutls-3.5.19.tar.xztar xf gnutls-3.5.19.tarcd gnutls-3.5.19./configure --enable-sharedmakemake install 在安装gnutls时，我们使用./configure –enable-shared时，可能遇到以下的问题; 解决： yum install gmp-devel 解决： yum install libffi libffi-devel ./configure –enable-shared –with-included-libtasn1 解决： yum install libunistring-devel ./configure –enable-shared –with-included-libtasn1 –with-included-unistring 解决： yum install p11-kit-devel yum install unbound unbound-devel unbound-libs ./configure –enable-shared –with-included-libtasn1 –with-included-unistring 4，解决ladspa.h的问题 1yum install ladspa* 5，解决libass的问题 1yum install libass* 6，解决libdc1394-2的问题1234561,官网下载源码https://sourceforge.net/projects/libdc1394/files/libdc1394-2/2，编译./configuremakemake install 7，解决libgsm的问题 1yum install gsm-tools gsm-devel 8，解决libmp3lame版本的问题 12345源码安装，地址git clone https://github.com/gypified/libmp3lame.git./configuremakemake install 9，解决libopencore_amrnb的问题 12345官网下载源码，再手动编译https://sourceforge.net/projects/opencore-amr/files/opencore-amr/ ./configure make make install 10，解决opencv的问题11，解决openh264的问题 12345从git上下载源码git clone https://github.com/cisco/openh264如果下载失败，则直接下载zip包，然后解压安装make ARCH=x86_64make install 12，解决libopenjp2版本的问题 12345678910git下载源码来编译安装git clone https://github.com/uclouvain/openjpeg.git如果下载不下来，则下载zip包解压安装 unzip openjpeg-master.zipcmake 安装mkdir buildcd buildcmake .. -DCMAKE_BUILD_TYPE=Releasemake -j 10make install 13，解决opus的问题 1234567891011#需要手动的下载安装https://ftp.osuosl.org/pub/xiph/releases/opus/#安装步骤wget http://downloads.xiph.org/releases/opus/opus-1.2.1.tar.gztar -zxvf opus-1.2.1.tar.gzcd opus-1.2.1./configuremakemake install#注意：如果pkg_config没有找到，需要手动的设置路径，见前面PKG_CONFIG_PATH路径的设置，如果设置好之后，库也存在还是不行，则要检查是否使用yum下载了低版本的，若是则删除yum remove opus-1.0.2-6.el7.x86_64 opus-tools-0.1.6-1.el7.x86_64 opusfile-0.5-1.el7.x86_64 opus-devel-1.0.2-6.el7.x86_64 opusfile-devel-0.5-1.el7.x86_64 14，解决libpulse的问题15，解决libsoxr的问题 123456#手动下载包，然后编译安装https://sourceforge.net/projects/soxr/files/tar -xvf soxr-0.1.3-Source.tar./gocd Realsemake install 在执行go的时候可能遇到这个问题,则需要下载cmake高级版本 123456# cmake 安装https://cmake.org/download/tar -zxvf cmake-3.13.0-rc1.tar.gz./configuremakemake install 16，解决speex的问题 12345##手动下载安装包，编译，选择 libspeex下载https://xiph.org/downloads/./configure --enable-sharedmakemake install 17，解决libtheora的问题 123456## 手动下载安装包，编译，选择libtheora下载https://xiph.org/downloads/unzip libtheora-1.1.1.zip./configuremakemake install 在configure的过程中，可能error,则我们需要下载安装这个 1yum install libogg* 18，解决libv412的问题19，解决vorbis的问题 12345git clone https://github.com/xiph/vorbis.git./autogen.sh./configure --enable-sharedmakemake install 20，解决libx264的问题 1234git clone --depth 1 http://git.videolan.org/git/x264./configure --enable-sharedmakemake install 如果编译时报错，则需要安装nasm 1234567curl -O -L http://www.nasm.us/pub/nasm/releasebuilds/2.13.02/nasm-2.13.02.tar.bz2 tar -xjvf nasm-2.13.02.tar.bz2cd nasm-2.13.02./autogen.sh ./configure --enable-shared makemake install 21，解决libx265的问题 123456git clone --depth 1 https://github.com/videolan/x265.gitcd x265cd buildcmake ../sourcemakemake install 22，解决libxvid的问题 123456789##官网下载https://www.xvid.com/download/## 按下图过程来查找## 然后按照README来安装cd build/generic./configuremake -j 10make install 23，解决openal的问题 1yum install openal-soft openal-soft-devel 24，解决libcdio的问题25，解决bzlib的问题26，解决libxcb的问题 1yum install libxcb-devel 四，添加硬件编解码1，查看机器上显卡的型号1lspci | grep VGA 2，安装对应显卡的驱动12https://www.nvidia.com/Download/index.aspx?lang=en-us安装的方法见显卡驱动安装的文档 3，重新编译ffmpeg12345678在./configure时添加以下的选项，来重新编译ffmpeg，既可以驱动显卡--enable-cuda-sdk \--enable-cuvid \--enable-nvenc \--enable-nonfree \--enable-libnpp \--extra-cflags=-I/usr/local/cuda/include \--extra-ldflags=-L/usr/local/cuda/lib64 \ 4，查看是否安装成功12使用ffmpeg -hwaccels命令查看支持的硬件加速选项ffmpeg -hwaccels 5，查看cuvid提供的GPU编解码器1ffmpeg -codecs | grep cuvid 6，使用GPU进行转码 用GPU进行转码的命令和软转码命令不太一样，CPU转码的时候，我们可以依赖ffmpeg识别输入视频的编码格式并选择对应的解码器，但ffmpeg只会自动选择CPU解码器，要让ffmpeg使用GPU解码器，必须先用ffprobe识别出输入视频的编码格式，然后在命令行中指定对应的GPU解码器。 例如，将h264编码的源视频转码为指定尺寸和码率的h264编码视频： 1234567ffmpeg -hwaccel cuvid -c:v h264_cuvid -i video/video-H264-AAC.mkv -c:v h264_nvenc -b:v 2048k -vf scale_npp=1280:-1 -y /root/transcode.mp4-hwaccel cuvid：指定使用cuvid硬件加速-c:v h264_cuvid：使用h264_cuvid进行视频解码-c:v h264_nvenc：使用h264_nvenc进行视频编码-vf scale_npp=1280:-1：指定输出视频的宽高，注意，这里和软解码时使用的-vf scale=x:x不一样转码期间使用nvidia-smi查看显卡状态，能够看到ffmpeg确实是在使用GPU进行转码： 如果在执行命令的时候报错，则需要,进行nv-codec-headers和驱动的版本匹配的处理 我开始编译nv-codec-headers使用的是最新版本9.1的，编译出错，有两种方法，一种是升级drive的版本，升级到430以上，这个比较的麻烦，另一种是降低nv-codec-headers的版本，我降低到8.1版本，就可以成功 1234ffmpeg 版本 ffmpeg version n4.1.1-3-g53f3f52cuda 版本 CUDA Version 10.0.130（这个版本自带驱动，可以不用安装驱动）drive 驱动版本 Driver Version: 410.48 nv-codec-headers 版本 sdk/8.1 7,在容器中使用NVIDIA1234在将自己的服务打包成镜像的时候，开始没有设置环境变量，导致怎么都无法调用NVIDIA进行硬件的转码；最后查询了很多的资料，发现需要添加一个环境变量，在Dockfile中ENV NVIDIA_DRIVER_CAPABILITIES video,compute,utility才能保证容器中使用成功 8，gpu和cpu转码测试​ 对于同一个视频，分别采用cpu和GPU两种方式来进行转码，对比这两者之间的效率 12345678910111213141516171819202122232425262728293031323334#机器信息逻辑核：24内存：64G24 Intel(R) Xeon(R) CPU E5-2620 v2 @ 2.10GHz系统：CentOS Linux release 7.6.1810 (Core)#视频信息：name: 11.mkvsize： 1.1GVideo: h264 (High), yuv420p(progressive), 1280x720 [SAR 1:1 DAR 16:9], 25 fps, 25 tbr, 1k tbn, 50 tbc (default)Audio: ac3, 48000 Hz, stereo, fltp, 192 kb/s (default)#软件转码：[time] ffmpeg -i video/11.mkv -c:v libx264 -b:v 2048k -vf scale=1280:-1 -y /root/transcode.mp4#结果real 11m18.807suser 180m16.290ssys 1m36.925scpu占用 平均1600%[time] ./softhw /root/video/11.mkv /opt/nvitra1.mp4real 14m51.166suser 220m2.857ssys 1m21.718scpu占用 平均1600%#硬件转码：[time] ffmpeg -hwaccel cuvid -c:v h264_cuvid -i video/11.mkv -c:v h264_nvenc -b:v 2048k -vf scale_npp=1280:-1 -y /root/transcode.mp4#结果real 1m45.228suser 1m15.910ssys 0m18.734scpu占用 平均90%[time] ./hw /root/video/11.mkv /opt/nvitra.mp4real 1m29.478suser 0m22.754ssys 0m23.465scpu占用 50% 8，指定显卡进行转码12345ffmpeg -hwaccel cuvid -hwaccel_device 0 -c:v h264_cuvid -i &lt;input&gt; -c:v h264_nvenc -b:v 2048k -vf scale_npp=1280:-1 -y &lt;output&gt;ffmpeg -hwaccel cuvid -hwaccel_device 1 -c:v h264_cuvid -i &lt;input&gt; -c:v h264_nvenc -b:v 2048k -vf scale_npp=1280:-1 -y &lt;output&gt;ffmpeg -hwaccel cuvid -hwaccel_device 0 -c:v h264_cuvid -i /root/source_media/flv.flv -c:v h264_nvenc -b:v 2048k -vf scale_npp=1280:-1 -y /root/flv.mp4]]></content>
      <categories>
        <category>ffmpeg</category>
      </categories>
      <tags>
        <tag>ffmpeg</tag>
        <tag>centos7</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[grpc编译]]></title>
    <url>%2F2020%2F01%2F14%2Fgrpc%E7%BC%96%E8%AF%91%2F</url>
    <content type="text"><![CDATA[1环境 centos7 一，安装编译依赖的环境123456yum install -y pkgconfig autoconf automake libtool make gcc-c++ unzipyum install -y gflags-devel gtest-devel clang libcxx-develyum install -y openssl openssl-develyum install -y libunwind libunwind-develyum install -y epel-releaseyum install -y golang 二，源码下载123git clone https://github.com/grpc/grpc.gitcd grpcgit submodule update --init 三，编译1，编译cmake12345678需要下载cmake高级版本，yum安装的版本太低https://cmake.org/download/源码安装cmake，（1）删除原来版本的cmake（2）./configure（3）make &amp;&amp; make install如果找不到，则创建软链接ln -s /usr/local/bin/cmake /usr/bin/cmake 2，先编译protobuf1234567891011cd third_party/protobufgit submodule update --init --recursive./autogen.sh./configure --prefix=/usr/local/helios/protobufmake make checkmake install2,建立软链接ln -s /usr/local/helios/protobuf/bin/protoc /usr/local/bin/protoc检测是否安装成功protoc --version 3，编译grpc（cmake)12345cd grpcmkdir -p cmake/buildcmake -DBUILD_SHARED_LIBS=on -DCMAKE_INSTALL_PREFIX=/usr/local/helios/grpc -DCMAKE_BUILD_TYPE=DEBUG -Wno-dev ../../makemake install 4，编译（make,不建议使用）12342,编译grpccd grpc根目录make -j 4make install 5，问题123456789101112131415161718192021222324252627282930对于cpp的使用，当编译好了之后，运行helloworld程序，没有响应，有很大的问题https://github.com/grpc/grpc/issues/21280#issuecomment-558164977解决方法：修改源码（不使用）vim / src / core / lib / surface / init.ccdiff --git a/src/core/lib/surface/init.cc b/src/core/lib/surface/init.ccindex 2812427f7a..3c6a547b20 100644--- a/src/core/lib/surface/init.cc+++ b/src/core/lib/surface/init.cc@@ -156,7 +156,7 @@ void grpc_init(void) &#123; * at the appropriate time */ grpc_register_security_filters(); register_builtin_channel_init();- grpc_tracer_init();将源码中的这个给注销+ // grpc_tracer_init(); /* no more changes to channel init pipelines */ grpc_channel_init_finalize(); grpc_iomgr_start(); 修改源码：vim src/core/lib/debug/trace.cc void TraceFlagList::Add(TraceFlag* flag) &#123;+ TraceFlag* t;+ for (t = root_tracer_; t; t = t -&gt; next_tracer_) &#123;+ if (t == flag ) return;+ &#125; flag-&gt;next_tracer_ = root_tracer_; root_tracer_ = flag;遍历链表，如果存在则不加入 6，运行helloworld程序12345678910111213141516171819202122232425262728cd examples/cpp/helloworldmake出现问题：which: no grpc_cpp_plugin in (/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin)因为自己配置的路径，所以先给grpc_cpp_plugin 建立软连接ln -s /usr/local/helios/grpc/bin/grpc_cpp_plugin /usr/local/bin/grpc_cpp_pluginhelloworld.pb.h:10:40: fatal error: google/protobuf/port_def.inc: No such file or directory配置cpp头文件路径export CPLUS_INCLUDE_PATH=$CPLUS_INCLUDE_PATH:/usr/local/helios/grpc/includePackage protobuf was not found in the pkg-config search path.Perhaps you should add the directory containing `protobuf.pc&apos;to the PKG_CONFIG_PATH environment variableNo package &apos;protobuf&apos; foundPackage grpc was not found in the pkg-config search path.Perhaps you should add the directory containing `grpc.pc&apos;to the PKG_CONFIG_PATH environment variableNo package &apos;grpc&apos; found配置pkgconfig搜索路径export PKG_CONFIG_PATH=$PKG_CONFIG_PATH:/usr/local/helios/protobuf/lib/pkgconfig/:/usr/local/helios/grpc/lib/pkgconfig/error while loading shared libraries: libgrpc_plugin_support.so.1: cannot open shared object file配置cpp动态库搜索路径export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/local/helios/grpc/lib/:/usr/local/helios/grpc/lib64/:/usr/local/helios/protobuf/lib]]></content>
      <categories>
        <category>grpc</category>
      </categories>
      <tags>
        <tag>grpc</tag>
        <tag>centos7</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ffmpeg-编码的步骤]]></title>
    <url>%2F2019%2F05%2F05%2Fffmpeg-%E7%BC%96%E7%A0%81%E7%9A%84%E6%AD%A5%E9%AA%A4%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;总结一下编码的大致过程，方便自己下一次的处理，分为音频编码和视频 音频编码的过程1，打开输出的文件流12AVFormatContext *ofmt_ctx;avformat_alloc_output_context2(&amp;ofmt_ctx, NULL, NULL, filename); 2，创建输出的音频流1234567891011AVStream *audioStream;AVCodec *encoder;AVCodecContext *enc_ctx;audioStream = avformat_new_stream(ofmt_ctx, NULL);if (!audioStream)&#123; av_log();&#125;encoder = avcodec_find_encoder(AV_CODEC_ID_AAC);if(!encoder)&#123; av_log();&#125; 3，设置编码的上下文1234567891011enc_ctx = avcodec_alloc_context3(encoder);if (!enc_ctx)&#123; av_log();&#125;enc_ctx -&gt; bit_rate = 64000;enc_ctx -&gt; sample_rate = 44100;enc_ctx -&gt; channel_layout = 2;//这个可以根据输入来设置enc_ctx -&gt; channels = av_get_channel_layout_nb_channels(enc_ctx -&gt; channel_layout);enc_ctx -&gt; sample_fmt = encoder -&gt; sample_fmts[0];AVRational time_base = &#123;1, enc_ctx -&gt; sample_rate&#125;;enc_ctx -&gt; time_base = time_base; 4，设置flag12if (ofmt_ctx -&gt; oformat -&gt; flags &amp; AVFMT_GLOBALHEADER) enc_ctx -&gt; flags |= AV_CODEC_FLAG_GLOBAL_HEADER; 5，打开编码器1234ret = avcodec_open2(enc_ctx, encoder, NULL);if (ret &lt; 0)&#123; av_log();&#125; 6，设置codec_tag1audioStream -&gt; codecpar -&gt; codec_tag = 0; 7，copy code to stream1ret = avcodec_parameters_from_context(audioStream -&gt; codecpar, enc_ctx);]]></content>
      <categories>
        <category>ffmpeg</category>
      </categories>
      <tags>
        <tag>ffmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[系统io状态排查]]></title>
    <url>%2F2019%2F04%2F28%2F%E7%B3%BB%E7%BB%9Fio%E7%8A%B6%E6%80%81%E6%8E%92%E6%9F%A5%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;这几天在排查自己写的转码服务性能上不去，转码特别慢，正常情况下，转码时CPU可以飙到很高，但是在问题机器上CPU只要50%左右，排查了好久，最终确定是某个其它服务io资源占用了太多，导致了我的转码服务io占用几乎没有，所以出现了问题，介绍几个io的工具，帮助以后查看系统的情况。 iostat&nbsp;&nbsp;&nbsp;&nbsp;iostat主要是用来查看系统的io使用情况，只记录自己使用的命令 下载1yum install sysstat 使用1iostat [-c ] [ -d ] [ -k ] [ -m ] [ -x ]]]></content>
      <categories>
        <category>centos7</category>
      </categories>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[相机底片的解析]]></title>
    <url>%2F2019%2F04%2F16%2F%E7%9B%B8%E6%9C%BA%E5%BA%95%E7%89%87%E7%9A%84%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;公司要求对相机原生格式如后缀为dng,CR2等的图片进行转码，然后预览，自己查找了一下资料，目前仅仅是用命令行来进行处理的，因为我们是linux端的服务，所以直接封装命令行比较的简单。 DNG数据格式的介绍12http://www.cnblogs.com/adong7639/p/4446828.htmlhttps://blog.csdn.net/wgx571859177/article/details/80755793?utm_source=blogxgwz1 DNG格式基本的概念12345 DNG格式是在TIFF的基础上扩展出来的，要了解DNG，需要清楚TIFF,TIFF/EP,DNG,RAW之间的关系。 DNG（Digital Negative）是Adobe开发的一种开发的raw image file format ,主要是为了统一不同厂商的raw格式。里面使用的tag基本上都定义在TIFF或者TIFF/EP 中，在DNG Sepcification中只是定义或者建议了数据的组织方式，颜色空间的转换等等。 TIFF/EP12345678TIFF是一个灵活适应性强的文件格式。通过在文件标头中使用&quot;标签&quot;，它能够在一个文件中处理多幅图像和数据。标签能够标明图像的如图像大小这样的基本几何尺寸，或者定义图像数据是如何排列的，或者是否使用了各种各样的图像压缩选项。TIFF/EP的全称是&quot;Tag Image File Format / Electronic Photography&quot;。 它是一个名为&quot;Electronic still-picture imaging – Removable memory – Part 2: TIFF/EP image data format&quot;ISO标准， 标准号为ISO12234-2。TIFF/EP对TIFF文件扩展部分标记属性。 RAW12345678910111213RAW文件包含创建一个可视图像所必须的相机传感器数据信息。RAW文件的结构，包括ISO标准的RAW图像格式ISO 12234-2 ，TIFF / EP，往往遵循一个共同的模式，那就是：一个短的文件头，它通常包含文件的字节顺序，文件标识符和主数据的文件偏移量摄像传感器元数据，用来描述图像传感器的数据，包括传感器的尺寸， 颜色滤波矩阵(color filter array)的属性和它的颜色配置文件列入任何CMS环境或数据库中需要的图像元数据。这些措施包括曝光设定，相机/扫描仪/镜头模型，拍摄/扫描日期（和可选的位置信息），创作信息和其他。一些原始文件包含可交换图像格式的标准化元数据节；图像缩略图；可选的JPEG格式缩小尺寸的图像，可用于快速预览；在电影胶片扫描中，无论是文件序列的时间码，序列码或帧编号都代表在扫描卷轴中的帧顺序。这个项目允许文件被被按帧顺序排列（不依赖于它的文件名​）；传感器图像数据； 常见的RAW格式1234许多RAW格式, 包括 3FR (Hasselblad), DCR, K25, KDC (Kodak), IIQ (Phase One), CR2 (Canon), ERF (Epson), MEF (Mamiya), MOS (Leaf), NEF (Nikon), ORF (Olympus), PEF (Pentax), RW2 (Panasonic) and ARW, SRF, SR2 (Sony), 都是基于TIFF格式。 这些文件可能在许多方面偏离TIFF标准，包括使用一个非标准的文件头，列入额外的图像标记和一些标签的数据加密。 TIFF, TIFF/EP, DNG, RAW之间的关系1234567TIFF和DNG同为Specification，分别定义了后缀名为.tif/.tiff和.dng的文件格式同时在TIFF Specification也定义个baseline及部分扩展的tag。TIFF/EP则定义并规范了在电子影像中所使用的TAG。DNG同时与TIFF和TIFF/EP兼容，并包含了EXIF和XMP信息。DNG实际上就是扩张的TIFF， 把DNG的扩展名改成TIF就可以直接预览图片。在DNG出现以前，各个数码相机制造商都有自己的格式，比如Canon(cr2/crw), Nikon(nef), Olympus(orf), Pentex(pef)等等。之所以出现这么多格式，一方面的原因是在这之前没有统一的raw格式， 但更重要的是，各个厂商希望用这个只对自己公开的数据格式来保护自己的私密信息。Adobe推出DNG希望能一统raw的天下。 处理不同格式RAW或者DNG底片的方法&nbsp;&nbsp;&nbsp;&nbsp;为了能够得到RAW格式或者DNG格式的jpg图片供我们预览，可以使用DCRAW和ffmpeg来结合使用 dcraw介绍1https://blog.csdn.net/bi_diu1368/article/details/80411304 123451,dcraw 下载 yum install dcraw2.1,如果相机底片有缩略图，则直接可以通过 dcraw -e test.dng 获得其缩略图（注意，缩略图也有不存在的时候）2.2,如果没有缩略图，则可以先将RAW格式的转化为ppm dcraw -v test.dng 获取其ppm的图片；然后在通过ffmpeg可以将 ppm格式的图片转码jpg ffmpeg -i test.ppm out.jpg]]></content>
      <categories>
        <category>图片处理</category>
      </categories>
      <tags>
        <tag>image</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo-常用命令]]></title>
    <url>%2F2019%2F04%2F12%2Fhexo-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;记录一下hexo经常使用的命令，发现自己好久没有hexo，命令都不记得了。 新建文章1hexo new &quot;postname&quot; (hexo n postname) 新建页面1hexo new page &quot;pagename&quot; 启动本地web服务12hexo server (hexo s)本地网址：localhost:4000 生成静态文件1hexo generate (hexo g) 生成部署1hexo d -g 生成预览1hexo s -g 清理public文件夹1hexo clean]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>tools</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ffmpeg_avfilter的使用详解]]></title>
    <url>%2F2019%2F03%2F27%2Fffmpeg-avfilter%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;在ffmpeg，我们对视音频进行一些处理，如添加水印，有个很方便的库，avfilter， 过滤的过程解码后的画面 -&gt; buffer过滤器 -&gt; 其他过滤器 -&gt; buffersink 过滤器 -&gt; 处理好的画面]]></content>
      <categories>
        <category>ffmpeg</category>
      </categories>
      <tags>
        <tag>ffmpeg</tag>
        <tag>avfilter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown语言的总结]]></title>
    <url>%2F2019%2F03%2F18%2Fmarkdown%E8%AF%AD%E8%A8%80%E7%9A%84%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[s3-关于s3cmd的下载]]></title>
    <url>%2F2019%2F03%2F18%2Fs3-%E5%85%B3%E4%BA%8Es3cmd%E7%9A%84%E4%B8%8B%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;很多人都用过对象存储，比如亚马逊的s3平台，我想大家都比较熟悉，今天来介绍一款工具，用来在centos7平台上方便的操作对象存储的东西，比如查看自己的桶，创建桶等。 s3cmd的下载第一步下载get-pip.py wget https://bootstrap.pypa.io/get-pip.py 第二步安装get-pip.py python get-pip.py 第三步安装s3cmd pip install s3cmd 第四步设置.s3cfg 设置三个比较主要的]]></content>
      <categories>
        <category>s3对象存储</category>
      </categories>
      <tags>
        <tag>centos7</tag>
        <tag>s3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[others-时间管理]]></title>
    <url>%2F2019%2F03%2F15%2Fothers-%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[目标设定是第一步，提供路线图 你的目标是什么？短期内。你希望达成什么样的愿望？长期来说。你希望你的人生是什么样子？]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[cpp-关于内存泄漏的问题]]></title>
    <url>%2F2019%2F03%2F15%2Fcpp-%E5%85%B3%E4%BA%8E%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[今天我们讨论一些怎么处理内存泄漏的问题]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
        <tag>ffmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git-常用的命令]]></title>
    <url>%2F2019%2F03%2F15%2Fgit-%E5%B8%B8%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;记录一些git常用的命令，便于在长时间不用时能够有个地方查阅，下面的几个是经常用到的。在windows下使用git，许多朋友都说无法使用一些状态（修改，保存，提交）图标，是因为图标显示不是git本身的功能呢，我们需要下载TortoiseGit才能使用图标。 重命名文件夹1git mv -f oldfolder newfolder 删除中间的某次提交1git revert commit id 版本回退12git reset --hard commitid这个不会保留之前的记录 撤销本地提交123git reset --soft commitidgit reset --mixed commitid两者的区别，--soft会将改动放在缓存区 --mixed不会讲改动放在缓存区 撤销远程的提交123git loggit reset --hard commitidgit push origin HEAD:master --force 强制提交1git push -u origin master -f 将某个分支的提交copy到另一个分支上1234例如，有两个分支，a,b,想要将a的某次提交，copy到b分支上1,在a分支上 git log 查询commitid2,git checkout b 切换分支3,git cherry-pick commitid 统计当前分支的提交数目1git rev-list HEAD | wc -l 将当前工作区的修改暂存起来123456git stash 冻结当前的分支修改git stash save &quot;说明信息&quot;git stash list 列出所有的工作现场存储git stash apply stash@&#123;n&#125; 恢复某个工作现场git stash drop stash@&#123;n&#125; 删除存储的某个工作现场git stash pop stash@&#123;n&#125; 恢复的同时把stash内容也删除了 解决git clone 项目中某个文件都需要输入密码1git config --global credential.helper store]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[centos7-控制系统的CPU]]></title>
    <url>%2F2019%2F03%2F15%2Fcentos7-%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9A%84CPU%2F</url>
    <content type="text"><![CDATA[这里是linux的学习基地，我们可以学习一些linux的常用知识]]></content>
      <categories>
        <category>centos7</category>
      </categories>
  </entry>
</search>

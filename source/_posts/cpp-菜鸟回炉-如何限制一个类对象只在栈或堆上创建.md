---
title: cpp-菜鸟回炉-如何限制一个类对象只在栈或堆上创建
categories:
  - Cpp
  - memory
tags: memory
abbrlink: 2137945521
date: 2021-08-10 11:29:42
---

​	有时候你想这样管理某些对象，要让某种类型的对象能够自我销毁，也就是能够“delete this"，很明显这钟管理方式需要此类型的类对象被分配到堆中。而有些时候你想要获取这样一种保障：”不在堆中分配对象，从而保证某种类型的类不会发生内存泄漏。"如果在嵌入式系统上进行工作，就有可能遇到这种情况，发生在嵌入式系统上的内存泄露是非常严重的，其堆空间是非常珍贵的。接下来我们来讨论一下如何限制一个类只在堆或者栈中创建对象。

### 对象实例化方式

我们都知道cpp提供了两种方式供对象的实例化，一种是在栈中实例化对象，由系统管理；一种是在堆中实例化对象，由用户自己管理。如下图：

![limitObject.jpg](/images/memory/limitObject.jpg)

### 只能在堆上创建对象

我们知道在堆上创建对象，就说明，我们只能使用`new Object()`来实例化对象。容易想到将构造函数设为私有。在构造函数私有之后，无法在类外部调用构造函数来构造类对象，只能使用new运算符来建立对象。然而，前面已经说过，new运算符的执行过程分为两步，C++提供new运算符的重载，其实是只允许重载operator new()函数，而operator new()函数只用于分配内存，无法提供构造功能。因此，这种方法不可以。

当对象建立在栈上面时，是由编译器分配内存空间的，调用构造函数来构造栈对象。当对象使用完后，编译器会调用析构函数来释放栈对象所占的空间。编译器管理了对象的整个生命周期。如果编译器无法调用类的析构函数，情况会是怎样的呢？比如，类的析构函数是私有的，编译器无法调用析构函数来释放内存。`所以，编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性，其实不光是析构函数，只要是非静态的函数，编译器都会进行检查。如果类的析构函数是私有的，则编译器不会在栈空间上为类对象分配内存。因此，将析构函数设为私有，类对象就无法建立在栈上了。`代码实现如下：

![createInDui.jpg](/images/memory/createInDui.jpg)

#### 缺点

上述方法的缺点，如果Base作为基类，则析构函数通常会设置为virtual，然后在子类重写，以实现多态。因此析构函数不能设为private。这个困难不是不能克服，通过将Base的析构函数设置为protected(同时它的构造函数还保持public)就可以解决继承的问题。代码如下：

![baseClass.jpg](/images/memory/baseClass.jpg)

![sonClass.jpg](/images/memory/sonClass.jpg)

### 只能在栈上创建对象

我们只需要禁用new运算符就可以实现对象只在栈上创建。虽然你不能影响new operator的能力（因为那是C++语言内建的），但是你可以利用一个事实：new operator 总是先调用 operator new,而后者我们是可以自行声明重写的。因此，将operator new()设为私有即可禁止对象被new在堆上。代码如下：

![createInZhan.jpg](/images/memory/createInZhan.jpg)

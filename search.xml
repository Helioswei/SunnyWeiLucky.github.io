<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ffmpeg-源码编译支持GPU]]></title>
    <url>%2F2020%2F01%2F14%2Fffmpeg-%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%E6%94%AF%E6%8C%81GPU%2F</url>
    <content type="text"><![CDATA[​ 源码编译需要很多的库的支持，一种是基础的库，一种是你需要的编解码信息的库 一，ffmpeg源码的下载1234567在git上找个你需要的版本的库，直接通过git下载git clone https://github.com/FFmpeg/FFmpeg.gitffmpeg 版本 ffmpeg version n4.1.1-3-g53f3f52cuda 版本 CUDA Version 10.0.130（这个版本自带驱动，可以不用安装驱动）drive 驱动版本 Driver Version: 410.48 nv-codec-headers 版本 sdk/8.1 二，基础环境的准备1yum -y install autoconf automake freetype-devel gcc gcc-c++ git libtool make nasm pkgconfig zlib-devel bzip2 bzip2-devel 三，编码过程1，设置环境路径 ​ 在 /etc/profile 文件中，设置 PKG_CONFIG_PATH 路径 12vim /etc/profileexport PKG_CONFIG_PATH=/usr/local/lib64/pkgconfig:/usr/lib64/pkgconfig:/usr/local/lib/pkgconfig:/usr/lib/pkgconfig 2，编码 ​ 配置好configure之后，通过make可以一步步试探你缺少的库是什么，然后在下载，编译 下载完之后，通过命令来配置你需要的东西./configure –help 123456make 编译的常用命令./configuremake -j 10 (编译，并行10个核来一起编译，可以取消)make install (安装)make disclean (卸载)make clean (清除编译) 3，解决gnutls的问题 我们需要手动的安装gnutls，gnutls3.5.19版本的可以，大于这个版本的有问题, http://www.linuxfromscratch.org/blfs/view/svn/postlfs/gnutls.html 有安装的方法 12345678910111213141,安装gnutls需要先安装gnutls，所有先手动下载这个wget https://ftp.gnu.org/gnu/nettle/nettle-3.1.1.tar.gztar zxf nettle-3.1.1.tar.gz ./configure --enable-sharedmakemake install2,安装gnutlswget https://www.gnupg.org/ftp/gcrypt/gnutls/v3.5/gnutls-3.5.19.tar.xzxz -d gnutls-3.5.19.tar.xztar xf gnutls-3.5.19.tarcd gnutls-3.5.19./configure --enable-sharedmakemake install 在安装gnutls时，我们使用./configure –enable-shared时，可能遇到以下的问题; 解决： yum install gmp-devel 解决： yum install libffi libffi-devel ./configure –enable-shared –with-included-libtasn1 解决： yum install libunistring-devel ./configure –enable-shared –with-included-libtasn1 –with-included-unistring 解决： yum install p11-kit-devel yum install unbound unbound-devel unbound-libs ./configure –enable-shared –with-included-libtasn1 –with-included-unistring 4，解决ladspa.h的问题 1yum install ladspa* 5，解决libass的问题 1yum install libass* 6，解决libdc1394-2的问题1234561,官网下载源码https://sourceforge.net/projects/libdc1394/files/libdc1394-2/2，编译./configuremakemake install 7，解决libgsm的问题 1yum install gsm-tools gsm-devel 8，解决libmp3lame版本的问题 12345源码安装，地址git clone https://github.com/gypified/libmp3lame.git./configuremakemake install 9，解决libopencore_amrnb的问题 12345官网下载源码，再手动编译https://sourceforge.net/projects/opencore-amr/files/opencore-amr/ ./configure make make install 10，解决opencv的问题11，解决openh264的问题 12345从git上下载源码git clone https://github.com/cisco/openh264如果下载失败，则直接下载zip包，然后解压安装make ARCH=x86_64make install 12，解决libopenjp2版本的问题 12345678910git下载源码来编译安装git clone https://github.com/uclouvain/openjpeg.git如果下载不下来，则下载zip包解压安装 unzip openjpeg-master.zipcmake 安装mkdir buildcd buildcmake .. -DCMAKE_BUILD_TYPE=Releasemake -j 10make install 13，解决opus的问题 1234567891011#需要手动的下载安装https://ftp.osuosl.org/pub/xiph/releases/opus/#安装步骤wget http://downloads.xiph.org/releases/opus/opus-1.2.1.tar.gztar -zxvf opus-1.2.1.tar.gzcd opus-1.2.1./configuremakemake install#注意：如果pkg_config没有找到，需要手动的设置路径，见前面PKG_CONFIG_PATH路径的设置，如果设置好之后，库也存在还是不行，则要检查是否使用yum下载了低版本的，若是则删除yum remove opus-1.0.2-6.el7.x86_64 opus-tools-0.1.6-1.el7.x86_64 opusfile-0.5-1.el7.x86_64 opus-devel-1.0.2-6.el7.x86_64 opusfile-devel-0.5-1.el7.x86_64 14，解决libpulse的问题15，解决libsoxr的问题 123456#手动下载包，然后编译安装https://sourceforge.net/projects/soxr/files/tar -xvf soxr-0.1.3-Source.tar./gocd Realsemake install 在执行go的时候可能遇到这个问题,则需要下载cmake高级版本 123456# cmake 安装https://cmake.org/download/tar -zxvf cmake-3.13.0-rc1.tar.gz./configuremakemake install 16，解决speex的问题 12345##手动下载安装包，编译，选择 libspeex下载https://xiph.org/downloads/./configure --enable-sharedmakemake install 17，解决libtheora的问题 123456## 手动下载安装包，编译，选择libtheora下载https://xiph.org/downloads/unzip libtheora-1.1.1.zip./configuremakemake install 在configure的过程中，可能error,则我们需要下载安装这个 1yum install libogg* 18，解决libv412的问题19，解决vorbis的问题 12345git clone https://github.com/xiph/vorbis.git./autogen.sh./configure --enable-sharedmakemake install 20，解决libx264的问题 1234git clone --depth 1 http://git.videolan.org/git/x264./configure --enable-sharedmakemake install 如果编译时报错，则需要安装nasm 1234567curl -O -L http://www.nasm.us/pub/nasm/releasebuilds/2.13.02/nasm-2.13.02.tar.bz2 tar -xjvf nasm-2.13.02.tar.bz2cd nasm-2.13.02./autogen.sh ./configure --enable-shared makemake install 21，解决libx265的问题 123456git clone --depth 1 https://github.com/videolan/x265.gitcd x265cd buildcmake ../sourcemakemake install 22，解决libxvid的问题 123456789##官网下载https://www.xvid.com/download/## 按下图过程来查找## 然后按照README来安装cd build/generic./configuremake -j 10make install 23，解决openal的问题 1yum install openal-soft openal-soft-devel 24，解决libcdio的问题25，解决bzlib的问题26，解决libxcb的问题 1yum install libxcb-devel 四，添加硬件编解码1，查看机器上显卡的型号1lspci | grep VGA 2，安装对应显卡的驱动12https://www.nvidia.com/Download/index.aspx?lang=en-us安装的方法见显卡驱动安装的文档 3，重新编译ffmpeg12345678在./configure时添加以下的选项，来重新编译ffmpeg，既可以驱动显卡--enable-cuda-sdk \--enable-cuvid \--enable-nvenc \--enable-nonfree \--enable-libnpp \--extra-cflags=-I/usr/local/cuda/include \--extra-ldflags=-L/usr/local/cuda/lib64 \ 4，查看是否安装成功12使用ffmpeg -hwaccels命令查看支持的硬件加速选项ffmpeg -hwaccels 5，查看cuvid提供的GPU编解码器1ffmpeg -codecs | grep cuvid 6，使用GPU进行转码 用GPU进行转码的命令和软转码命令不太一样，CPU转码的时候，我们可以依赖ffmpeg识别输入视频的编码格式并选择对应的解码器，但ffmpeg只会自动选择CPU解码器，要让ffmpeg使用GPU解码器，必须先用ffprobe识别出输入视频的编码格式，然后在命令行中指定对应的GPU解码器。 例如，将h264编码的源视频转码为指定尺寸和码率的h264编码视频： 1234567ffmpeg -hwaccel cuvid -c:v h264_cuvid -i video/video-H264-AAC.mkv -c:v h264_nvenc -b:v 2048k -vf scale_npp=1280:-1 -y /root/transcode.mp4-hwaccel cuvid：指定使用cuvid硬件加速-c:v h264_cuvid：使用h264_cuvid进行视频解码-c:v h264_nvenc：使用h264_nvenc进行视频编码-vf scale_npp=1280:-1：指定输出视频的宽高，注意，这里和软解码时使用的-vf scale=x:x不一样转码期间使用nvidia-smi查看显卡状态，能够看到ffmpeg确实是在使用GPU进行转码： 如果在执行命令的时候报错，则需要,进行nv-codec-headers和驱动的版本匹配的处理 我开始编译nv-codec-headers使用的是最新版本9.1的，编译出错，有两种方法，一种是升级drive的版本，升级到430以上，这个比较的麻烦，另一种是降低nv-codec-headers的版本，我降低到8.1版本，就可以成功 1234ffmpeg 版本 ffmpeg version n4.1.1-3-g53f3f52cuda 版本 CUDA Version 10.0.130（这个版本自带驱动，可以不用安装驱动）drive 驱动版本 Driver Version: 410.48 nv-codec-headers 版本 sdk/8.1 7,在容器中使用NVIDIA1234在将自己的服务打包成镜像的时候，开始没有设置环境变量，导致怎么都无法调用NVIDIA进行硬件的转码；最后查询了很多的资料，发现需要添加一个环境变量，在Dockfile中ENV NVIDIA_DRIVER_CAPABILITIES video,compute,utility才能保证容器中使用成功 8，gpu和cpu转码测试​ 对于同一个视频，分别采用cpu和GPU两种方式来进行转码，对比这两者之间的效率 12345678910111213141516171819202122232425262728293031323334#机器信息逻辑核：24内存：64G24 Intel(R) Xeon(R) CPU E5-2620 v2 @ 2.10GHz系统：CentOS Linux release 7.6.1810 (Core)#视频信息：name: 11.mkvsize： 1.1GVideo: h264 (High), yuv420p(progressive), 1280x720 [SAR 1:1 DAR 16:9], 25 fps, 25 tbr, 1k tbn, 50 tbc (default)Audio: ac3, 48000 Hz, stereo, fltp, 192 kb/s (default)#软件转码：[time] ffmpeg -i video/11.mkv -c:v libx264 -b:v 2048k -vf scale=1280:-1 -y /root/transcode.mp4#结果real 11m18.807suser 180m16.290ssys 1m36.925scpu占用 平均1600%[time] ./softhw /root/video/11.mkv /opt/nvitra1.mp4real 14m51.166suser 220m2.857ssys 1m21.718scpu占用 平均1600%#硬件转码：[time] ffmpeg -hwaccel cuvid -c:v h264_cuvid -i video/11.mkv -c:v h264_nvenc -b:v 2048k -vf scale_npp=1280:-1 -y /root/transcode.mp4#结果real 1m45.228suser 1m15.910ssys 0m18.734scpu占用 平均90%[time] ./hw /root/video/11.mkv /opt/nvitra.mp4real 1m29.478suser 0m22.754ssys 0m23.465scpu占用 50% 8，指定显卡进行转码12345ffmpeg -hwaccel cuvid -hwaccel_device 0 -c:v h264_cuvid -i &lt;input&gt; -c:v h264_nvenc -b:v 2048k -vf scale_npp=1280:-1 -y &lt;output&gt;ffmpeg -hwaccel cuvid -hwaccel_device 1 -c:v h264_cuvid -i &lt;input&gt; -c:v h264_nvenc -b:v 2048k -vf scale_npp=1280:-1 -y &lt;output&gt;ffmpeg -hwaccel cuvid -hwaccel_device 0 -c:v h264_cuvid -i /root/source_media/flv.flv -c:v h264_nvenc -b:v 2048k -vf scale_npp=1280:-1 -y /root/flv.mp4]]></content>
      <categories>
        <category>ffmpeg</category>
      </categories>
      <tags>
        <tag>ffmpeg</tag>
        <tag>centos7</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[grpc编译]]></title>
    <url>%2F2020%2F01%2F14%2Fgrpc%E7%BC%96%E8%AF%91%2F</url>
    <content type="text"><![CDATA[1环境 centos7 一，安装编译依赖的环境123456yum install -y pkgconfig autoconf automake libtool make gcc-c++ unzipyum install -y gflags-devel gtest-devel clang libcxx-develyum install -y openssl openssl-develyum install -y libunwind libunwind-develyum install -y epel-releaseyum install -y golang 二，源码下载123git clone https://github.com/grpc/grpc.gitcd grpcgit submodule update --init 三，编译1，编译cmake12345678需要下载cmake高级版本，yum安装的版本太低https://cmake.org/download/源码安装cmake，（1）删除原来版本的cmake（2）./configure（3）make &amp;&amp; make install如果找不到，则创建软链接ln -s /usr/local/bin/cmake /usr/bin/cmake 2，先编译protobuf1234567891011cd third_party/protobufgit submodule update --init --recursive./autogen.sh./configure --prefix=/usr/local/helios/protobufmake make checkmake install2,建立软链接ln -s /usr/local/helios/protobuf/bin/protoc /usr/local/bin/protoc检测是否安装成功protoc --version 3，编译grpc（cmake)12345cd grpcmkdir -p cmake/buildcmake -DBUILD_SHARED_LIBS=on -DCMAKE_INSTALL_PREFIX=/usr/local/helios/grpc -DCMAKE_BUILD_TYPE=DEBUG -Wno-dev ../../makemake install 4，编译（make,不建议使用）12342,编译grpccd grpc根目录make -j 4make install 5，问题123456789101112131415161718192021222324252627282930对于cpp的使用，当编译好了之后，运行helloworld程序，没有响应，有很大的问题https://github.com/grpc/grpc/issues/21280#issuecomment-558164977解决方法：修改源码（不使用）vim / src / core / lib / surface / init.ccdiff --git a/src/core/lib/surface/init.cc b/src/core/lib/surface/init.ccindex 2812427f7a..3c6a547b20 100644--- a/src/core/lib/surface/init.cc+++ b/src/core/lib/surface/init.cc@@ -156,7 +156,7 @@ void grpc_init(void) &#123; * at the appropriate time */ grpc_register_security_filters(); register_builtin_channel_init();- grpc_tracer_init();将源码中的这个给注销+ // grpc_tracer_init(); /* no more changes to channel init pipelines */ grpc_channel_init_finalize(); grpc_iomgr_start(); 修改源码：vim src/core/lib/debug/trace.cc void TraceFlagList::Add(TraceFlag* flag) &#123;+ TraceFlag* t;+ for (t = root_tracer_; t; t = t -&gt; next_tracer_) &#123;+ if (t == flag ) return;+ &#125; flag-&gt;next_tracer_ = root_tracer_; root_tracer_ = flag;遍历链表，如果存在则不加入 6，运行helloworld程序12345678910111213141516171819202122232425262728cd examples/cpp/helloworldmake出现问题：which: no grpc_cpp_plugin in (/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin)因为自己配置的路径，所以先给grpc_cpp_plugin 建立软连接ln -s /usr/local/helios/grpc/bin/grpc_cpp_plugin /usr/local/bin/grpc_cpp_pluginhelloworld.pb.h:10:40: fatal error: google/protobuf/port_def.inc: No such file or directory配置cpp头文件路径export CPLUS_INCLUDE_PATH=$CPLUS_INCLUDE_PATH:/usr/local/helios/grpc/includePackage protobuf was not found in the pkg-config search path.Perhaps you should add the directory containing `protobuf.pc&apos;to the PKG_CONFIG_PATH environment variableNo package &apos;protobuf&apos; foundPackage grpc was not found in the pkg-config search path.Perhaps you should add the directory containing `grpc.pc&apos;to the PKG_CONFIG_PATH environment variableNo package &apos;grpc&apos; found配置pkgconfig搜索路径export PKG_CONFIG_PATH=$PKG_CONFIG_PATH:/usr/local/helios/protobuf/lib/pkgconfig/:/usr/local/helios/grpc/lib/pkgconfig/error while loading shared libraries: libgrpc_plugin_support.so.1: cannot open shared object file配置cpp动态库搜索路径export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/local/helios/grpc/lib/:/usr/local/helios/grpc/lib64/:/usr/local/helios/protobuf/lib]]></content>
      <categories>
        <category>grpc</category>
      </categories>
      <tags>
        <tag>grpc</tag>
        <tag>centos7</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ffmpeg-编码的步骤]]></title>
    <url>%2F2019%2F05%2F05%2Fffmpeg-%E7%BC%96%E7%A0%81%E7%9A%84%E6%AD%A5%E9%AA%A4%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;总结一下编码的大致过程，方便自己下一次的处理，分为音频编码和视频 音频编码的过程1，打开输出的文件流12AVFormatContext *ofmt_ctx;avformat_alloc_output_context2(&amp;ofmt_ctx, NULL, NULL, filename); 2，创建输出的音频流1234567891011AVStream *audioStream;AVCodec *encoder;AVCodecContext *enc_ctx;audioStream = avformat_new_stream(ofmt_ctx, NULL);if (!audioStream)&#123; av_log();&#125;encoder = avcodec_find_encoder(AV_CODEC_ID_AAC);if(!encoder)&#123; av_log();&#125; 3，设置编码的上下文1234567891011enc_ctx = avcodec_alloc_context3(encoder);if (!enc_ctx)&#123; av_log();&#125;enc_ctx -&gt; bit_rate = 64000;enc_ctx -&gt; sample_rate = 44100;enc_ctx -&gt; channel_layout = 2;//这个可以根据输入来设置enc_ctx -&gt; channels = av_get_channel_layout_nb_channels(enc_ctx -&gt; channel_layout);enc_ctx -&gt; sample_fmt = encoder -&gt; sample_fmts[0];AVRational time_base = &#123;1, enc_ctx -&gt; sample_rate&#125;;enc_ctx -&gt; time_base = time_base; 4，设置flag12if (ofmt_ctx -&gt; oformat -&gt; flags &amp; AVFMT_GLOBALHEADER) enc_ctx -&gt; flags |= AV_CODEC_FLAG_GLOBAL_HEADER; 5，打开编码器1234ret = avcodec_open2(enc_ctx, encoder, NULL);if (ret &lt; 0)&#123; av_log();&#125; 6，设置codec_tag1audioStream -&gt; codecpar -&gt; codec_tag = 0; 7，copy code to stream1ret = avcodec_parameters_from_context(audioStream -&gt; codecpar, enc_ctx);]]></content>
      <categories>
        <category>ffmpeg</category>
      </categories>
      <tags>
        <tag>ffmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[系统io状态排查]]></title>
    <url>%2F2019%2F04%2F28%2F%E7%B3%BB%E7%BB%9Fio%E7%8A%B6%E6%80%81%E6%8E%92%E6%9F%A5%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;这几天在排查自己写的转码服务性能上不去，转码特别慢，正常情况下，转码时CPU可以飙到很高，但是在问题机器上CPU只要50%左右，排查了好久，最终确定是某个其它服务io资源占用了太多，导致了我的转码服务io占用几乎没有，所以出现了问题，介绍几个io的工具，帮助以后查看系统的情况。 iostat&nbsp;&nbsp;&nbsp;&nbsp;iostat主要是用来查看系统的io使用情况，只记录自己使用的命令 下载1yum install sysstat 使用1iostat [-c ] [ -d ] [ -k ] [ -m ] [ -x ]]]></content>
      <categories>
        <category>centos7</category>
      </categories>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[相机底片的解析]]></title>
    <url>%2F2019%2F04%2F16%2F%E7%9B%B8%E6%9C%BA%E5%BA%95%E7%89%87%E7%9A%84%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;公司要求对相机原生格式如后缀为dng,CR2等的图片进行转码，然后预览，自己查找了一下资料，目前仅仅是用命令行来进行处理的，因为我们是linux端的服务，所以直接封装命令行比较的简单。 DNG数据格式的介绍12http://www.cnblogs.com/adong7639/p/4446828.htmlhttps://blog.csdn.net/wgx571859177/article/details/80755793?utm_source=blogxgwz1 DNG格式基本的概念12345 DNG格式是在TIFF的基础上扩展出来的，要了解DNG，需要清楚TIFF,TIFF/EP,DNG,RAW之间的关系。 DNG（Digital Negative）是Adobe开发的一种开发的raw image file format ,主要是为了统一不同厂商的raw格式。里面使用的tag基本上都定义在TIFF或者TIFF/EP 中，在DNG Sepcification中只是定义或者建议了数据的组织方式，颜色空间的转换等等。 TIFF/EP12345678TIFF是一个灵活适应性强的文件格式。通过在文件标头中使用&quot;标签&quot;，它能够在一个文件中处理多幅图像和数据。标签能够标明图像的如图像大小这样的基本几何尺寸，或者定义图像数据是如何排列的，或者是否使用了各种各样的图像压缩选项。TIFF/EP的全称是&quot;Tag Image File Format / Electronic Photography&quot;。 它是一个名为&quot;Electronic still-picture imaging – Removable memory – Part 2: TIFF/EP image data format&quot;ISO标准， 标准号为ISO12234-2。TIFF/EP对TIFF文件扩展部分标记属性。 RAW12345678910111213RAW文件包含创建一个可视图像所必须的相机传感器数据信息。RAW文件的结构，包括ISO标准的RAW图像格式ISO 12234-2 ，TIFF / EP，往往遵循一个共同的模式，那就是：一个短的文件头，它通常包含文件的字节顺序，文件标识符和主数据的文件偏移量摄像传感器元数据，用来描述图像传感器的数据，包括传感器的尺寸， 颜色滤波矩阵(color filter array)的属性和它的颜色配置文件列入任何CMS环境或数据库中需要的图像元数据。这些措施包括曝光设定，相机/扫描仪/镜头模型，拍摄/扫描日期（和可选的位置信息），创作信息和其他。一些原始文件包含可交换图像格式的标准化元数据节；图像缩略图；可选的JPEG格式缩小尺寸的图像，可用于快速预览；在电影胶片扫描中，无论是文件序列的时间码，序列码或帧编号都代表在扫描卷轴中的帧顺序。这个项目允许文件被被按帧顺序排列（不依赖于它的文件名​）；传感器图像数据； 常见的RAW格式1234许多RAW格式, 包括 3FR (Hasselblad), DCR, K25, KDC (Kodak), IIQ (Phase One), CR2 (Canon), ERF (Epson), MEF (Mamiya), MOS (Leaf), NEF (Nikon), ORF (Olympus), PEF (Pentax), RW2 (Panasonic) and ARW, SRF, SR2 (Sony), 都是基于TIFF格式。 这些文件可能在许多方面偏离TIFF标准，包括使用一个非标准的文件头，列入额外的图像标记和一些标签的数据加密。 TIFF, TIFF/EP, DNG, RAW之间的关系1234567TIFF和DNG同为Specification，分别定义了后缀名为.tif/.tiff和.dng的文件格式同时在TIFF Specification也定义个baseline及部分扩展的tag。TIFF/EP则定义并规范了在电子影像中所使用的TAG。DNG同时与TIFF和TIFF/EP兼容，并包含了EXIF和XMP信息。DNG实际上就是扩张的TIFF， 把DNG的扩展名改成TIF就可以直接预览图片。在DNG出现以前，各个数码相机制造商都有自己的格式，比如Canon(cr2/crw), Nikon(nef), Olympus(orf), Pentex(pef)等等。之所以出现这么多格式，一方面的原因是在这之前没有统一的raw格式， 但更重要的是，各个厂商希望用这个只对自己公开的数据格式来保护自己的私密信息。Adobe推出DNG希望能一统raw的天下。 处理不同格式RAW或者DNG底片的方法&nbsp;&nbsp;&nbsp;&nbsp;为了能够得到RAW格式或者DNG格式的jpg图片供我们预览，可以使用DCRAW和ffmpeg来结合使用 dcraw介绍1https://blog.csdn.net/bi_diu1368/article/details/80411304 123451,dcraw 下载 yum install dcraw2.1,如果相机底片有缩略图，则直接可以通过 dcraw -e test.dng 获得其缩略图（注意，缩略图也有不存在的时候）2.2,如果没有缩略图，则可以先将RAW格式的转化为ppm dcraw -v test.dng 获取其ppm的图片；然后在通过ffmpeg可以将 ppm格式的图片转码jpg ffmpeg -i test.ppm out.jpg]]></content>
      <categories>
        <category>图片处理</category>
      </categories>
      <tags>
        <tag>image</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo-常用命令]]></title>
    <url>%2F2019%2F04%2F12%2Fhexo-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;记录一下hexo经常使用的命令，发现自己好久没有hexo，命令都不记得了。 新建文章1hexo new &quot;postname&quot; (hexo n postname) 新建页面1hexo new page &quot;pagename&quot; 启动本地web服务12hexo server (hexo s)本地网址：localhost:4000 生成静态文件1hexo generate (hexo g) 生成部署1hexo d -g 生成预览1hexo s -g 清理public文件夹1hexo clean]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ffmpeg_avfilter的使用详解]]></title>
    <url>%2F2019%2F03%2F27%2Fffmpeg-avfilter%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;在ffmpeg，我们对视音频进行一些处理，如添加水印，有个很方便的库，avfilter， 过滤的过程解码后的画面 -&gt; buffer过滤器 -&gt; 其他过滤器 -&gt; buffersink 过滤器 -&gt; 处理好的画面]]></content>
      <categories>
        <category>ffmpeg</category>
      </categories>
      <tags>
        <tag>ffmpeg</tag>
        <tag>avfilter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown语言的总结]]></title>
    <url>%2F2019%2F03%2F18%2Fmarkdown%E8%AF%AD%E8%A8%80%E7%9A%84%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[s3-关于s3cmd的下载]]></title>
    <url>%2F2019%2F03%2F18%2Fs3-%E5%85%B3%E4%BA%8Es3cmd%E7%9A%84%E4%B8%8B%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;很多人都用过对象存储，比如亚马逊的s3平台，我想大家都比较熟悉，今天来介绍一款工具，用来在centos7平台上方便的操作对象存储的东西，比如查看自己的桶，创建桶等。 s3cmd的下载第一步下载get-pip.py wget https://bootstrap.pypa.io/get-pip.py 第二步安装get-pip.py python get-pip.py 第三步安装s3cmd pip install s3cmd 第四步设置.s3cfg 设置三个比较主要的]]></content>
      <categories>
        <category>s3对象存储</category>
      </categories>
      <tags>
        <tag>centos7</tag>
        <tag>s3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[others-时间管理]]></title>
    <url>%2F2019%2F03%2F15%2Fothers-%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[目标设定是第一步，提供路线图 你的目标是什么？短期内。你希望达成什么样的愿望？长期来说。你希望你的人生是什么样子？]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[cpp-关于内存泄漏的问题]]></title>
    <url>%2F2019%2F03%2F15%2Fcpp-%E5%85%B3%E4%BA%8E%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[今天我们讨论一些怎么处理内存泄漏的问题]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
        <tag>ffmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git-常用的命令]]></title>
    <url>%2F2019%2F03%2F15%2Fgit-%E5%B8%B8%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;记录一些git常用的命令，便于在长时间不用时能够有个地方查阅，下面的几个是经常用到的。在windows下使用git，许多朋友都说无法使用一些状态（修改，保存，提交）图标，是因为图标显示不是git本身的功能呢，我们需要下载TortoiseGit才能使用图标。 重命名文件夹1git mv -f oldfolder newfolder 删除中间的某次提交1git revert commit id 版本回退12git reset --hard commitid这个不会保留之前的记录 撤销本地提交123git reset --soft commitidgit reset --mixed commitid两者的区别，--soft会将改动放在缓存区 --mixed不会讲改动放在缓存区 撤销远程的提交123git loggit reset --hard commitidgit push origin HEAD:master --force 强制提交1git push -u origin master -f 将某个分支的提交copy到另一个分支上1234例如，有两个分支，a,b,想要将a的某次提交，copy到b分支上1,在a分支上 git log 查询commitid2,git checkout b 切换分支3,git cherry-pick commitid 统计当前分支的提交数目1git rev-list HEAD | wc -l 将当前工作区的修改暂存起来123456git stash 冻结当前的分支修改git stash save &quot;说明信息&quot;git stash list 列出所有的工作现场存储git stash apply stash@&#123;n&#125; 恢复某个工作现场git stash drop stash@&#123;n&#125; 删除存储的某个工作现场git stash pop stash@&#123;n&#125; 恢复的同时把stash内容也删除了]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[centos7-控制系统的CPU]]></title>
    <url>%2F2019%2F03%2F15%2Fcentos7-%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9A%84CPU%2F</url>
    <content type="text"><![CDATA[这里是linux的学习基地，我们可以学习一些linux的常用知识]]></content>
      <categories>
        <category>centos7</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F03%2F08%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
